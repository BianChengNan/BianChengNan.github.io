<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>BianChengNan&#39;s Blog</title>
  
  <subtitle>Coding is hard, you can make it easy!</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://bianchengnan.github.io/"/>
  <updated>2024-05-18T08:56:44.218Z</updated>
  <id>https://bianchengnan.github.io/</id>
  
  <author>
    <name>BianChengNan</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>置顶声明</title>
    <link href="https://bianchengnan.github.io//articles/top-most-announcement/"/>
    <id>https://bianchengnan.github.io//articles/top-most-announcement/</id>
    <published>2025-03-01T01:29:14.000Z</published>
    <updated>2024-05-18T08:56:44.218Z</updated>
    
    <content type="html"><![CDATA[<p>实在抱歉，因为图床的原因，可能文章中的某些图片看不到，如果需要查看相关图片，请联系我，或者到我的公众号里查看。</p><p>我的个人微信号是 <code>BianChengNan</code>，公众号是 <code>编程难</code>。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;实在抱歉，因为图床的原因，可能文章中的某些图片看不到，如果需要查看相关图片，请联系我，或者到我的公众号里查看。&lt;/p&gt;
&lt;p&gt;我的个人微信号是 &lt;code&gt;BianChengNan&lt;/code&gt;，公众号是 &lt;code&gt;编程难&lt;/code&gt;。&lt;/p&gt;

      
    
    </summary>
    
      <category term="原" scheme="https://bianchengnan.github.io/categories/%E5%8E%9F/"/>
    
    
      <category term="原" scheme="https://bianchengnan.github.io/tags/%E5%8E%9F/"/>
    
  </entry>
  
  <entry>
    <title>2024 开工喽</title>
    <link href="https://bianchengnan.github.io//articles/2024-startup/"/>
    <id>https://bianchengnan.github.io//articles/2024-startup/</id>
    <published>2024-02-20T13:15:25.000Z</published>
    <updated>2024-05-18T08:56:43.530Z</updated>
    
    <content type="html"><![CDATA[<h2 id="回首-2023"><a href="#回首-2023" class="headerlink" title="回首 2023"></a>回首 2023</h2><p>回顾整个 <code>2023</code> ，相比 <code>2022</code>  加班少了，工作没那么拼命了。</p><p>由于各种原因，年初立的 <code>flag</code> 好几个都没实现。</p><ul><li>公众号基本上处于鸽的状态</li><li>也没分享技术视频</li><li>语言倒是接触了一下 <code>rust</code>，但远没有达到能实战的地步</li><li>嘴没管住，腿倒是迈开了</li></ul><h2 id="展望-2024"><a href="#展望-2024" class="headerlink" title="展望 2024"></a>展望 2024</h2><p>我对 <code>2024</code> 这个数字感到非常亲切，<code>2024 = 1000 + 1024</code>，两个<strong>一千</strong></p><ul><li><p><strong>今年的首要任务依旧是锻炼身体</strong></p><p>本来计划 <code>2024</code> 年跑步作为日常锻炼的方式，结果 <code>2023</code> 年最后一次从公司跑回家后膝盖疼，<code>2024</code> 只能偶尔跑跑了</p></li></ul><ul><li><strong>继续遛狗</strong><br><code>2023</code> 花费了很大一部分时间在遛狗上，<code>2024</code> 继续努力。如果不是狗子的陪伴，估计我早抑郁了，感谢，感恩。</li></ul><ul><li><p><strong>坚持练习英语口语</strong></p><p>希望这次不要因为任何原因中断</p></li></ul><ul><li><p><strong>继续坚持分享技术文章</strong></p><p>遇到值得总结的问题，及时总结分享</p></li></ul><ul><li><p><strong>读一些非技术书籍</strong></p><p>之前看的书以技术书籍为主，<code>2024</code> 年争取多看些非技术的书籍</p></li></ul><ul><li><p><strong>做一些改变</strong></p><p>尽量熟悉 <code>AI</code> 相关的人和事</p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;回首-2023&quot;&gt;&lt;a href=&quot;#回首-2023&quot; class=&quot;headerlink&quot; title=&quot;回首 2023&quot;&gt;&lt;/a&gt;回首 2023&lt;/h2&gt;&lt;p&gt;回顾整个 &lt;code&gt;2023&lt;/code&gt; ，相比 &lt;code&gt;2022&lt;/code&gt;  加班少了
      
    
    </summary>
    
      <category term="年度总结" scheme="https://bianchengnan.github.io/categories/%E5%B9%B4%E5%BA%A6%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="原" scheme="https://bianchengnan.github.io/tags/%E5%8E%9F/"/>
    
  </entry>
  
  <entry>
    <title>调试实战 | 记一次有教益的递归栈查看（续）</title>
    <link href="https://bianchengnan.github.io//articles/how-to-view-startup-function-from-a-deep-recursive-stack-continue/"/>
    <id>https://bianchengnan.github.io//articles/how-to-view-startup-function-from-a-deep-recursive-stack-continue/</id>
    <published>2024-01-06T02:30:22.000Z</published>
    <updated>2024-05-18T08:56:43.939Z</updated>
    
    <content type="html"><![CDATA[<h2 id="缘起"><a href="#缘起" class="headerlink" title="缘起"></a>缘起</h2><p>在上篇<a href="https://bianchengnan.gitee.io/articles/how-to-view-startup-function-from-a-deep-recursive-stack/" target="_blank" rel="noopener">文章</a>中介绍了在 <code>windbg</code> 中如何查看非常深的调用栈 —— 使用 <code>kN</code> 命令指定栈帧数。<code>kN</code> 虽好，但最多只能查看 <code>0xffff</code> 个栈帧。如果栈帧数量比 <code>0xffff</code> 还多，该如何查看呢？本文将介绍几种查看方法。</p><a id="more"></a><p>在介绍查看方法前，需要对线程栈的特点有个基本的认识。</p><h2 id="线程栈的关键特性"><a href="#线程栈的关键特性" class="headerlink" title="线程栈的关键特性"></a>线程栈的关键特性</h2><ul><li><p>线程栈是从高向低扩展的，当向栈上 <code>push</code> 一个值的时候，栈底指针 <code>esp</code> 的值会减小。</p></li><li><p>函数返回地址会保存到栈上：</p><p>函数 <code>A</code> 调用函数 <code>B</code> 的时候，会把 <code>B</code> 需要的参数根据调用约定放到对应的位置，有可能是通过寄存器传递，也有可能通过栈传递。处理完参数后会执行 <code>call B</code>，而 <code>call</code> 指令可以简单理解为以下两个操作：</p><ol><li><strong>把返回地址（调用函数 B 的下一条指令地址）入栈</strong></li><li><strong>跳转到函数 <code>B</code> 继续执行</strong></li></ol><p>如果函数 <code>B</code> 会调用另外一个函数 <code>C</code>，那么会遵循相同的规律：会把返回地址（ <strong><code>call C</code> 后面的地址</strong>）入栈，然后跳转到 <code>C</code> 继续执行。当 <code>C</code> 执行结束的时候，<code>CPU</code> 会从栈上把保存的返回地址弹出到 <code>rip</code> 中，这样就可以继续从函数 <code>B</code> 中调用函数 <code>C</code> 的下一条指令继续执行了。</p></li></ul><p>根据以上几点可以得到一个非常重要的结论：如果 <code>A</code> 调用了 <code>B</code>，<code>B</code> 又调用了 <code>C</code>，<code>C</code> 又调用了 <code>D</code>。那么 <code>B</code> 返回到 <code>A</code> 的地址在线程栈的高处，<code>C</code> 返回到 <code>B</code> 的地址在线程栈的低处，<code>D</code> 返回到 <code>C</code> 的地址在线程栈的最低处。</p><p>有了以上的基本认识，就可以使用以下几种方法查看调用栈了。</p><h2 id="查看方法"><a href="#查看方法" class="headerlink" title="查看方法"></a>查看方法</h2><p><strong>方法1：</strong>使用 <code>.kframes</code> 设置默认显示的栈帧数量</p><p>​    增大默认显示数量，这样就可以一次性显示更多的调用栈</p><p><strong>方法2：</strong>使用 <code>dps</code>，自己识别调用栈</p><p>​    可以灵活高效的从指定的位置开始查找</p><p><strong>方法3：</strong>使用 <code>k</code> 命令的时候指定 <code>StackPtr</code></p><p>​    可以从指定位置开始显示调用栈，不必从头开始显示</p><p>为了方便验证每种方法的可行性，我写了一个非常简单的递归调用测试程序，为了让调用栈可以更深一些，我修改了工程设置中的<strong>堆栈保留大小</strong>为 <code>0x70800000</code>（大概 <code>1.75 GB</code> ）。</p><h2 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Recursive</span><span class="params">(<span class="keyword">int</span> depth)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (depth &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        Recursive(--depth);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CallRecursive</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Recursive(<span class="number">0x7fffffff</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    CallRecursive();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试工程可以到<a href="https://gitee.com/bianchengnan/my-blog-stuff/tree/master/how-to-view-startup-function-from-a-deep-recursive-stack-continue" target="_blank" rel="noopener">这里</a>下载。</p><p>接下来依次介绍每种查看方法。</p><h2 id="方法1：使用-kframes-设置默认显示的栈帧数量"><a href="#方法1：使用-kframes-设置默认显示的栈帧数量" class="headerlink" title="方法1：使用 .kframes 设置默认显示的栈帧数量"></a>方法1：使用 <code>.kframes</code> 设置默认显示的栈帧数量</h2><p>在 <code>windbg</code> 的帮助文档中发现可以通过 <code>.kframes</code> 命令来设置 <code>k</code> 命令默认显示的栈帧数量。但是也不是可以显示无限多个栈帧。</p><p>那么通过 <code>.kframes</code> 可以设置的最大栈帧数是多少呢？通过几次尝试，我发现 <code>.kframes</code> 可以接受的最大值是 <code>32</code> 位的带符号整数的最大值，也就是 <code>0x7fffffff</code>（对应的十进制是 <code>2147483647</code>）。</p><p><img src="http://resources.bianchengnan.tech/how-to-view-startup-function-from-a-deep-recursive-stack-continue/try-to-find-max-kframes-number.png" alt="try-to-find-max-kframes-number"></p><p> 但是，如果通过 <code>.kframes</code> 命令把栈帧数设置为 <code>0x7fffffff</code> 后，再执行 <code>k</code> 命令，发现 <code>windbg</code> 会直接提示内存分配失败。</p><p><img src="http://resources.bianchengnan.tech/how-to-view-startup-function-from-a-deep-recursive-stack-continue/windbg-k-failed-after-kframes-set-to-0x7fffffff.png" alt="windbg-k-failed-after-kframes-set-to-0x7fffffff"></p><p>尝试把栈帧数设置为 <code>0x1000000</code>，再执行 <code>k</code> 命令，发现 <code>windbg</code> 的内存占用非常高，高峰期大概消耗了 <code>20GB</code> 的物理内存（下图中的 <code>Working Set</code> 列），经过将近两分钟的努力，最终还是以内存分配失败告终~</p><p><img src="http://resources.bianchengnan.tech/how-to-view-startup-function-from-a-deep-recursive-stack-continue/windbg-memory-usage-kframe-0x10000000.png" alt="windbg-memory-usage-kframe-0x10000000"></p><p>又试了几个更小的值，发现在我的机器上（<code>24GB</code> 物理内存）设置为 <code>0x1000000</code> 时可以输出结果，但是因为数据量太大了，等了半个多小时也没执行完~</p><p>虽然这次 <code>.kframes</code> 没能成功，但这绝对是一个非常值得了解的命令，可以处理绝大多数情况下的线程栈查看问题。</p><p><strong>优点：</strong> </p><ol><li>操作非常简单</li><li>可以处理绝大多数情况</li></ol><p><strong>缺点：</strong> </p><ol><li>会影响后续 <code>k</code> 命令默认显示效果（仅限当前调试会话，<code>windbg</code> 重启后会自动失效）</li><li>当调用栈过深的时候，<code>k</code> 命令可能会<strong>非常非常非常</strong>慢（对于示例程序，半个小时还没执行完）</li><li>内存占用可能会非常高（需要分配内存来显示对应的信息）</li><li>不能解决调用栈过深的问题（受到物理内存的限制）</li><li>很难找到一个合适的值（设置的太大，可能消耗过多的资源，运行慢；设置的太小，调用栈可能显示不全）</li></ol><h2 id="方法2：使用-dps，自己识别调用栈"><a href="#方法2：使用-dps，自己识别调用栈" class="headerlink" title="方法2：使用 dps，自己识别调用栈"></a>方法2：使用 <code>dps</code>，自己识别调用栈</h2><p>在 <code>windbg</code> 中可以通过 <code>dps</code> 以指针长度为单位打印出指定内存范围的值，同时会输出匹配的符号。</p><p><strong>操作步骤：</strong></p><ol><li>通过 <code>!teb</code> 指令找到栈顶（<code>StackBase</code>）的位置，然后减去一定的值（比如 <code>64kb</code>）得到一个较低的地址 <code>A</code>。</li><li>执行 <code>dps A StackBase</code>。如果输出结果中没有包含感兴趣的函数，可以减去一个更大的值，再次执行 <code>dps</code> 并查看输出结果，直到输出结果中包含感兴趣的函数为止。</li><li>根据 <code>dps</code> 的输出内容手动识别调用栈。</li></ol><p><strong>实战：</strong></p><p>通过 <code>!teb</code> 命令获取栈顶位置（<code>0000002a33800000</code>）然后减去 <code>64KB</code> （<code>0x10000</code>，也可以换成其它值，一般情况下 <code>64KB</code> 足够了）得到地址 <code>0000002a337f0000</code>，然后执行 <code>dps 0000002a337f0000 0000002a33800000</code>。或者可以直接直接输入 <code>dps 0000002a33800000-0x10000 0000002a33800000</code>。</p><p><img src="http://resources.bianchengnan.tech/how-to-view-startup-function-from-a-deep-recursive-stack-continue/windbg-dps.png" alt="windbg-dps"></p><p>根据 <code>dps</code> 的结果可知，已经包含了关键的递归函数 —— <code>TestDeepRecursive!Recursive</code>，可以根据此次 <code>dps</code> 的输出结果手动识别调用栈。拉到输出结果的最下方，可以看到输出结果如下图：</p><p><img src="http://resources.bianchengnan.tech/how-to-view-startup-function-from-a-deep-recursive-stack-continue/windbg-dps-manual-reconstruct-callstack.png" alt="windbg-dps-manual-reconstruct-callstack"></p><p>从上图可以看到 <code>main</code> 函数，<code>CallRecursive</code> 函数，<code>Recursive</code> 函数。而且与 <code>vs</code> 中的调用栈完美匹配。</p><p><img src="http://resources.bianchengnan.tech/how-to-view-startup-function-from-a-deep-recursive-stack-continue/view-callstack-in-vs.png" alt="view-callstack-in-vs"></p><blockquote><p><strong>说明：</strong> 输出结果中<strong>极有可能</strong>包含很多无关的信息（比如上图中的黄色高亮部分），需要仔细甄别。</p></blockquote><p><strong>优点：</strong> </p><ol><li>输出结果速度非常快</li><li>非常灵活，强大</li></ol><p><strong>缺点：</strong></p><ol><li>需要对线程栈有一定的认识</li><li>需要人肉识别调用栈，有一定难度</li><li>比较依赖调试符号，如果没有调试符号，只根据地址信息，很难找出关联关系</li><li>容易出错，因为栈上的内容比较杂，可能包含很多无关的信息</li></ol><h2 id="方法3：使用-k-命令的时候指定-StackPtr"><a href="#方法3：使用-k-命令的时候指定-StackPtr" class="headerlink" title="方法3：使用 k 命令的时候指定 StackPtr"></a>方法3：使用 <code>k</code> 命令的时候指定 <code>StackPtr</code></h2><p>前两种方法都有各自的优缺点，可以在前两种方法的基础上使用本方法——使用 <code>k</code> 命令的时候指定正确的 <code>StackPtr</code>，<code>windbg</code> 会自动帮我们识别调用栈。</p><p>使用本方法时需要传递一个<strong>正确</strong>的 <code>StackPtr</code>（调试 <code>x64</code> 程序时需要传递 <code>rsp</code>，调试 <code>x86</code> 程序时需要传递 <code>ebp</code>，也叫 <code>BasePtr</code> ），也可以同时指定要显示的栈帧数量。</p><p>关于 <code>k</code> 命令的帮助文档可以参考下图（截取自 <code>windbg</code> 帮助文档）：</p><p><img src="http://resources.bianchengnan.tech/how-to-view-startup-function-from-a-deep-recursive-stack-continue/windbg-k-command-help.png" alt="windbg-k-command-help"></p><p>如果传递的 <code>StackPtr</code> 不对，那么输出结果很可能是错误的。比如，我使用一个错误的值执行 <code>k=0x0000002a337ff938</code> 输出结果如下：</p><p><img src="http://resources.bianchengnan.tech/how-to-view-startup-function-from-a-deep-recursive-stack-continue/output-of-wrong-stackptr-k-command.png" alt="output-of-wrong-stackptr-k-command"></p><p>所以，传递一个正确的 <code>StackPtr</code> 是必须的。那么，该如何获取一个正确的 <code>StackPtr</code> 呢？有两个方法：</p><ol><li><p>执行 <code>k</code> 命令的时候，最左侧那一列就是 <code>rsp</code>（<code>x86</code> 程序对应着 <code>ebp</code>）。可以这样处理：先通过 <code>.kframes</code> 设置一个相对合理的值，然后执行 <code>k</code> 命令，等命令执行完，取最后一条输出结果的 <code>rsp</code> 的值，假设是 <code>00000029c3004040</code>，然后执行 <code>k=00000029c3004040 3</code>，就可以继续显示后续的三条调用栈了。重复此过程即可。<br><img src="http://resources.bianchengnan.tech/how-to-view-startup-function-from-a-deep-recursive-stack-continue/windbg-k-start-at-specific-address.png" alt="windbg-k-start-at-specific-address"><br>实际使用的时候，可以尽量每次多显示一些栈帧，如果调用栈非常深，需要重复的次数会很多，但总比不能查看强！</p></li><li><p>在 <code>dps</code> 的输出结果中 <strong>“猜”</strong> 一个 <code>ebp</code> 或者 <code>rsp</code> 的值。说是猜，其实是有规律的。</p><p>2.1 对于 <code>x86</code> 的程序，<code>ebp</code> 保存了调用者的 <code>ebp</code>，<code>ebp+4</code> 的位置保存了返回地址。<br><img src="http://resources.bianchengnan.tech/how-to-view-startup-function-from-a-deep-recursive-stack-continue/view-ebp-by-dps.png" alt="view-ebp-by-dps"></p><p>根据上图可以猜测，一个合法的 <code>ebp</code> 的值是 <code>0x009ef908</code>。</p><p>在 <code>windbg</code> 中输入 <code>k=0x09ef908 0x100</code>，可以得到下图完美的调用栈：<img src="http://resources.bianchengnan.tech/how-to-view-startup-function-from-a-deep-recursive-stack-continue/k-0x009ef908-0x100.png" alt="k-0x009ef908-0x100"></p><p>2.2 对于 <code>x64</code> 的程序，<code>rsp-8</code> 的位置保存了返回地址。可以根据有意义的符号名称对应的最左侧地址值 <code>+8</code> 得到 <code>rsp</code> 的值。</p><p><img src="http://resources.bianchengnan.tech/how-to-view-startup-function-from-a-deep-recursive-stack-continue/view-rsp-by-dps.png" alt="view-rsp-by-dps"></p><p>根据上图可知，一个合法的 <code>rsp</code> 的值是 <code>0x0000002a337ffbd0</code>。在 <code>windbg</code> 中输入 <code>k=0x0000002a337ffbd0 0x100</code>，可以得到下图完美的调用栈：</p><p><img src="http://resources.bianchengnan.tech/how-to-view-startup-function-from-a-deep-recursive-stack-continue/k-0000002a337ffbd0-0x100.png" alt="k-0000002a337ffbd0-0x100"></p></li></ol><p><strong>优点：</strong></p><ol><li>输出效率高，只需要显示关心的栈帧即可</li><li>不用自己识别调用栈，可以像普通的 <code>k</code> 命令一样输出调用栈</li></ol><p><strong>缺点：</strong></p><ol><li>需要指定一个合法的 <code>StackPtr</code>，不能随便指定</li><li>需要非常了解  <code>x86/x64</code> 程序的调用栈，这样才能比较快速准确的找到合法的 <code>StackPtr</code></li></ol><p>所以，<code>dps</code> <code>+</code> <code>k=StackPtr [FrameCount]</code> 是最高效，最优雅的解决方案。</p><blockquote><p><strong>说明：</strong> 如果知道了一个合法的 <code>StackPtr</code>，也可以先通过 <code>r rsp = StackPtr</code> 修改 <code>rsp</code> 寄存器的值，然后再执行 <code>k</code> 命令显示调用栈。但是这个方法有一个<strong>特别不好</strong>的地方，<code>rsp</code> 会被修改，后续用到 <code>rsp</code> 寄存器的命令都会受影响。因此，不推荐使用。</p></blockquote><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>使用 <code>.kframes</code> 可以设置默认显示的栈帧数，可以突破默认最多显示 <code>0xffff</code> 个栈帧的限制，但是注意如果设置的值太大，会非常消耗内存</li><li><code>dps</code> 可以按指针打印一系列的值，并且会显示匹配的符号。务必记住此命令，非常有用</li><li>使用 <code>k</code> 命令时，可以指定 <code>StackPtr</code> 来从指定位置开始显示调用栈</li><li>对于 <code>x86</code> 的程序，<code>ebp</code> 保存了调用者的 <code>ebp</code>，<code>ebp+4</code> 的位置保存了返回地址。<strong>非常重要！！！</strong></li><li>对于 <code>x64</code> 的程序，<code>rsp-8</code> 的位置保存了返回地址。<strong>非常重要！！！</strong></li></ul><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://devblogs.microsoft.com/oldnewthing/20130906-00/?p=3303" target="_blank" rel="noopener">https://devblogs.microsoft.com/oldnewthing/20130906-00/?p=3303</a></p><p><a href="https://blog.aaronballman.com/2011/07/reconstructing-a-corrupted-stack-crawl/" target="_blank" rel="noopener">https://blog.aaronballman.com/2011/07/reconstructing-a-corrupted-stack-crawl/</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;缘起&quot;&gt;&lt;a href=&quot;#缘起&quot; class=&quot;headerlink&quot; title=&quot;缘起&quot;&gt;&lt;/a&gt;缘起&lt;/h2&gt;&lt;p&gt;在上篇&lt;a href=&quot;https://bianchengnan.gitee.io/articles/how-to-view-startup-function-from-a-deep-recursive-stack/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;文章&lt;/a&gt;中介绍了在 &lt;code&gt;windbg&lt;/code&gt; 中如何查看非常深的调用栈 —— 使用 &lt;code&gt;kN&lt;/code&gt; 命令指定栈帧数。&lt;code&gt;kN&lt;/code&gt; 虽好，但最多只能查看 &lt;code&gt;0xffff&lt;/code&gt; 个栈帧。如果栈帧数量比 &lt;code&gt;0xffff&lt;/code&gt; 还多，该如何查看呢？本文将介绍几种查看方法。&lt;/p&gt;
    
    </summary>
    
      <category term="调试" scheme="https://bianchengnan.github.io/categories/%E8%B0%83%E8%AF%95/"/>
    
    
      <category term="调试" scheme="https://bianchengnan.github.io/tags/%E8%B0%83%E8%AF%95/"/>
    
      <category term="debug" scheme="https://bianchengnan.github.io/tags/debug/"/>
    
      <category term="dump" scheme="https://bianchengnan.github.io/tags/dump/"/>
    
      <category term="windbg" scheme="https://bianchengnan.github.io/tags/windbg/"/>
    
      <category term="stack" scheme="https://bianchengnan.github.io/tags/stack/"/>
    
      <category term="递归" scheme="https://bianchengnan.github.io/tags/%E9%80%92%E5%BD%92/"/>
    
      <category term="栈" scheme="https://bianchengnan.github.io/tags/%E6%A0%88/"/>
    
  </entry>
  
  <entry>
    <title>调试实战 | 记一次有教益的递归栈查看</title>
    <link href="https://bianchengnan.github.io//articles/how-to-view-startup-function-from-a-deep-recursive-stack/"/>
    <id>https://bianchengnan.github.io//articles/how-to-view-startup-function-from-a-deep-recursive-stack/</id>
    <published>2024-01-06T02:00:22.000Z</published>
    <updated>2024-05-18T08:56:43.945Z</updated>
    
    <content type="html"><![CDATA[<h2 id="缘起"><a href="#缘起" class="headerlink" title="缘起"></a>缘起</h2><p>最近，遇到了一个由于递归导致的卡死问题。这个问题非常有意思，值得总结。</p><p>你知道什么情况下无限递归会卡死，而不崩溃吗？你知道递归层数过多时，如何找到导致递归调用的函数吗？你知道如何快速找到关键线程吗？你知道如何附加到一个正在被调试的进程吗？你知道如何在 <code>windbg</code> 中显示指定数量的栈帧吗？</p><p>带着这些疑问，一起来看看这个非常有意思的问题吧。</p><blockquote><p><strong>说明：</strong> 文章末尾有这些问题的答案，可以直接跳到末尾查看。</p></blockquote><a id="more"></a><h2 id="初遇错误"><a href="#初遇错误" class="headerlink" title="初遇错误"></a>初遇错误</h2><p>程序在执行某个功能时，迟迟不能完成，通过任务管理器可以发现 <code>CPU</code> 使用率比较高（<code>12.47%</code>），大概耗尽了一个核心（机器是八核的，每个核心占 <code>12.5%</code>）。</p><p><img src="http://resources.bianchengnan.tech/how-to-view-startup-function-from-a-deep-recursive-stack/high-cpu.png" alt="high-cpu"></p><p>心中暗喜，大概率是遇到了死循环，应该很好解决。赶紧用 <code>vs</code> 附加上去看看。</p><h2 id="了解错误"><a href="#了解错误" class="headerlink" title="了解错误"></a>了解错误</h2><p>附加到被调试进程后，手动暂停，然后通过<strong>并行堆栈</strong>找到可疑线程。</p><blockquote><p><strong>温馨提示：</strong> 可以通过 <code>调试 -&gt; 窗口 -&gt; 并行堆栈</code> 打开<strong>并行堆栈</strong>视图，也可以使用快捷键 <code>Ctrl+Shift+D, S</code> 打开 。</p></blockquote><p>一般情况下调用栈最长的线程就是可疑线程。即使不是，也可以在<strong>并行堆栈</strong>视图中快速切换线程。相比于手动一个个切换线程，并行堆栈简直是太方便了！</p><p><img src="http://resources.bianchengnan.tech/how-to-view-startup-function-from-a-deep-recursive-stack/view-thread-stack.png" alt="view-thread-stack"></p><p>通过并行堆栈视图，可以观察到当前线程的调用栈非常深，已经超出了 <code>vs</code> 所支持的最大栈帧数。仔细观察调用栈，可以发现 <code>00007ffc9dcb3cb5</code> 这个地址会<strong>重复</strong>出现，说明这很可能是一个递归问题。</p><p>然而，只知道这是一个递归问题还不够，我们需要找到引发递归调用的函数。如果能看到完整的调用栈，那么就可以找到罪魁祸首了。由于 <code>vs</code> 不能显示更多的调用栈帧，我们可以请老朋友 <code>windbg</code> 出马。</p><h2 id="请出-windbg"><a href="#请出-windbg" class="headerlink" title="请出 windbg"></a>请出 windbg</h2><p>启动 <code>windbg</code>，以 <code>Noninvasive</code> 模式附加到被调试进程（由于该进程正在被 <code>vs</code> 调试，如果不以 <code>Noninvasive</code> 模式附加，<code>windbg</code> 无法成功附加）。</p><p><img src="http://resources.bianchengnan.tech/how-to-view-startup-function-from-a-deep-recursive-stack/windbg-noninvasive-attach.png" alt="windbg-noninvasive-attach"></p><p>附加成功后，通过 <code>~~[12544]s</code> 切换到目标线程，没想到报错了。</p><p><img src="http://resources.bianchengnan.tech/how-to-view-startup-function-from-a-deep-recursive-stack/windbg-switch-thread-error.png" alt="windbg-switch-thread-error"></p><p>没关系，直接切不过去，还有其它方法可以找到目标线程。可以简单粗暴的使用 <code>~* k</code> 命令显示所有线程的调用栈，然后根据调用栈判断哪个线程是目标线程，也可以通过 <code>!runaway</code> 查看所有线程的运行时间，根据运行时间长短快速找出目标线程。</p><h2 id="runaway"><a href="#runaway" class="headerlink" title="!runaway"></a>!runaway</h2><p>在 <code>windbg</code> 中输入 <code>!runaway</code> 可以查看所有线程的运行时间。一般，<code>CPU</code> 占用率越高的线程，运行时间也越长。</p><p><img src="http://resources.bianchengnan.tech/how-to-view-startup-function-from-a-deep-recursive-stack/windbg-runaway.png" alt="windbg-runaway"></p><p>可以发现 <code>0</code> 号线程运行时间最长，然后是 <code>32</code> 号线程。先切换到 <code>0</code> 号线程，执行 <code>k</code> 命令查看调用栈，发现是主线程（一般情况下 <code>0</code> 号线程都是主线程），不是我们关心的线程。再执行 <code>~32s</code> 切换到运行时间排名第二的线程，然后执行 <code>k</code> 命令查看调用栈，发现与在 <code>vs</code> 中看到的调用栈吻合，<code>32</code> 号线程是目标线程了。</p><blockquote><p>*<em>说明： *</em> 当时比较着急，忘了 <code>windbg</code> 中默认使用十六进制。如果执行 <code>~~[0n12544]s</code> 即可正常切换过去了。<code>0n</code> 表示使用十进制。</p><p><img src="http://resources.bianchengnan.tech/how-to-view-startup-function-from-a-deep-recursive-stack/switch-to-0n12544-successfully.png" alt="switch-to-0n12544-successfully"></p></blockquote><p>找到对应的线程后，接下来的任务是查看完整调用栈。</p><h2 id="查看完整调用栈"><a href="#查看完整调用栈" class="headerlink" title="查看完整调用栈"></a>查看完整调用栈</h2><p>默认情况下，<code>windbg</code> 的 <code>k</code> 命令最多只显示 <code>256</code> 个调用栈帧，最大的栈帧号是 <code>ff</code>，从 <code>0</code> 开始计数。</p><p><img src="http://resources.bianchengnan.tech/how-to-view-startup-function-from-a-deep-recursive-stack/windbg-k-output-default.png" alt="windbg-k-output-default"></p><p>我们可以在 <code>windbg</code> 中执行 <code>kN</code>来指定要显示的栈帧数，如果 <code>N</code> 足够大，那么应该可以显示出完整的调用栈。</p><p>先尝试输入 <code>k200</code>，发现看不到头，再试试 <code>k2000</code>，依然看不到头，<code>k5000</code> 依然看不到头（这调用栈不是一般的深啊~）。 直接输入 <code>k50000</code>，这次应该够了吧？没想到报错了。</p><p><img src="http://resources.bianchengnan.tech/how-to-view-startup-function-from-a-deep-recursive-stack/windbg-k50000-error.png" alt="windbg-k50000-error"></p><p>根据提示可知，可以输入的最大值是 <code>0xffff</code>。在 <code>windbg</code> 中输入 <code>k0xffff</code>，耐心等待一会儿就可以看到完整的调用栈了。如下图：</p><p><img src="http://resources.bianchengnan.tech/how-to-view-startup-function-from-a-deep-recursive-stack/view-full-callstack-in-windbg.png" alt="view-full-callstack-in-windbg"></p><blockquote><p><strong>说明：</strong> 不要输入 <code>kffff</code>，因为会被解释为  <code>kf fff</code>，第一个 <code>f</code> 会被解释为选项，用来显示两个栈帧的间距。<img src="http://resources.bianchengnan.tech/how-to-view-startup-function-from-a-deep-recursive-stack/windbg-k-command-help.png" alt="windbg-k-command-help"></p></blockquote><h2 id="调用栈深的异常"><a href="#调用栈深的异常" class="headerlink" title="调用栈深的异常"></a>调用栈深的异常</h2><p>调用栈深的有点异常，总共有 <code>0x9032 + 1</code> 个栈帧（即 <code>36915</code> 个）。这样深的调用栈却未发生栈溢出，实属不可思议。要知道，线程栈预留空间默认只有 <code>1MB</code>。</p><p>在 <code>windbg</code> 中查看当前线程栈信息，重点查看线程栈总大小和当前已使用大小（具体查看方法可以参考<a href="https://bianchengnan.gitee.io/articles/how-to-check-thread-stack-base/" target="_blank" rel="noopener">这篇文章</a>）。</p><p><img src="http://resources.bianchengnan.tech/how-to-view-startup-function-from-a-deep-recursive-stack/view-stack-total-size-and-current-used-size.png" alt="view-stack-total-size-and-current-used-size"></p><p>可以发现，线程栈预留空间大约是 <code>1.757 GB</code>，当前已使用大小大约是 <code>64.07 MB</code>。</p><p>说实话，我还是头一次遇到这么<strong>巨大</strong>的栈空间，难怪调用栈如此深却没有发生栈溢出。</p><p>但是等一下，线程栈怎么会这么大？默认不是只有 <code>1MB</code> 吗？是在创建线程的时候指定了<strong>线程栈预留空间</strong>大小？还是 <code>64</code> 位程序编译时使用的<strong>线程栈预留空间</strong>的默认值发生了变化，或者被手动修改了？又或者是有人调整了 <code>PE</code> 文件头中的 <code>SizeOfStackReserve</code> 值？</p><p>不论是修改编译参数，还是手动修改 <code>PE</code> 头，这些操作最终都会体现在 <code>PE</code> 文件上。先使用 <code>CFF Explorer</code> 查看 <code>PE</code> 文件头。</p><h2 id="查看-PE-头"><a href="#查看-PE-头" class="headerlink" title="查看 PE 头"></a>查看 PE 头</h2><p>果然，<code>PE</code> 文件头中的 <code>SizeOfStackReserve</code> 变成了 <code>0x0000000070800000</code> ，与上面在 <code>windbg</code> 中看到的线程栈总大小是一致的。<br><img src="http://resources.bianchengnan.tech/how-to-view-startup-function-from-a-deep-recursive-stack/view-pe-header.png" alt="view-pe-header"></p><p>为了验证是不是 <code>64</code> 位程序默认编译参数导致的，我特意建了一个简单的控制台程序，查看了工程设置参数，发现与 <code>32</code> 位程序一样，<strong>线程栈预留空间</strong>默认大小是 <code>1MB</code>。</p><p>一般不会有人修改生成的 <code>PE</code> 文件，回想到总是遇到栈溢出问题，猜测极有可能是某位同事修改了工程设置。不过栈空间修改的这么大，确实有待商榷。</p><p>至此，基本可以结案了。</p><h2 id="结案"><a href="#结案" class="headerlink" title="结案"></a>结案</h2><p>虽然递归了，调用栈很深，但是由于栈空间非常大，所以<strong>一时半会儿</strong>还不会导致栈溢出。最终看到的现象就是卡死、<code>CPU</code> 占用率高，而不是崩溃。当然，最终栈空间耗尽后，还是会触发栈溢出异常的。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>在 <code>windbg</code> 中可以通过 <code>kN</code> 查看指定数量的调用栈。只要 <code>N</code> 足够大，基本上可以看到完整的调用栈，但是默认情况下，<code>N</code> 不能超过 <code>0xffff</code>。</li><li>在 <code>vs</code> 中可以通过<strong>并行堆栈</strong>快速查看各个线程的调用栈，从而可以快速找到关键线程。强烈推荐！</li><li>在 <code>windbg</code> 中可以使用 <code>~* k</code> 快速查看所有线程的调用栈，与 <code>vs</code> 中的<strong>并行堆栈</strong>功能不相上下。</li><li>在 <code>windbg</code> 中可以通过 <code>!runaway</code> 查看运行时间最长的线程，从而可以快速找到关键线程。</li><li><code>windbg</code> 可以以 <code>Noninvasive</code> 的形式附加到一个正在被调试的进程。</li><li><code>PE</code> 文件头中的 <code>SizeOfStackReserve</code> 决定了线程栈预留空间的大小，可以手动修改此值来调整线程的默认栈预留空间大小。</li><li>在 <code>vs</code> 工程中可以通过修改<strong>堆栈保留大小</strong>选项（单位是字节）来控制 <code>PE</code> 文件头中的 <code>SizeOfStackReserve</code> 的值。</li></ul><h2 id="More"><a href="#More" class="headerlink" title="More"></a>More</h2><p>如果调用栈深度超出了 <code>0xffff</code>，该如何查看完整的调用栈呢？下篇更精彩，敬请期待~~</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;缘起&quot;&gt;&lt;a href=&quot;#缘起&quot; class=&quot;headerlink&quot; title=&quot;缘起&quot;&gt;&lt;/a&gt;缘起&lt;/h2&gt;&lt;p&gt;最近，遇到了一个由于递归导致的卡死问题。这个问题非常有意思，值得总结。&lt;/p&gt;
&lt;p&gt;你知道什么情况下无限递归会卡死，而不崩溃吗？你知道递归层数过多时，如何找到导致递归调用的函数吗？你知道如何快速找到关键线程吗？你知道如何附加到一个正在被调试的进程吗？你知道如何在 &lt;code&gt;windbg&lt;/code&gt; 中显示指定数量的栈帧吗？&lt;/p&gt;
&lt;p&gt;带着这些疑问，一起来看看这个非常有意思的问题吧。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;说明：&lt;/strong&gt; 文章末尾有这些问题的答案，可以直接跳到末尾查看。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="调试" scheme="https://bianchengnan.github.io/categories/%E8%B0%83%E8%AF%95/"/>
    
    
      <category term="调试" scheme="https://bianchengnan.github.io/tags/%E8%B0%83%E8%AF%95/"/>
    
      <category term="debug" scheme="https://bianchengnan.github.io/tags/debug/"/>
    
      <category term="dump" scheme="https://bianchengnan.github.io/tags/dump/"/>
    
      <category term="windbg" scheme="https://bianchengnan.github.io/tags/windbg/"/>
    
      <category term="stack" scheme="https://bianchengnan.github.io/tags/stack/"/>
    
      <category term="递归" scheme="https://bianchengnan.github.io/tags/%E9%80%92%E5%BD%92/"/>
    
      <category term="栈" scheme="https://bianchengnan.github.io/tags/%E6%A0%88/"/>
    
  </entry>
  
  <entry>
    <title>调试实战 | 从转储文件找出抛出的异常 —— 实战</title>
    <link href="https://bianchengnan.github.io//articles/search-throwing-exception-from-dump-file-part2/"/>
    <id>https://bianchengnan.github.io//articles/search-throwing-exception-from-dump-file-part2/</id>
    <published>2023-12-31T10:36:41.000Z</published>
    <updated>2024-05-18T08:56:44.102Z</updated>
    
    <content type="html"><![CDATA[<h2 id="缘起"><a href="#缘起" class="headerlink" title="缘起"></a>缘起</h2><p>我在<a href="https://bianchengnan.gitee.io/articles/search-throwing-exception-from-dump-file-part1/" target="_blank" rel="noopener">上一篇文章</a>中介绍了定位抛出异常的理论知识，本文会通过几个实例介绍各种情况下的定位方法。有调试符号如何定位？没有调试符号如何定位？<code>32</code> 位程序如何定位？<code>64</code> 位程序又该如何定位？</p><p>其实，<code>32</code> 位程序和 <code>64</code> 位程序定位过程大同小异，只不过在解析过程中需要注意，很多关键字段在 <code>64</code> 位程序中是偏移，需要加上模块基址得到虚拟地址后才能使用，而在 <code>32</code> 位程序中对应的字段就是虚拟地址，可以直接使用。</p><p>没有调试符号的时候定位异常类型会比较困难，需要根据上一篇文章中总结的步骤一步步的找到异常类型。有调试符号的情况会比较容易，有很多简便的查看方法。</p><p>一起来实战吧！</p><a id="more"></a><p>在开始实战之前，把相关结构体再贴一下，方便参考。</p><h2 id="32-位关键结构"><a href="#32-位关键结构" class="headerlink" title="32 位关键结构"></a>32 位关键结构</h2> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span>:<span class="number">000</span>&gt; dt EHExceptionRecord</span><br><span class="line">TestThrowException!EHExceptionRecord</span><br><span class="line">   +<span class="number">0x000</span> ExceptionCode    : Uint4B</span><br><span class="line">   +<span class="number">0x004</span> ExceptionFlags   : Uint4B</span><br><span class="line">   +<span class="number">0x008</span> ExceptionRecord  : Ptr32 _EXCEPTION_RECORD</span><br><span class="line">   +<span class="number">0x00c</span> ExceptionAddress : Ptr32 Void</span><br><span class="line">   +<span class="number">0x010</span> NumberParameters : Uint4B</span><br><span class="line">   +<span class="number">0x014</span> params           : EHExceptionRecord::EHParameters <span class="comment">//&lt;----</span></span><br><span class="line"></span><br><span class="line"><span class="number">0</span>:<span class="number">000</span>&gt; dt EHExceptionRecord::EHParameters</span><br><span class="line">TestThrowException!EHExceptionRecord::EHParameters</span><br><span class="line">   +<span class="number">0x000</span> magicNumber      : Uint4B</span><br><span class="line">   +<span class="number">0x004</span> pExceptionObject : Ptr32 Void</span><br><span class="line">   +<span class="number">0x008</span> pThrowInfo       : Ptr32 _s_ThrowInfo <span class="comment">//&lt;----</span></span><br><span class="line"></span><br><span class="line"><span class="number">0</span>:<span class="number">000</span>&gt; dt _s_ThrowInfo</span><br><span class="line">TestThrowException!_s_ThrowInfo</span><br><span class="line">   +<span class="number">0x000</span> attributes       : Uint4B</span><br><span class="line">   +<span class="number">0x004</span> pmfnUnwind       : Ptr32     <span class="keyword">void</span> </span><br><span class="line">   +<span class="number">0x008</span> pForwardCompat   : Ptr32     <span class="keyword">int</span> </span><br><span class="line">   +<span class="number">0x00c</span> pCatchableTypeArray : Ptr32 _s_CatchableTypeArray <span class="comment">//&lt;----</span></span><br><span class="line"></span><br><span class="line"><span class="number">0</span>:<span class="number">000</span>&gt; dt _s_CatchableTypeArray</span><br><span class="line">TestThrowException!_s_CatchableTypeArray</span><br><span class="line">   +<span class="number">0x000</span> nCatchableTypes  : Int4B</span><br><span class="line">   +<span class="number">0x004</span> arrayOfCatchableTypes : [<span class="number">0</span>] Ptr32 _s_CatchableType <span class="comment">//&lt;----</span></span><br><span class="line"></span><br><span class="line"><span class="number">0</span>:<span class="number">000</span>&gt; dt _s_CatchableType</span><br><span class="line">TestThrowException!_s_CatchableType</span><br><span class="line">   +<span class="number">0x000</span> properties       : Uint4B</span><br><span class="line">   +<span class="number">0x004</span> pType            : Ptr32 TypeDescriptor <span class="comment">//&lt;----</span></span><br><span class="line">   +<span class="number">0x008</span> thisDisplacement : PMD</span><br><span class="line">   +<span class="number">0x014</span> sizeOrOffset     : Int4B</span><br><span class="line">   +<span class="number">0x018</span> copyFunction     : Ptr32     <span class="keyword">void</span></span><br><span class="line"></span><br><span class="line"><span class="number">0</span>:<span class="number">000</span>&gt; dt TypeDescriptor</span><br><span class="line">TestThrowException!TypeDescriptor</span><br><span class="line">   +<span class="number">0x000</span> hash             : Uint4B</span><br><span class="line">   +<span class="number">0x004</span> spare            : Ptr32 Void</span><br><span class="line">   +<span class="number">0x008</span> name             : [<span class="number">0</span>] Char <span class="comment">//&lt;====</span></span><br></pre></td></tr></table></figure><h2 id="64-位关键结构"><a href="#64-位关键结构" class="headerlink" title="64 位关键结构"></a>64 位关键结构</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span>:<span class="number">000</span>&gt; dt EHExceptionRecord</span><br><span class="line">VCRUNTIME140!EHExceptionRecord</span><br><span class="line">   +<span class="number">0x000</span> ExceptionCode    : Uint4B</span><br><span class="line">   +<span class="number">0x004</span> ExceptionFlags   : Uint4B</span><br><span class="line">   +<span class="number">0x008</span> ExceptionRecord  : Ptr64 _EXCEPTION_RECORD</span><br><span class="line">   +<span class="number">0x010</span> ExceptionAddress : Ptr64 Void</span><br><span class="line">   +<span class="number">0x018</span> NumberParameters : Uint4B</span><br><span class="line">   +<span class="number">0x020</span> params           : EHExceptionRecord::EHParameters <span class="comment">//&lt;----</span></span><br><span class="line"></span><br><span class="line"><span class="number">0</span>:<span class="number">000</span>&gt; dt EHExceptionRecord::EHParameters</span><br><span class="line">VCRUNTIME140!EHExceptionRecord::EHParameters</span><br><span class="line">   +<span class="number">0x000</span> magicNumber      : Uint4B</span><br><span class="line">   +<span class="number">0x008</span> pExceptionObject : Ptr64 Void</span><br><span class="line">   +<span class="number">0x010</span> pThrowInfo       : Ptr64 _s_ThrowInfo <span class="comment">//&lt;----</span></span><br><span class="line">   +<span class="number">0x018</span> pThrowImageBase  : Ptr64 Void</span><br><span class="line"></span><br><span class="line"><span class="number">0</span>:<span class="number">000</span>&gt; dt _s_ThrowInfo</span><br><span class="line">VCRUNTIME140!_s_ThrowInfo</span><br><span class="line">   +<span class="number">0x000</span> attributes       : Uint4B</span><br><span class="line">   +<span class="number">0x004</span> pmfnUnwind       : Int4B</span><br><span class="line">   +<span class="number">0x008</span> pForwardCompat   : Int4B</span><br><span class="line">   +<span class="number">0x00c</span> pCatchableTypeArray : Int4B <span class="comment">//&lt;----</span></span><br><span class="line"></span><br><span class="line"><span class="number">0</span>:<span class="number">000</span>&gt; dt CatchableTypeArray</span><br><span class="line">VCRUNTIME140!CatchableTypeArray</span><br><span class="line">   +<span class="number">0x000</span> nCatchableTypes  : Int4B</span><br><span class="line">   +<span class="number">0x004</span> arrayOfCatchableTypes : [<span class="number">0</span>] Int4B <span class="comment">//&lt;----</span></span><br><span class="line"></span><br><span class="line"><span class="number">0</span>:<span class="number">000</span>&gt; dt CatchableType</span><br><span class="line">VCRUNTIME140!CatchableType</span><br><span class="line">   +<span class="number">0x000</span> properties       : Uint4B</span><br><span class="line">   +<span class="number">0x004</span> pType            : Int4B <span class="comment">//&lt;----</span></span><br><span class="line">   +<span class="number">0x008</span> thisDisplacement : PMD</span><br><span class="line">   +<span class="number">0x014</span> sizeOrOffset     : Int4B</span><br><span class="line">   +<span class="number">0x018</span> copyFunction     : Int4B</span><br><span class="line"></span><br><span class="line"><span class="number">0</span>:<span class="number">000</span>&gt; dt TypeDescriptor</span><br><span class="line">VCRUNTIME140!TypeDescriptor</span><br><span class="line">   +<span class="number">0x000</span> pVFTable         : Ptr64 Void</span><br><span class="line">   +<span class="number">0x008</span> spare            : Ptr64 Void</span><br><span class="line">   +<span class="number">0x010</span> name             : [<span class="number">0</span>] Char <span class="comment">//&lt;====</span></span><br></pre></td></tr></table></figure><p>接下来，先介绍无调试符号时的定位方法，然后再介绍有调试符号时的定位方法。</p><h2 id="无调试符号"><a href="#无调试符号" class="headerlink" title="无调试符号"></a>无调试符号</h2><p>如果没有导致异常的模块的调试符号，定位过程会比较复杂，需要根据上一篇文章中总结的方法一步步定位。此方法的坏处是麻烦，好处是比较通用，任何情况下都可以使用。</p><h3 id="64-位程序"><a href="#64-位程序" class="headerlink" title="64 位程序"></a>64 位程序</h3><ol><li><p>获取 <code>EHParameters</code> 的地址。<code>_CxxThrowException</code> 栈帧的 <code>rsp+0x28</code> 指向了 <code>EHParameters</code>。</p><p><code>_CxxThrowException</code> 对应栈帧的 <code>rsp</code> 是 <code>000000b9f2effb80</code>。在 <code>windbg</code> 中输入 <code>? 000000b9f2effb80 + 0x28</code>，如下图：</p><p><img src="http://resources.bianchengnan.tech/search-throwing-exception-from-dump-file-part2/view-address-of-EHParameters.png" alt="view-address-of-EHParameters"></p><p>由上图红色高亮部分可知 <code>EHParameters</code> 的地址是 <code>000000b9f2effba8</code>。</p></li><li><p>获取 <code>ThrowInfo</code> 的地址。<code>EHParameters + 0x10</code> 的位置保存了 <code>ThrowInfo</code> 的地址，<code>EHParameters + 0x18</code> 的位置保存了异常模块基址。</p><p>在 <code>windbg</code> 中输入 <code>dq 000000b9f2effba8</code>，如下图：</p><p><img src="http://resources.bianchengnan.tech/search-throwing-exception-from-dump-file-part2/view-ThrowInfo-imagebase.png" alt="view-ThrowInfo-imagebase"></p><p>由上图红色高亮部分可知 <code>ThrowInfo</code> 的地址是 <code>00007ff71c542a20</code>，异常模块基址是 <code>00007ff71c540000</code>。</p><blockquote><p><strong>说明：</strong> 如果有 <code>vcruntimexxx.dll</code> 的调试符号，可以跳过前两步，直接切换到 <code>_CxxThrowException</code> 对应的栈帧即可得到 <code>ThrowInfo</code> 的地址和异常模块基址。</p></blockquote></li><li><p>获取 <code>CatchableTypeArray</code> 的地址。<code>ThrowInfo + 0xc</code> 保存了 <code>CatchableTypeArray</code> 的偏移。</p><p>在 <code>windbg</code> 中输入 <code>dd 00007ff71c542a20</code>，如下图：</p><p><img src="http://resources.bianchengnan.tech/search-throwing-exception-from-dump-file-part2/view-throwinfo.png" alt="view-throwinfo"></p><p>由上图红色高亮部分可知 <code>CatchableTypeArray</code> 的偏移是 <code>000029b8</code>。</p><p>异常模块基址是 <code>00007ff71c540000</code>，所以 <code>CatchableTypeArray</code> 的地址是 <code>00007ff71c540000 + 000029b8 = 00007ff71c5429b8</code>。</p></li><li><p>获取 <code>CatchableType</code> 的地址。<code>CatchableTypeArray + 0x04</code> 保存了第一个 <code>CatchableType</code> 对象的<strong>偏移</strong>，<code>CatchableTypeArray + 0x08</code> 保存了第二个 <code>CatchableType</code> 对象的<strong>偏移</strong>，以此类推。</p><p>在 <code>windbg</code> 中输入 <code>dd 00007ff71c5429b8</code>，如下图：</p><p><img src="http://resources.bianchengnan.tech/search-throwing-exception-from-dump-file-part2/view-CatchableTypeArray.png" alt="view-CatchableTypeArray"></p><p>由上图可知，一共有两个 <code>CatchableType</code> 类型的对象，第一个偏移是 <code>000029d0</code>，第二个偏移是 <code>000029f8</code>。</p><p>异常模块基址是 <code>00007ff71c540000</code>，所以第一个 <code>CatchableType</code> 对象的地址是 <code>00007ff71c540000 + 000029d0 = 00007ff71c5429d0</code>。</p></li><li><p>获取 <code>TypeDescriptor</code> 的地址。<code>CatchableType + 0x04</code> 保存了 <code>TypeDescriptor</code> 的偏移。</p><p>在 <code>windbg</code> 中输入 <code>dd 00007ff71c5429d0</code>，如下图：</p><p><img src="http://resources.bianchengnan.tech/search-throwing-exception-from-dump-file-part2/view-CatchableType.png" alt="view-CatchableType"></p><p>由上图红色高亮部分可知 <code>TypeDescriptor</code> 的偏移是 <code>00004058</code>。</p><p>异常模块基址是 <code>00007ff71c540000</code>，所以 <code>TypeDescriptor</code> 的地址是 <code>00007ff71c540000 + 00004058 = 00007ff71c544058</code>。</p></li><li><p>获取异常类型名。<code>TypeDescriptor + 0x10</code> 保存了编码后的异常类型名。</p><p>在 <code>windbg</code> 中输入 <code>da 00007ff71c544058 + 0x10</code>，如下图：</p><p><img src="http://resources.bianchengnan.tech/search-throwing-exception-from-dump-file-part2/view-TypeDescriptor.png" alt="view-TypeDescriptor"></p><p>从上图可知，异常类型是 <code>.?AVbad_alloc@std@@</code>，也就是 <code>std::bad_alloc</code>。</p></li></ol><h3 id="32-位程序"><a href="#32-位程序" class="headerlink" title="32 位程序"></a>32 位程序</h3><p><code>32</code> 位程序和 <code>64</code> 位程序定位过程大同小异，只需要把 <code>64</code> 位程序定位过程中的偏移值当成地址使用即可。这里就不赘述了，参考下图：</p><p><img src="http://resources.bianchengnan.tech/search-throwing-exception-from-dump-file-part2/view-exception-type-32-bit.png" alt="view-exception-type-32-bit"></p><p>其实，对于 <code>32</code> 位程序，如果有 <code>vcruntimexxx.dll</code> 对应的符号，还有一种极其简单的方法，在 <code>windbg</code> 中输入 <code>dt -r3 ThrowInfo address</code>，如下图：</p><p><img src="http://resources.bianchengnan.tech/search-throwing-exception-from-dump-file-part2/view-exception-type-by-dt-r3.png" alt="view-exception-type-by-dt-r3"></p><h2 id="有调试符号"><a href="#有调试符号" class="headerlink" title="有调试符号"></a>有调试符号</h2><p>对于有调试符号的情况，不仅可以使用无调试符号的定位方法，还可以使用更简单的方法查看——通过查看 <code>pExceptionObject</code> 对象的虚函数表来推断对应的对象类型。</p><p>在测试程序中，<code>pExceptionObject</code> 的地址是 <code>0x000000b9f2effc00</code>，可以在 <code>windbg</code> 中执行 <code>dps 0x000000b9f2effc00</code> 即可查看异常对象对应的虚表，如下图：</p><p><img src="http://resources.bianchengnan.tech/search-throwing-exception-from-dump-file-part2/view-exception-object-vtable.png" alt="view-exception-object-vtable"></p><p>从上图可知，异常类型是 <code>std::bad_alloc</code>，其虚表内容都是其基类（<code>std::exception</code>）的虚函数，因为  <code>std::bad_alloc</code> 没重写任何虚函数，也没新增任何虚函数。</p><p>为什么没调试符号的时候不能用这个方法呢？因为没有调试符号的情况下，从 <code>dps</code> 的输出结果中看不到关键的虚表名称，也就不能推断出具体的异常类型了。</p><p><img src="http://resources.bianchengnan.tech/search-throwing-exception-from-dump-file-part2/dps-result-no-symbol.png" alt="dps-result-no-symbol"></p><h2 id="亲自动手"><a href="#亲自动手" class="headerlink" title="亲自动手"></a>亲自动手</h2><p>对应的程序源码工程文件及对应的转储文件已经上传到我的个人仓库了，感兴趣的小伙伴儿可以从以下链接自行下载：</p><p><a href="https://gitee.com/bianchengnan/my-blog-stuff/tree/master/search-throwing-exception-from-dump-file-part2/TestThrowException" target="_blank" rel="noopener">https://gitee.com/bianchengnan/my-blog-stuff/tree/master/search-throwing-exception-from-dump-file-part2/TestThrowException</a></p><p>还有一个更真实的转储文件，可以实战一把。因为比较大，我传到百度云了，可以到这里下载：</p><p><a href="https://pan.baidu.com/s/1K7FzsseMlU6kmrMwm3jn4Q?pwd=8t47" target="_blank" rel="noopener">https://pan.baidu.com/s/1K7FzsseMlU6kmrMwm3jn4Q?pwd=8t47</a></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>获取通过 <code>throw</code> 抛出的异常的突破点在 <code>_CxxThrowException()</code> 函数，该函数有源码，涉及到的关键结构体都有源码可以查询。</li><li>查找 <code>throw</code> 抛出的异常，关在是掌握对应的数据结构，务必要把关键的数据结构牢记于心。</li><li>如果有调试符号，还可以直接查看  <code>pExceptionObject</code> 对象的虚函数表来进行推断。</li><li>在解析过程中，需要注意的是在 <code>64</code> 位程序中，很多成员变量都是相对于发生异常模块的偏移，而不是直接可用的地址，需要先把偏移转换成虚拟地址后再使用。</li></ul><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><code>vs</code> 源码</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;缘起&quot;&gt;&lt;a href=&quot;#缘起&quot; class=&quot;headerlink&quot; title=&quot;缘起&quot;&gt;&lt;/a&gt;缘起&lt;/h2&gt;&lt;p&gt;我在&lt;a href=&quot;https://bianchengnan.gitee.io/articles/search-throwing-exception-from-dump-file-part1/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;上一篇文章&lt;/a&gt;中介绍了定位抛出异常的理论知识，本文会通过几个实例介绍各种情况下的定位方法。有调试符号如何定位？没有调试符号如何定位？&lt;code&gt;32&lt;/code&gt; 位程序如何定位？&lt;code&gt;64&lt;/code&gt; 位程序又该如何定位？&lt;/p&gt;
&lt;p&gt;其实，&lt;code&gt;32&lt;/code&gt; 位程序和 &lt;code&gt;64&lt;/code&gt; 位程序定位过程大同小异，只不过在解析过程中需要注意，很多关键字段在 &lt;code&gt;64&lt;/code&gt; 位程序中是偏移，需要加上模块基址得到虚拟地址后才能使用，而在 &lt;code&gt;32&lt;/code&gt; 位程序中对应的字段就是虚拟地址，可以直接使用。&lt;/p&gt;
&lt;p&gt;没有调试符号的时候定位异常类型会比较困难，需要根据上一篇文章中总结的步骤一步步的找到异常类型。有调试符号的情况会比较容易，有很多简便的查看方法。&lt;/p&gt;
&lt;p&gt;一起来实战吧！&lt;/p&gt;
    
    </summary>
    
      <category term="调试" scheme="https://bianchengnan.github.io/categories/%E8%B0%83%E8%AF%95/"/>
    
    
      <category term="原" scheme="https://bianchengnan.github.io/tags/%E5%8E%9F/"/>
    
      <category term="总结" scheme="https://bianchengnan.github.io/tags/%E6%80%BB%E7%BB%93/"/>
    
      <category term="调试" scheme="https://bianchengnan.github.io/tags/%E8%B0%83%E8%AF%95/"/>
    
      <category term="异常" scheme="https://bianchengnan.github.io/tags/%E5%BC%82%E5%B8%B8/"/>
    
      <category term="debug" scheme="https://bianchengnan.github.io/tags/debug/"/>
    
      <category term="dump" scheme="https://bianchengnan.github.io/tags/dump/"/>
    
      <category term="转储文件" scheme="https://bianchengnan.github.io/tags/%E8%BD%AC%E5%82%A8%E6%96%87%E4%BB%B6/"/>
    
      <category term="part2" scheme="https://bianchengnan.github.io/tags/part2/"/>
    
      <category term="exception" scheme="https://bianchengnan.github.io/tags/exception/"/>
    
  </entry>
  
  <entry>
    <title>调试实战 | 从转储文件找出抛出的异常 —— 理论</title>
    <link href="https://bianchengnan.github.io//articles/search-throwing-exception-from-dump-file-part1/"/>
    <id>https://bianchengnan.github.io//articles/search-throwing-exception-from-dump-file-part1/</id>
    <published>2023-12-30T00:36:41.000Z</published>
    <updated>2024-05-18T08:56:44.095Z</updated>
    
    <content type="html"><![CDATA[<h2 id="缘起"><a href="#缘起" class="headerlink" title="缘起"></a>缘起</h2><p>最近在分析转储文件时，遇到了一个由 <code>throw</code> 抛出的异常。尽管在 <code>windbg</code> 中使用 <code>!analyze -v</code> 迅速知道了异常码是 <code>0xe06d7363</code>（对应的 <code>ASCII</code> 码是 <code>.msc</code>），但是根据异常码并不能确定具体抛出来的是哪种异常。针对这种情况，确定具体的异常类型才有意义。</p><p>本篇文章会简单介绍与抛出异常相关的内容，包括关键的函数及结构体。下一篇文章会通过实例介绍几种典型情况（有调试符号 / 没有调试符号 / <code>32</code> 位程序 / <code>64</code> 位程序）下的定位方法。</p><a id="more"></a><blockquote><p><strong>说明：</strong> 对源码不感兴趣的小伙伴而可以直接跳到【解析方法小结】查看结论。</p></blockquote><h2 id="突破口"><a href="#突破口" class="headerlink" title="突破口"></a>突破口</h2><p><code>throw</code> 关键字编译后对应的函数是 <code>_CxxThrowException()</code>，该函数内部会通过 <code>RaiseException()</code> 触发异常。<code>_CxxThrowException()</code> 是有源码可查的，我们可以从这个函数入手，先来熟悉下这个函数以及相关的结构体。</p><h2 id="CxxThrowException"><a href="#CxxThrowException" class="headerlink" title="_CxxThrowException"></a>_CxxThrowException</h2><p>该函数定义在 <code>vs</code> 自带的 <code>throw.cpp</code> 中，一般在 <code>crt\src\vcruntime\</code> 目录下。直接用 <code>everything</code> 搜索 <code>throw.cpp</code>，然后打开即可。<code>vs2019</code> 中的实现代码如下，有删减：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="string">"C"</span> __declspec(noreturn) <span class="keyword">void</span> __stdcall</span><br><span class="line">_CxxThrowException(</span><br><span class="line">  <span class="keyword">void</span>*       pExceptionObject, <span class="comment">// The object thrown</span></span><br><span class="line">  _ThrowInfo* pThrowInfo        <span class="comment">// Everything we need to know about it</span></span><br><span class="line">) &#123;</span><br><span class="line">    EHTRACE_ENTER_FMT1(<span class="string">"Throwing object @ 0x%p"</span>, pExceptionObject);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">const</span> EHExceptionRecord ExceptionTemplate = &#123; <span class="comment">// A generic exception record</span></span><br><span class="line">      EH_EXCEPTION_NUMBER,       <span class="comment">// Exception number</span></span><br><span class="line">      EXCEPTION_NONCONTINUABLE,  <span class="comment">// Exception flags (we don't do resume)</span></span><br><span class="line">      <span class="literal">nullptr</span>,                   <span class="comment">// Additional record (none)</span></span><br><span class="line">      <span class="literal">nullptr</span>,                   <span class="comment">// Address of exception (OS fills in)</span></span><br><span class="line">      EH_EXCEPTION_PARAMETERS,   <span class="comment">// Number of parameters</span></span><br><span class="line">      &#123; EH_MAGIC_NUMBER1,        <span class="comment">// Our version control magic number</span></span><br><span class="line">        <span class="literal">nullptr</span>,                 <span class="comment">// pExceptionObject</span></span><br><span class="line">        <span class="literal">nullptr</span>,</span><br><span class="line">#<span class="keyword">if</span> EH_EXCEPTION_PARAMETERS == <span class="number">4</span></span><br><span class="line">        <span class="literal">nullptr</span>                  <span class="comment">// Image base of thrown object</span></span><br><span class="line">#endif</span><br><span class="line">      &#125;                          <span class="comment">// pThrowInfo</span></span><br><span class="line">    &#125;;</span><br><span class="line">    EHExceptionRecord ThisException = ExceptionTemplate; <span class="comment">// This exception</span></span><br><span class="line"></span><br><span class="line">    ThrowInfo* pTI = (ThrowInfo*)pThrowInfo;</span><br><span class="line">    <span class="comment">// deleted ...</span></span><br><span class="line">    </span><br><span class="line">    ThisException.params.pExceptionObject = pExceptionObject;</span><br><span class="line">    ThisException.params.pThrowInfo = pTI;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> _EH_RELATIVE_TYPEINFO</span></span><br><span class="line">    PVOID ThrowImageBase = RtlPcToFileHeader((PVOID)pTI, &amp;ThrowImageBase);</span><br><span class="line">    ThisException.params.pThrowImageBase = ThrowImageBase;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="comment">// deleted ...</span></span><br><span class="line"></span><br><span class="line">    EHTRACE_EXIT;</span><br><span class="line">    RaiseException( ThisException.ExceptionCode,</span><br><span class="line">      ThisException.ExceptionFlags,</span><br><span class="line">      ThisException.NumberParameters,</span><br><span class="line">      (PULONG_PTR)&amp;ThisException.params );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>根据源码可知， <code>_CxxThrowException()</code> 内部会调用 <code>RaiseException()</code>，<code>RaiseException()</code> 的原型如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">VOID WINAPI <span class="title">RaiseException</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  _In_ DWORD dwExceptionCode,</span></span></span><br><span class="line"><span class="function"><span class="params">  _In_ DWORD dwExceptionFlags,</span></span></span><br><span class="line"><span class="function"><span class="params">  _In_ DWORD nNumberOfArguments,</span></span></span><br><span class="line"><span class="function"><span class="params">  _In_reads_opt_(nNumberOfArguments) CONST ULONG_PTR* lpArguments</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br></pre></td></tr></table></figure><p> <code>_CxxThrowException</code> 调用 <code>RaiseException()</code> 时传递的各个参数值如下：</p><ul><li><p><code>dwExceptionCode</code> 的值是 <code>EH_EXCEPTION_NUMBER</code>，对应的十六进制值是 <code>0xe06d7363</code>，也就是 <code>.msc</code>。</p></li><li><p><code>dwExceptionFlags</code> 的值是 <code>EXCEPTION_NONCONTINUABLE</code>，对应的十六进制值是 <code>0x1</code>。</p></li><li><p><code>nNumberOfArguments</code> 的值是 <code>EH_EXCEPTION_PARAMETERS</code>，在 <code>32</code> 位程序中是 <code>3</code>，在 <code>64</code> 位程序中是 <code>4</code>。定义如下：</p></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">if</span> (defined(_M_AMD64) || defined(_M_ARM) || defined(_M_ARM64)) &amp;&amp; !defined(_CHPE_X86_ARM64_EH_)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EH_EXCEPTION_PARAMETERS 4  <span class="comment">// Number of parameters in exception record</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EH_EXCEPTION_PARAMETERS 3  <span class="comment">// Number of parameters in exception record</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><ul><li><code>lpArguments</code> 指向具体的参数，来自 <code>ThisException.params</code>。<code>ThisException</code> 的类型是 <code>EHExceptionRecord</code>，其定义如下：</li></ul><h2 id="EHExceptionRecord"><a href="#EHExceptionRecord" class="headerlink" title="EHExceptionRecord"></a>EHExceptionRecord</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">EHExceptionRecord</span> &#123;</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">long</span>ExceptionCode;  <span class="comment">// The code of this exception. (= EH_EXCEPTION_NUMBER)</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">long</span>ExceptionFlags;<span class="comment">// Flags determined by NT</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">EXCEPTION_RECORD</span>* <span class="title">ExceptionRecord</span>;</span> <span class="comment">// An extra exception record (not used)</span></span><br><span class="line">  <span class="keyword">void</span>* ExceptionAddress;  <span class="comment">// Address at which exception occurred</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">long</span> NumberParameters; <span class="comment">// Number of extended parameters. (= EH_EXCEPTION_PARAMETERS)</span></span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">EHParameters</span> &#123;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> magicNumber; <span class="comment">// = EH_MAGIC_NUMBER1</span></span><br><span class="line">    <span class="keyword">void</span> * pExceptionObject;   <span class="comment">// Pointer to the actual object thrown</span></span><br><span class="line">    ThrowInfo* pThrowInfo;     <span class="comment">// Description of thrown object</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> _EH_RELATIVE_TYPEINFO</span></span><br><span class="line">  <span class="keyword">void</span> * pThrowImageBase;    <span class="comment">// Image base of thrown object</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">  &#125; params; <span class="comment">// &lt;-----</span></span><br><span class="line"></span><br><span class="line">&#125; EHExceptionRecord;</span><br></pre></td></tr></table></figure><p>根据定义可知，<code>ThisException.params</code> 的类型是 <code>EHExceptionRecord::EHParameters</code>，如果 <code>_EH_RELATIVE_TYPEINFO</code> 为 <code>0</code>，则包含 <code>3</code> 个成员，否则就会包含第 4 个成员 <code>pThrowImageBase</code>。</p><p>而 <code>_EH_RELATIVE_TYPEINFO</code> 在 <code>32</code> 位程序中是 <code>0</code>，在 <code>64</code> 位程序中是 <code>1</code>，定义如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(_M_CEE_PURE) || defined(BUILDING_C1XX_FORCEINCLUDE)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _EH_RELATIVE_TYPEINFO 0  <span class="comment">// &lt;-----</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _EH_RELATIVE_FUNCINFO 0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _RTTI_RELATIVE_TYPEINFO 0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">elif</span> defined(_CHPE_X86_ARM64_EH_)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _EH_RELATIVE_TYPEINFO 0  <span class="comment">// &lt;-----</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _EH_RELATIVE_FUNCINFO 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _RTTI_RELATIVE_TYPEINFO 0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">elif</span> defined(_M_ARM)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _EH_RELATIVE_TYPEINFO 1  <span class="comment">// &lt;-----</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _EH_RELATIVE_FUNCINFO 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _RTTI_RELATIVE_TYPEINFO 0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">elif</span> defined(_M_AMD64) || defined(_M_ARM64)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _EH_RELATIVE_TYPEINFO 1  <span class="comment">// &lt;-----</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _EH_RELATIVE_FUNCINFO 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _RTTI_RELATIVE_TYPEINFO 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _EH_RELATIVE_TYPEINFO 0  <span class="comment">// &lt;-----</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _EH_RELATIVE_FUNCINFO 0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _RTTI_RELATIVE_TYPEINFO 0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><p><code>EHExceptionRecord::EHParameters</code> 结构体的成员数量与调用 <code>RaiseException()</code> 时的 <code>nNumberOfArguments</code> 参数值是对应的。</p><p>在 <code>32</code> 位程序中，<code>nNumberOfArguments</code> 的值是 <code>3</code>，<code>EHExceptionRecord::EHParameters</code> 刚好有 <code>3</code> 个成员，在 <code>64</code> 位程序中 <code>nNumberOfArguments</code> 的值是 <code>4</code>，<code>EHExceptionRecord::EHParameters</code> 刚好有 <code>4</code> 个成员。</p><p><code>EHExceptionRecord::EHParameters</code> 中的 <code>pExceptionObject</code> 和 <code>pThrowInfo</code> 是查找异常类型的关键。</p><p>其中，<code>pExceptionObject</code> 是异常对象的地址，<code>pThrowInfo</code> 的类型是 <code>ThrowInfo</code>，用来描述异常对象的类型信息。一起来看看 <code>ThrowInfo</code> 的定义。</p><h2 id="ThrowInfo"><a href="#ThrowInfo" class="headerlink" title="ThrowInfo"></a>ThrowInfo</h2> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> _<span class="title">s_ThrowInfo</span> &#123;</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> attributes; <span class="comment">// Throw Info attributes (Bit field)</span></span><br><span class="line">  PMFN pmfnUnwind; <span class="comment">// Destructor to call when exception has been handled or aborted</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> _EH_RELATIVE_TYPEINFO &amp;&amp; !defined(BUILDING_C1XX_FORCEINCLUDE)</span></span><br><span class="line">  <span class="keyword">int</span> pForwardCompat;  <span class="comment">// Image relative offset of Forward compatibility frame handler</span></span><br><span class="line">  <span class="keyword">int</span> pCatchableTypeArray; <span class="comment">// Image relative offset of CatchableTypeArray</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">  <span class="keyword">int</span> (__cdecl * pForwardCompat)(...); <span class="comment">// Forward compatibility frame handler</span></span><br><span class="line">  CatchableTypeArray* pCatchableTypeArray; <span class="comment">// Pointer to list of pointers to types</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125; ThrowInfo;</span><br></pre></td></tr></table></figure><ul><li><p><code>pmfnUnwind</code> 是处理异常时会调用的回卷函数，一般是析构函数，可以根据此值判断异常对象的类型！</p></li><li><p><code>pForwardCompat</code> 一般情况下都是 <code>0</code>，不用太关心</p></li><li><p><code>pCatchableTypeArray</code> <strong>非常重要</strong>，记录了类型信息</p></li></ul><p><code>_EH_RELATIVE_TYPEINFO</code> 在上面已经贴出来了，在 <code>32</code> 位程序中被定义为 <code>0</code>，在 <code>64</code> 位程序中被定义为 <code>1</code>。</p><p>所以，<code>pForwardCompat</code> 和 <code>pCatchableTypeArray</code> 在 <code>32</code> 位程序中是地址，在 <code>64</code> 位程序中是偏移。</p><p>还记得 <code>EHExceptionRecord::EHParameters</code> 在 <code>64</code> 位程序中有 <code>4</code> 个成员吗？第 <code>4</code> 个成员就是抛出异常对应的模块基址，用这个基址加上这里的偏移就得到了对应成员在内存中的位置。<strong>一定要记住这个结论</strong>，在分析 <code>64</code> 位程序的异常对象类型时会用到！</p><p>接下来看看关键的 <code>CatchableTypeArray</code> 类型的定义，摘录如下：</p><h2 id="CatchableTypeArray"><a href="#CatchableTypeArray" class="headerlink" title="CatchableTypeArray"></a>CatchableTypeArray</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> _<span class="title">s_CatchableTypeArray</span> &#123;</span></span><br><span class="line">  <span class="keyword">int</span> nCatchableTypes;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> _EH_RELATIVE_TYPEINFO</span></span><br><span class="line">  <span class="keyword">int</span> arrayOfCatchableTypes[];<span class="comment">// Image relative offset of Catchable Types</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">  CatchableType* arrayOfCatchableTypes[];</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125; CatchableTypeArray;</span><br></pre></td></tr></table></figure><ul><li><code>nCatchableTypes</code> 记录了数组 <code>arrayOfCatchableTypes</code> 的数量。</li><li><code>arrayOfCatchableTypes</code> 记录了异常类型信息。同样的，在 <code>32</code> 位程序中是地址，在 <code>64</code> 位程序中是偏移。</li></ul><blockquote><p><strong>说明：</strong> 这里为什么使用数组呢？因为抛出的异常可能继承自某个基类。<code>arrayOfCatchableTypes</code> 会把继承链上的所有类型信息按照从子类到基类的顺序记录下来。拿 <code>std::bad_alloc</code> 举例，它继承自 <code>std::exception</code>。所以，<code>nCatchableTypes</code> 的值为 <code>2</code>，<code>arrayOfCatchableTypes[0]</code> 记录了 <code>std::bad_alloc</code> 的类型信息，<code>arrayOfCatchableTypes[1]</code> 记录了 <code>std::exception</code> 的类型信息。</p></blockquote><p>再来看看结构体 <code>CatchableType</code> 的定义，摘录如下：</p><h2 id="CatchableType"><a href="#CatchableType" class="headerlink" title="CatchableType"></a>CatchableType</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> _<span class="title">s_CatchableType</span> &#123;</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> properties; <span class="comment">// Catchable Type properties (Bit field)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> _EH_RELATIVE_TYPEINFO</span></span><br><span class="line">  <span class="keyword">int</span> pType; <span class="comment">// Image relative offset of TypeDescriptor</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">  TypeDescriptor* pType; <span class="comment">// Pointer to the type descriptor for this type</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">  PMD thisDisplacement;<span class="comment">// Pointer to instance of catch type within thrown object.</span></span><br><span class="line">  <span class="keyword">int</span> sizeOrOffset;  <span class="comment">// Size of simple-type object or offset into</span></span><br><span class="line">           <span class="comment">// buffer of 'this' pointer for catch object</span></span><br><span class="line">  PMFN copyFunction; <span class="comment">// Copy constructor or CC-closure</span></span><br><span class="line">&#125; CatchableType;</span><br></pre></td></tr></table></figure><p>我们只需要关注 <code>pType</code> 成员即可。同样的，在 <code>32</code> 位程序中是地址，在 <code>64</code> 位程序中是偏移。 <code>pType</code> 对应的类型是 <code>TypeDescriptor</code>，接下来看看 <code>TypeDescriptor</code> 的定义。</p><h2 id="TypeDescriptor"><a href="#TypeDescriptor" class="headerlink" title="TypeDescriptor"></a>TypeDescriptor</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">TypeDescriptor</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(_WIN64) || defined(_RTTI) || defined(BUILDING_C1XX_FORCEINCLUDE)</span></span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">void</span>* pVFTable; <span class="comment">// Field overloaded by RTTI</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">long</span>hash; <span class="comment">// Hash value computed from type's decorated name</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">  <span class="keyword">void</span>*spare; <span class="comment">// reserved, possible for RTTI</span></span><br><span class="line">  <span class="keyword">char</span> name[]; <span class="comment">// The decorated name of the type; 0 terminated.</span></span><br><span class="line">&#125; TypeDescriptor;</span><br></pre></td></tr></table></figure><p>其中，<code>name</code> 成员是经过名字改编后的异常类型，它是一个以 <code>\0</code> 结尾的字符串，可以在 <code>windbg</code> 中通过 <code>da</code> 查看。</p><p>源码有点乱，还是在 <code>windbg</code> 中看的直观舒服，还可以看到偏移。以下是  <code>32</code> 位和 <code>64</code> 位程序中对应的结构体定义：</p><h2 id="关键结构"><a href="#关键结构" class="headerlink" title="关键结构"></a>关键结构</h2><h3 id="32-位关键结构"><a href="#32-位关键结构" class="headerlink" title="32 位关键结构"></a>32 位关键结构</h3> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span>:<span class="number">000</span>&gt; dt EHExceptionRecord</span><br><span class="line">TestThrowException!EHExceptionRecord</span><br><span class="line">   +<span class="number">0x000</span> ExceptionCode    : Uint4B</span><br><span class="line">   +<span class="number">0x004</span> ExceptionFlags   : Uint4B</span><br><span class="line">   +<span class="number">0x008</span> ExceptionRecord  : Ptr32 _EXCEPTION_RECORD</span><br><span class="line">   +<span class="number">0x00c</span> ExceptionAddress : Ptr32 Void</span><br><span class="line">   +<span class="number">0x010</span> NumberParameters : Uint4B</span><br><span class="line">   +<span class="number">0x014</span> params           : EHExceptionRecord::EHParameters <span class="comment">//&lt;----</span></span><br><span class="line"></span><br><span class="line"><span class="number">0</span>:<span class="number">000</span>&gt; dt EHExceptionRecord::EHParameters</span><br><span class="line">TestThrowException!EHExceptionRecord::EHParameters</span><br><span class="line">   +<span class="number">0x000</span> magicNumber      : Uint4B</span><br><span class="line">   +<span class="number">0x004</span> pExceptionObject : Ptr32 Void</span><br><span class="line">   +<span class="number">0x008</span> pThrowInfo       : Ptr32 _s_ThrowInfo <span class="comment">//&lt;----</span></span><br><span class="line"></span><br><span class="line"><span class="number">0</span>:<span class="number">000</span>&gt; dt _s_ThrowInfo</span><br><span class="line">TestThrowException!_s_ThrowInfo</span><br><span class="line">   +<span class="number">0x000</span> attributes       : Uint4B</span><br><span class="line">   +<span class="number">0x004</span> pmfnUnwind       : Ptr32     <span class="keyword">void</span> </span><br><span class="line">   +<span class="number">0x008</span> pForwardCompat   : Ptr32     <span class="keyword">int</span> </span><br><span class="line">   +<span class="number">0x00c</span> pCatchableTypeArray : Ptr32 _s_CatchableTypeArray <span class="comment">//&lt;----</span></span><br><span class="line"></span><br><span class="line"><span class="number">0</span>:<span class="number">000</span>&gt; dt _s_CatchableTypeArray</span><br><span class="line">TestThrowException!_s_CatchableTypeArray</span><br><span class="line">   +<span class="number">0x000</span> nCatchableTypes  : Int4B</span><br><span class="line">   +<span class="number">0x004</span> arrayOfCatchableTypes : [<span class="number">0</span>] Ptr32 _s_CatchableType <span class="comment">//&lt;----</span></span><br><span class="line"></span><br><span class="line"><span class="number">0</span>:<span class="number">000</span>&gt; dt _s_CatchableType</span><br><span class="line">TestThrowException!_s_CatchableType</span><br><span class="line">   +<span class="number">0x000</span> properties       : Uint4B</span><br><span class="line">   +<span class="number">0x004</span> pType            : Ptr32 TypeDescriptor <span class="comment">//&lt;----</span></span><br><span class="line">   +<span class="number">0x008</span> thisDisplacement : PMD</span><br><span class="line">   +<span class="number">0x014</span> sizeOrOffset     : Int4B</span><br><span class="line">   +<span class="number">0x018</span> copyFunction     : Ptr32     <span class="keyword">void</span></span><br><span class="line"></span><br><span class="line"><span class="number">0</span>:<span class="number">000</span>&gt; dt TypeDescriptor</span><br><span class="line">TestThrowException!TypeDescriptor</span><br><span class="line">   +<span class="number">0x000</span> hash             : Uint4B</span><br><span class="line">   +<span class="number">0x004</span> spare            : Ptr32 Void</span><br><span class="line">   +<span class="number">0x008</span> name             : [<span class="number">0</span>] Char <span class="comment">//&lt;====</span></span><br></pre></td></tr></table></figure><h3 id="64-位关键结构"><a href="#64-位关键结构" class="headerlink" title="64 位关键结构"></a>64 位关键结构</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span>:<span class="number">000</span>&gt; dt EHExceptionRecord</span><br><span class="line">VCRUNTIME140!EHExceptionRecord</span><br><span class="line">   +<span class="number">0x000</span> ExceptionCode    : Uint4B</span><br><span class="line">   +<span class="number">0x004</span> ExceptionFlags   : Uint4B</span><br><span class="line">   +<span class="number">0x008</span> ExceptionRecord  : Ptr64 _EXCEPTION_RECORD</span><br><span class="line">   +<span class="number">0x010</span> ExceptionAddress : Ptr64 Void</span><br><span class="line">   +<span class="number">0x018</span> NumberParameters : Uint4B</span><br><span class="line">   +<span class="number">0x020</span> params           : EHExceptionRecord::EHParameters <span class="comment">//&lt;----</span></span><br><span class="line"></span><br><span class="line"><span class="number">0</span>:<span class="number">000</span>&gt; dt EHExceptionRecord::EHParameters</span><br><span class="line">VCRUNTIME140!EHExceptionRecord::EHParameters</span><br><span class="line">   +<span class="number">0x000</span> magicNumber      : Uint4B</span><br><span class="line">   +<span class="number">0x008</span> pExceptionObject : Ptr64 Void</span><br><span class="line">   +<span class="number">0x010</span> pThrowInfo       : Ptr64 _s_ThrowInfo <span class="comment">//&lt;----</span></span><br><span class="line">   +<span class="number">0x018</span> pThrowImageBase  : Ptr64 Void</span><br><span class="line"></span><br><span class="line"><span class="number">0</span>:<span class="number">000</span>&gt; dt _s_ThrowInfo</span><br><span class="line">VCRUNTIME140!_s_ThrowInfo</span><br><span class="line">   +<span class="number">0x000</span> attributes       : Uint4B</span><br><span class="line">   +<span class="number">0x004</span> pmfnUnwind       : Int4B</span><br><span class="line">   +<span class="number">0x008</span> pForwardCompat   : Int4B</span><br><span class="line">   +<span class="number">0x00c</span> pCatchableTypeArray : Int4B <span class="comment">//&lt;----</span></span><br><span class="line"></span><br><span class="line"><span class="number">0</span>:<span class="number">000</span>&gt; dt CatchableTypeArray</span><br><span class="line">VCRUNTIME140!CatchableTypeArray</span><br><span class="line">   +<span class="number">0x000</span> nCatchableTypes  : Int4B</span><br><span class="line">   +<span class="number">0x004</span> arrayOfCatchableTypes : [<span class="number">0</span>] Int4B <span class="comment">//&lt;----</span></span><br><span class="line"></span><br><span class="line"><span class="number">0</span>:<span class="number">000</span>&gt; dt CatchableType</span><br><span class="line">VCRUNTIME140!CatchableType</span><br><span class="line">   +<span class="number">0x000</span> properties       : Uint4B</span><br><span class="line">   +<span class="number">0x004</span> pType            : Int4B <span class="comment">//&lt;----</span></span><br><span class="line">   +<span class="number">0x008</span> thisDisplacement : PMD</span><br><span class="line">   +<span class="number">0x014</span> sizeOrOffset     : Int4B</span><br><span class="line">   +<span class="number">0x018</span> copyFunction     : Int4B</span><br><span class="line"></span><br><span class="line"><span class="number">0</span>:<span class="number">000</span>&gt; dt TypeDescriptor</span><br><span class="line">VCRUNTIME140!TypeDescriptor</span><br><span class="line">   +<span class="number">0x000</span> pVFTable         : Ptr64 Void</span><br><span class="line">   +<span class="number">0x008</span> spare            : Ptr64 Void</span><br><span class="line">   +<span class="number">0x010</span> name             : [<span class="number">0</span>] Char <span class="comment">//&lt;====</span></span><br></pre></td></tr></table></figure><blockquote><p><strong>划重点：</strong> 务必记住以上结构体的定义，尤其是关键字段的偏移。这是解析的依据！</p></blockquote><h2 id="解析方法小结"><a href="#解析方法小结" class="headerlink" title="解析方法小结"></a>解析方法小结</h2><ol><li><p>先找到 <code>EHParameters</code> 类型的对象（可省略此步）</p><p>可以通过 <code>RaiseException()</code> 的第四个参数查找。</p><p>在 <code>32</code> 位程序中，定位方法非常简单，可以直接查看 <code>RaiseException()</code> 的第 <code>4</code> 个参数，<code>ebp+0x14</code>。</p><p>在 <code>x64</code> 位中可以通过 <code>_CxxThrowException()</code> 的 <code>rsp + 0x28</code> 定位。因为在调用 <code>RaiseException()</code> 的时候， <code>_CxxThrowException()</code> 会把此参数存在自己栈帧中 <code>rsp + 0x28</code> 的位置。</p></li></ol><ol start="2"><li><p>再找到  <code>ThrowInfo</code> 类型的对象</p><p>解析 <code>EHParameters</code> 中的第 <code>3</code> 个成员 <code>pThrowInfo</code>，在 <code>32</code> 位程序中偏移是 <code>0x8</code>，在 <code>64</code> 位程序中偏移是 <code>0x10</code>。</p><blockquote><p><strong>说明：</strong> 还有两种查看方法： </p><ol><li><p>对于 <code>32</code> 位程序可以通过 <code>_CxxThrowException()</code> 对应栈帧的第 <code>2</code> 个参数（<code>ebp+c</code>）直接查看。</p></li><li><p>如果有 <code>vcruntimexxx.dll</code> 的调试符号，可以直接切到 <code>_CxxThrowException()</code> 对应的栈帧，<code>windbg</code> 会自动帮忙列出对应的值。 </p></li></ol></blockquote></li></ol><ol start="3"><li><p>再找到 <code>CatchableTypeArray</code> 类型的对象</p><p>解析 <code>ThrowInfo</code> 的第 <code>4</code> 个成员 <code>pCatchableTypeArray</code>，其偏移是 <code>0xc</code>（<code>32</code>位 <code>64</code> 位通用）。</p><p><strong>需要注意的是，此成员在 <code>32</code> 位程序中是地址；在 <code>64</code> 位程序中是偏移，需要加上镜像基址得到最终的地址。</strong></p></li></ol><ol start="4"><li><p>再找到 <code>CatchableType</code> 类型的对象</p><p>解析 <code>CatchableTypeArray</code> 的第 <code>2</code>个成员 <code>arrayOfCatchableTypes</code> ，偏移是 <code>0x4</code>（<code>32</code>位 <code>64</code> 位通用）。</p><p>该成员记录了 <code>CatchableType</code> 数组的首地址或者偏移。</p><p><strong>需要注意的是，此成员在 <code>32</code> 位程序中是地址；在 <code>64</code> 位程序中是偏移，需要加上镜像基址得到最终的地址。</strong></p><blockquote><p><strong>说明：</strong> 第 <code>1</code> 个成员 <code>nCatchableTypes</code> 记录了 <code>CatchableType</code> 数组的个数。</p></blockquote></li></ol><ol start="5"><li><p>再找到 <code>TypeDescriptor</code> 类型的对象</p><p>解析 <code>CatchableType</code> 数组中的每个对象（其实，只需要解析第一个即可）。重点关注第 <code>2</code> 个成员 <code>pType</code>，偏移是 <code>0x4</code>（<code>32</code>位 <code>64</code> 位通用）。</p><p><strong>需要注意的是，此成员在 <code>32</code> 位程序中是地址；在 <code>64</code> 位程序中是偏移，需要加上镜像基址得到最终的地址。</strong></p></li></ol><ol start="6"><li><p>最后找到异常类型名</p><p>解析 <code>TypeDescriptor</code> 对象，只需要关注第 <code>3</code> 个成员 <code>name</code> 成员即可，在 <code>32</code> 位程序中偏移是 <code>0x8</code>，在 <code>64</code> 位程序中偏移是 <code>0x10</code>。</p><p>它是一个以 <code>\0</code> 结尾的字符串，可以在 <code>windbg</code> 用 <code>da</code> 显示其内容。</p></li></ol><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li><code>throw</code> 对应的实现函数是 <code>_CxxThrowException()</code> 函数，该函数定义在 <code>throw.cpp</code> 中，可以查看源码。</li><li><code>_CxxThrowException()</code> 内部会调用 <code>RaiseException()</code>，调用时传递的错误码是 <code>0xe06d7363</code>（对应的字符是 <code>.msc</code>）。</li><li>【关键结构】中的结构体是解析时的依据，务必要熟悉。</li><li>【解析方法小结】中总结的方法是通用方法，适用于任何情况。在实际解析过程中还可以利用虚表等其它相关信息进行解析。</li><li>在解析过程中，需要注意的是在 <code>64</code> 位程序中，很多成员变量都是相对于发生异常模块的偏移，而不是直接可用的地址，需要先把偏移转换成虚拟地址后再使用。</li></ul><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><code>vs</code> 源码</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;缘起&quot;&gt;&lt;a href=&quot;#缘起&quot; class=&quot;headerlink&quot; title=&quot;缘起&quot;&gt;&lt;/a&gt;缘起&lt;/h2&gt;&lt;p&gt;最近在分析转储文件时，遇到了一个由 &lt;code&gt;throw&lt;/code&gt; 抛出的异常。尽管在 &lt;code&gt;windbg&lt;/code&gt; 中使用 &lt;code&gt;!analyze -v&lt;/code&gt; 迅速知道了异常码是 &lt;code&gt;0xe06d7363&lt;/code&gt;（对应的 &lt;code&gt;ASCII&lt;/code&gt; 码是 &lt;code&gt;.msc&lt;/code&gt;），但是根据异常码并不能确定具体抛出来的是哪种异常。针对这种情况，确定具体的异常类型才有意义。&lt;/p&gt;
&lt;p&gt;本篇文章会简单介绍与抛出异常相关的内容，包括关键的函数及结构体。下一篇文章会通过实例介绍几种典型情况（有调试符号 / 没有调试符号 / &lt;code&gt;32&lt;/code&gt; 位程序 / &lt;code&gt;64&lt;/code&gt; 位程序）下的定位方法。&lt;/p&gt;
    
    </summary>
    
      <category term="调试" scheme="https://bianchengnan.github.io/categories/%E8%B0%83%E8%AF%95/"/>
    
    
      <category term="原" scheme="https://bianchengnan.github.io/tags/%E5%8E%9F/"/>
    
      <category term="总结" scheme="https://bianchengnan.github.io/tags/%E6%80%BB%E7%BB%93/"/>
    
      <category term="调试" scheme="https://bianchengnan.github.io/tags/%E8%B0%83%E8%AF%95/"/>
    
      <category term="异常" scheme="https://bianchengnan.github.io/tags/%E5%BC%82%E5%B8%B8/"/>
    
      <category term="debug" scheme="https://bianchengnan.github.io/tags/debug/"/>
    
      <category term="dump" scheme="https://bianchengnan.github.io/tags/dump/"/>
    
      <category term="转储文件" scheme="https://bianchengnan.github.io/tags/%E8%BD%AC%E5%82%A8%E6%96%87%E4%BB%B6/"/>
    
      <category term="exception" scheme="https://bianchengnan.github.io/tags/exception/"/>
    
      <category term="part1" scheme="https://bianchengnan.github.io/tags/part1/"/>
    
  </entry>
  
  <entry>
    <title>调试实战 | 谁在偷偷占用我的文件？原来是我自己</title>
    <link href="https://bianchengnan.github.io//articles/findout-who-is-using-my-file-with-the-help-of-perfview-and-process-explorer/"/>
    <id>https://bianchengnan.github.io//articles/findout-who-is-using-my-file-with-the-help-of-perfview-and-process-explorer/</id>
    <published>2023-12-24T12:14:23.000Z</published>
    <updated>2024-05-18T08:56:43.849Z</updated>
    
    <content type="html"><![CDATA[<h2 id="缘起"><a href="#缘起" class="headerlink" title="缘起"></a>缘起</h2><p>之前基于 <code>.net</code> 官方提供的 <code>FileSystemWatcher</code> 写了一个文件变化监听工具，具体参考<a href="https://bianchengnan.gitee.io/articles/A-better-file-system-wacher-based-on-dotnet-FileSystemWatcher/" target="_blank" rel="noopener">这篇文章</a> 。主要解决了以下三个问题：</p><ol><li>事件触发时，文件可能还不能被访问。</li><li>如果监听选项设置的过多，有可能会多次触发文件变化事件。</li><li>监听过滤器不够灵活，我没找到同时监听多种特定文件类型的方法（比如，同时只监听 <code>.docx</code> 和 <code>.bmp</code> 文件）。</li></ol><p>为了解决<strong>问题1</strong>，我在调用用户注册的回调函数前，会先调用 <code>WaitUntilCanAccess()</code> 来确保文件是可访问状态。没想到在测试过程中发现了一个意想不到的问题。本文记录了解决这个问题的过程。</p><a id="more"></a><blockquote><p><strong>说明：</strong> 我写了一个示例工程，本文所有的叙述都是基于这个示例工程的。</p></blockquote><h2 id="测试程序"><a href="#测试程序" class="headerlink" title="测试程序"></a>测试程序</h2><p><code>TestMonitorImage.exe</code> 会<strong>递归</strong>监听当前程序所在目录中的所有 <code>.bmp</code> 类型的文件变化，监听到相应事件后会调用 <code>picturebox.Load(path)</code> 把图像显示到界面上。</p><p><code>copy.ps1</code> 是一个辅助脚本，会每隔一秒拷贝一张图片到子目录中，会触发文件变化事件。按理说，每隔一秒界面上应该显示一张新图片，如此往复，如下图：</p><p><img src="http://resources.bianchengnan.tech/findout-who-is-using-my-file-with-the-help-of-perfview-and-process-explorer/right-result.gif" alt="right-result"></p><p>但是……</p><h2 id="初遇问题"><a href="#初遇问题" class="headerlink" title="初遇问题"></a>初遇问题</h2><p>没想到只显示了一张图片后就停止显示了，就像下面这样。</p><p><img src="http://resources.bianchengnan.tech/findout-who-is-using-my-file-with-the-help-of-perfview-and-process-explorer/wrong-result.png" alt="wrong-result"></p><p>这不可能啊（哈哈，最近的口头禅）！但是现象确实是不对的，到底是哪里出了问题呢？</p><h2 id="调查"><a href="#调查" class="headerlink" title="调查"></a>调查</h2><p>附加调试器，通过调试信息可以判断监听还在正常进行，因为能不断输出调试日志。</p><p><img src="http://resources.bianchengnan.tech/findout-who-is-using-my-file-with-the-help-of-perfview-and-process-explorer/debug-output.gif" alt="debug-output"></p><p>接着观察一下回调函数是否正常。在回调函数里加断点，奇怪，怎么没命中？难道是通知环节出了问题？</p><p>观察一下通知线程的运行情况，观察了几秒钟，发现这个线程会反复遇到同一个异常——文件正由另一进程使用，因此该进程无法访问此文件。</p><p><img src="http://resources.bianchengnan.tech/findout-who-is-using-my-file-with-the-help-of-perfview-and-process-explorer/file-is-being-used-by-another-process-exception.png" alt="file-is-being-used-by-another-process-exception"></p><p>按理说，<code>powershell</code> 脚本拷贝完文件后，就不会占用这个文件了。而且我机器上装的是固态硬盘，本地文件拷贝过程应该非常快，就算再慢，<code>1</code> 秒也应该拷贝完了。即使遇到文件被占用的异常，最多只会在最开始的十几毫秒内遇到，不应该过了这么久还会遇到这种异常。那到底是谁在占用这个文件呢？</p><h2 id="请出-process-explorer"><a href="#请出-process-explorer" class="headerlink" title="请出 process explorer"></a>请出 process explorer</h2><p>打开 <code>process explorer</code>，搜索 <code>testimage1.bmp</code>，发现只搜到一条结果，而且居然还是自己的进程！</p><p><img src="http://resources.bianchengnan.tech/findout-who-is-using-my-file-with-the-help-of-perfview-and-process-explorer/search-testimage1.png" alt="search-testimage1"></p><p>看来应该是某处代码打开了这个文件，但是没有关闭。在 <code>windows</code> 中，打开文件后会返回一个句柄（<code>HANDLE</code>），不再使用这个文件的时候需要关闭。如果打开了文件，但是没有关闭它，则会导致句柄泄露，而且下次再尝试打开这个文件的时候<strong>可能</strong>会遇到文件被占用，无法访问的情况。有没有一种机制可以追踪句柄打开/关闭的情况呢？如果能同时显示对应的调用栈，那就更完美了。我知道两种方法：</p><ol><li>使用 <code>windbg</code> 的 <code>!htrace</code> 命令</li><li>使用 <code>ETW(Event Trace for Windows)</code> 追踪句柄。</li></ol><p>如果可以调试的话，可以用 <code>windbg</code> 附加到对应的进程中，然后执行 <code>!htrace -enable</code> 开启句柄追踪，等程序运行一段时间后，执行 <code>!htrace -diff</code> 即可查看句柄变化情况，而且可以看到对应的调用栈。虽然 <code>windbg</code> 很强大，但是今天的主角不是 <code>windbg</code>，而是 <a href="https://github.com/microsoft/perfview" target="_blank" rel="noopener">perfView</a> —— 一款开源、免费、绿色而且非常强大的 <code>ETW</code> 事件收集及分析工具。</p><h2 id="采集数据"><a href="#采集数据" class="headerlink" title="采集数据"></a>采集数据</h2><p>打开 <code>perfView</code>，点击 <code>Collect -&gt; Collect   Alt+C</code>，会以管理员权限弹出收集界面，如下图：</p><p><img src="http://resources.bianchengnan.tech/findout-who-is-using-my-file-with-the-help-of-perfview-and-process-explorer/perfview-collect.png" alt="perfview-collect"></p><p>点击 <code>Advance Options</code> 按钮，即可打开高级选项。勾选 <code>Handle</code> 即可追踪句柄，勾选 <code>File I/O</code> 即可追踪文件操作。</p><p>设置好后，点击 <code>Start Collection</code> 即可开始收集。问题重现后，点击 <code>Stop Collection</code> 停止收集。完整操作过程如下：</p><p><img src="http://resources.bianchengnan.tech/findout-who-is-using-my-file-with-the-help-of-perfview-and-process-explorer/collect-event-with-perfview.gif" alt="collect-event-with-perfview"></p><blockquote><p><strong><em>说明：</em></strong></p><ol><li>除了点击 <code>Collect</code> 菜单下的 <code>Collect</code>，还可以点击 <code>Run</code>，与 <code>Collect</code> 的区别是：<code>Run</code> 可以自动启动指定的程序，当程序结束运行时，自动停止收集。</li><li>需要说明的是：不论是 <code>Collect</code> 还是 <code>Run</code>，收集是机器级别的，不能只针对某个进程进行收集。</li></ol></blockquote><h2 id="分析数据"><a href="#分析数据" class="headerlink" title="分析数据"></a>分析数据</h2><p>点击 <code>Stop Collection</code> 按钮后， <code>perfView</code> 会自动保存采集结果，然后显示在左侧列表中。</p><p><img src="http://resources.bianchengnan.tech/findout-who-is-using-my-file-with-the-help-of-perfview-and-process-explorer/perfview-left-expand.png" alt="perfview-left-expand"></p><p>选中刚刚采集的文件，找到 <code>Events</code> 项，<strong>双击</strong>即可查看所有原始的 <code>ETW</code> 数据。其它项都是为了方便查看某些数据而创建的。比如，<code>CPU Stacks</code> 可以查看进程 <code>CPU</code> 使用情况。</p><p>因为采集的文件中包含<strong>海量</strong>的数据，而且大多数与我们要分析的问题无关，因此我们需要过滤出感兴趣的数据。</p><h2 id="过滤数据"><a href="#过滤数据" class="headerlink" title="过滤数据"></a>过滤数据</h2><p><code>perfView</code> 提供了很灵活的过滤机制，既可以根据进程过滤，也可以根据事件类型过滤，还可以根据事件内容进行过滤。</p><p><code>Process Filter</code> 可以根据进程进行过滤。输入 <code>TestMonitorImage</code>。</p><p><code>Event Types</code> 可以根据事件类型进行过滤。在对应的 <code>Filters</code> 中输入 <code>file|handle</code>（表示过滤文件和句柄事件），在过滤出来的结果中选择具体的事件类型（<code>CloseHandle, CreateHandle, DuplicateHandle, HandleDCEnd</code>），按回车即可在右侧显示出过滤后的事件。</p><p><code>Text Filter</code> 可以根据事件内容进行过滤。输入 <code>.bmp</code>，回车即可过滤出事件内容中包含 <code>.bmp</code> 的记录。</p><p><code>Columns To Display</code>  可以设置显示的列。为了更好的观察感兴趣的字段，点击 <code>Cols</code> 按钮选择需要显示的列，我选择了 <code>ObjectName</code>, <code>ThreadID</code> 和 <code>*</code>。</p><blockquote><p> <strong>注意：</strong></p><p>我在操作的过程中先显示了 <code>file</code> 和 <code>handle</code> 相关的事件，然后才只显示 <code>handle</code> 相关的事件。如果上来就只显示 <code>handle</code> 相关的事件，那么根据 <code>.bmp</code> 过滤的话，会过滤不出来任何记录。我猜是 <code>perfView</code> 自动根据 <code>file</code> 事件中的句柄和文件名推断出了对应的 <code>handle</code> 事件的 <code>ObjectName</code>。</p></blockquote><p><img src="http://resources.bianchengnan.tech/findout-who-is-using-my-file-with-the-help-of-perfview-and-process-explorer/filter-result.png" alt="filter-result"></p><p>从上图可以很清楚的看到 <code>.bmp</code> 相关的事件。注意 <code>ThreadID</code> 一列，<code>线程ID</code> 为 <code>10164</code> 的线程只出现了一次，对应的事件是 <code>CreateHandle</code>。（缺少了对应的 <code>CloseHandle</code>，说明这个线程只打开了文件，并没有关闭）在对应行的 <code>Time MSec</code> 这一列，右键，点击 <code>Open Any Stack   Alt+S</code> （或者在对应列上按 <code>Alt + S</code>）即可查看对应的调用栈，如下图：</p><p><img src="http://resources.bianchengnan.tech/findout-who-is-using-my-file-with-the-help-of-perfview-and-process-explorer/call-stack.png" alt="call-stack"></p><p>在对应行上，右键，点击 <code>Goto SOurce(Def)  Alt+D</code> （或者在对应行上按 <code>Alt+D</code>）即可打开对应的源码，如下图：</p><p><img src="http://resources.bianchengnan.tech/findout-who-is-using-my-file-with-the-help-of-perfview-and-process-explorer/go-to-source.png" alt="go-to-source"></p><p>可以发现在 <code>OnFileChanged()</code> 回调函数中，会使用 <code>s_form.pictureBox1.Load(e.FullPath)</code> 加载文件。可以猜测 <code>Load()</code> 函数内部打开对应的文件后并没有关闭。</p><p>目前程序在每次通知前会使用 <code>WaitUntilCanAccess()</code> 检查文件是否可以读写（内部通过  <code>File.Open(e.FullPath, FileMode.Open, FileAccess.ReadWrite, FileShare.None);</code> 进行判断）。</p><p>试想，如果下次收到同一个文件变化的通知，<code>WaitUntilCanAccess()</code> 内部会使用 <code>File.Open()</code> 尝试打开这个文件，而这个文件已经被打开了，是不是有可能触发文件被占用的异常呢？确实有可能会，也可能不会！</p><p>文件打开后没关闭，再次尝试打开时<strong>不一定</strong>会触发异常，比如两次都是通过 <code>File.Open(e.FullPath, FileMode.Open, FileAccess.ReadWrite, FileShare.ReadWrite);</code> 打开文件，第二次是可以顺利打开文件的。</p><p>那么什么情况下会触发文件被占用的异常呢？</p><h2 id="深入分析"><a href="#深入分析" class="headerlink" title="深入分析"></a>深入分析</h2><p>关于<code>FileAcess</code> 和 <code>FileShare</code> 的关系，请参考我总结的这篇文章 —— <a href="https://bianchengnan.gitee.io/articles/review-CreateFile-DesireAccess-ShareMode/" target="_blank" rel="noopener">《开发常识 | 彻底理清 CreateFile 读写权限与共享模式的关系》</a>。</p><p>简单来说就是：后续的<strong>访问权限</strong>与先前的<strong>共享权限</strong>不能冲突。后续的<strong>共享权限</strong>与先前的<strong>访问权限</strong>不能冲突。</p><p>检查一下 <code>线程ID</code> 为 <code>10164</code> 的线程打开文件时指定的 <code>ShareAccess</code>，是 <code>ShareAccess.Read</code>，如下图：</p><p><img src="http://resources.bianchengnan.tech/findout-who-is-using-my-file-with-the-help-of-perfview-and-process-explorer/fileIO-Create-on-callback.png" alt="fileIO-Create-on-callback"></p><p>后续如果用 <code>FileAccess.ReadWrite</code> 打开，肯定会报错。而 <code>WaitUntilCanAccess()</code> 内部调用 <code>File.Open()</code> 时 <code>FileAccess</code> 参数的值就是 <code>FileAccess.ReadWrite</code>。  </p><p>而且 <code>WaitUntilCanAccess()</code> 指定的 <code>ShareAccess</code> 是 <code>FileShare.None</code>。只要在调用  <code>WaitUntilCanAccess()</code>  的时候，已经在其它地方打开了这个文件，肯定会触发文件被占用的异常。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>简单做个总结，整个过程是这样的：</p><p>当监听目录下的文件发生变化后，会进入内部的监听回调函数，监听回调函数会通过 <code>AddEventData()</code> 把数据放到通知队列中，并通过 <code>eventFiredEvent.Set()</code> 触发通知事件，通知线程收到消息后开始依次处理队列中的事件。</p><p>通知线程会先通过 <code>WaitUntilCanAccess()</code> 确保这个文件是可读写的状态，然后再调用外部回调函数。在外部回调函数中打开了文件但是并没有关闭。</p><p>当通知线程处理后续事件时，对应的文件刚好是上一个被占用的文件，<code>WaitUntilCanAccess()</code> 内部调用 <code>File.Open()</code> 尝试打开文件时触发了文件被占用的异常，休息 <code>FileAccessCheckIntervalMs</code> 毫秒后，又会调用 <code>File.Open()</code> 检查文件是否可以访问，又会触发文件被占用的异常，如此往复。后续所有的事件都得不到通知了。</p><p>问题的核心有两点：</p><ol><li>同一个文件的变化事件被通知了 <code>2</code> 次或多次。</li><li>外部回调函数中打开了对应的文件，但是没有关闭，而且打开文件时指定的 <code>FileShare</code> 是 <code>FileShare.Read</code> 。而通知线程在调用  <code>WaitUntilCanAccess()</code> 检测文件是否可用时指定的 <code>FileAccess</code> 是 <code>FileAccess.ReadWrite</code>，与 <code>FileShare.Read</code> 冲突。</li></ol><h2 id="解决问题"><a href="#解决问题" class="headerlink" title="解决问题"></a>解决问题</h2><ol><li><p>在调用外部回调函数前，尽量避免同一事件被通知多次。需要增加去除重复事件的支持。</p><p>我已经在 <code>FileSystemWatcherEx</code> 中增加了 <code>TryMergeSameEvent</code> 和 <code>DelayTriggerMs</code>。</p><p><code>TryMergeSameEvent</code> 表示是否合并”相同”事件，默认是 <code>true</code>。</p><p><code>DelayTriggerMs</code> 只有在 <code>TryMergeSameEvent</code> 为 <code>true</code> 的时候才有效。表示在通知事件前等待的毫秒数，默认是 <code>10</code> 毫秒。在这段时间内发生的事件会做去重处理。</p><blockquote><p><strong>说明：</strong> 虽然在一定程度上可以避免事件重复通知的问题，但依然有可能发生重复通知的情况，需要用户自己根据情况进行调整。</p></blockquote></li></ol><ol start="2"><li><p>在外部回调中打开文件后尽快关闭。在本示例代码中，只需要换一种方式显示图片即可——把图像加载到内存后就立刻关闭文件。</p><p>把回调函数中的代码改成下面这样即可。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">OnFileChanged_Ok</span>(<span class="params"><span class="keyword">object</span> sender, System.IO.FileSystemEventArgs e</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (e.ChangeType == System.IO.WatcherChangeTypes.Created </span><br><span class="line">      || e.ChangeType == System.IO.WatcherChangeTypes.Changed)</span><br><span class="line">  &#123;</span><br><span class="line">    s_form.Invoke(<span class="keyword">new</span> MethodInvoker(<span class="keyword">delegate</span>()</span><br><span class="line">    &#123;</span><br><span class="line">      ShowImage(s_form.pictureBox1, e.FullPath);</span><br><span class="line">    &#125;));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">ShowImage</span>(<span class="params">System.Windows.Forms.PictureBox pictureBox, <span class="keyword">string</span> imagePath</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">try</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">using</span> (<span class="keyword">var</span> imageStream = <span class="keyword">new</span> FileStream(imagePath, FileMode.Open))</span><br><span class="line">    &#123;</span><br><span class="line">      pictureBox.Image = (Bitmap)Image.FromStream(imageStream);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">catch</span> (System.Exception)</span><br><span class="line">  &#123;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>还有一点可以优化：</p><p><code>WaitUntilCanAccess()</code> 中用来判断文件是否可以访问的语句如下：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">File.Open(e.FullPath, FileMode.Open, FileAccess.ReadWrite, FileShare.None);</span><br></pre></td></tr></table></figure><p>，其中的 <code>FileShare</code> 指定的太严格了，可以不做限制。改为如下语句：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">File.Open(e.FullPath, FileMode.Open, FileAccess.ReadWrite, (FileShare)<span class="number">0xff</span>);</span><br></pre></td></tr></table></figure></li></ol><h2 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h2><p>直接克隆</p><p><code>github</code> ：<a href="https://github.com/BianChengNan/FileSystemWatcherEx" target="_blank" rel="noopener">https://github.com/BianChengNan/FileSystemWatcherEx</a></p><p><code>gitee</code> ：  <a href="https://gitee.com/bianchengnan/FileSystemWatcherEx" target="_blank" rel="noopener">https://gitee.com/bianchengnan/FileSystemWatcherEx</a></p><p>也可以直接下载压缩包：</p><p>百度云：<a href="https://pan.baidu.com/s/1OBSFpQYRDQHhO5A0Yviqmw" target="_blank" rel="noopener">https://pan.baidu.com/s/1OBSFpQYRDQHhO5A0Yviqmw</a> 提取码: yic3</p><p>CSDN：<a href="https://download.csdn.net/download/xiaoyanilw/19648448" target="_blank" rel="noopener">https://download.csdn.net/download/xiaoyanilw/19648448</a></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li><p><code>process explorer</code> 不仅可以用来查看进程基本信息，还可以查看哪些文件被哪些进程占用。</p></li><li><p><code>windbg</code> 中的 <code>!htrace</code> 也可以用来追踪句柄情况，但是要求附加到对应的程序中。</p></li><li><p><code>perfView</code> 是非常强大的 <code>ETW</code> 收集及分析工具，可以收集机器级别的信息，包括但不限于句柄，文件读写，注册表读写，进程事件，网络事件等等。</p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;缘起&quot;&gt;&lt;a href=&quot;#缘起&quot; class=&quot;headerlink&quot; title=&quot;缘起&quot;&gt;&lt;/a&gt;缘起&lt;/h2&gt;&lt;p&gt;之前基于 &lt;code&gt;.net&lt;/code&gt; 官方提供的 &lt;code&gt;FileSystemWatcher&lt;/code&gt; 写了一个文件变化监听工具，具体参考&lt;a href=&quot;https://bianchengnan.gitee.io/articles/A-better-file-system-wacher-based-on-dotnet-FileSystemWatcher/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;这篇文章&lt;/a&gt; 。主要解决了以下三个问题：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;事件触发时，文件可能还不能被访问。&lt;/li&gt;
&lt;li&gt;如果监听选项设置的过多，有可能会多次触发文件变化事件。&lt;/li&gt;
&lt;li&gt;监听过滤器不够灵活，我没找到同时监听多种特定文件类型的方法（比如，同时只监听 &lt;code&gt;.docx&lt;/code&gt; 和 &lt;code&gt;.bmp&lt;/code&gt; 文件）。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;为了解决&lt;strong&gt;问题1&lt;/strong&gt;，我在调用用户注册的回调函数前，会先调用 &lt;code&gt;WaitUntilCanAccess()&lt;/code&gt; 来确保文件是可访问状态。没想到在测试过程中发现了一个意想不到的问题。本文记录了解决这个问题的过程。&lt;/p&gt;
    
    </summary>
    
      <category term="调试实战" scheme="https://bianchengnan.github.io/categories/%E8%B0%83%E8%AF%95%E5%AE%9E%E6%88%98/"/>
    
    
      <category term="原" scheme="https://bianchengnan.github.io/tags/%E5%8E%9F/"/>
    
      <category term="总结" scheme="https://bianchengnan.github.io/tags/%E6%80%BB%E7%BB%93/"/>
    
      <category term="调试" scheme="https://bianchengnan.github.io/tags/%E8%B0%83%E8%AF%95/"/>
    
      <category term="process explorer" scheme="https://bianchengnan.github.io/tags/process-explorer/"/>
    
      <category term="c#" scheme="https://bianchengnan.github.io/tags/c/"/>
    
      <category term="dotnet" scheme="https://bianchengnan.github.io/tags/dotnet/"/>
    
      <category term="perfview" scheme="https://bianchengnan.github.io/tags/perfview/"/>
    
  </entry>
  
  <entry>
    <title>开发常识 | 彻底理清 CreateFile 读写权限与共享模式的关系</title>
    <link href="https://bianchengnan.github.io//articles/review-CreateFile-DesireAccess-ShareMode/"/>
    <id>https://bianchengnan.github.io//articles/review-CreateFile-DesireAccess-ShareMode/</id>
    <published>2023-12-23T07:44:22.000Z</published>
    <updated>2024-05-18T08:56:44.081Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>前一阵子，我在编写文件变化监控程序的时候遇到了文件被占用的问题。很早之前写过一篇关于 <code>CreateFile</code> 函数的 <code>dwDesiredAccess</code> 和 <code>dwShareMode</code> 参数的笔记。我发现之前的理解不够全面、准确。为了更好的理解这两个参数的作用，我搜索了大量资料，编写了测试程序及测试脚本，参考了 <code>xp</code> 源码，终于搞清楚这两个参数的作用。简而言之，需要遵循以下两个规则：</p><p><strong>规则 1</strong>：后续的<strong>访问权限</strong>与先前的<strong>共享模式</strong>不能冲突。</p><p><strong>规则 2</strong>：后续的<strong>共享模式</strong>与先前的<strong>访问权限</strong>不能冲突。</p><p>如果你对下面的几个问题有明确的答案并且清楚的知道原因，那么可以跳过本文了。</p><ol><li>第一次以<strong>读</strong>访问权限，<strong>写</strong>共享模式打开文件，会成功吗？</li><li>如果第一次打开成功了，第二次以<strong>写</strong>访问权限，<strong>读</strong>共享模式打开。会成功吗？</li><li>如果第二次打开成功了，第三次以<strong>读</strong> / <strong>写</strong> / <strong>读写</strong>访问权限，<strong>读写</strong>共享模式打开，会成功吗？</li><li>第一次以<strong>读</strong>访问权限，<strong>写</strong>共享模式打开文件，第二次以<strong>写</strong>访问权限，<strong>读写</strong>共享模式打开。第三次以<strong>写</strong>访问权限，<strong>读写</strong>共享模式打开，会成功吗？</li></ol><a id="more"></a><p>在总结之前，先看一下关键的权限检查代码。</p><h2 id="参考源码"><a href="#参考源码" class="headerlink" title="参考源码"></a>参考源码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">NTSTATUS <span class="title">IoCheckShareAccess</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  IN ACCESS_MASK DesiredAccess,</span></span></span><br><span class="line"><span class="function"><span class="params">  IN ULONG DesiredShareAccess,</span></span></span><br><span class="line"><span class="function"><span class="params">  IN OUT PFILE_OBJECT FileObject,</span></span></span><br><span class="line"><span class="function"><span class="params">  IN OUT PSHARE_ACCESS ShareAccess,</span></span></span><br><span class="line"><span class="function"><span class="params">  IN BOOLEAN Update</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  PAGED_CODE();</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 获取本次调用时，指定的 读/写/删除 访问权限标志</span></span><br><span class="line">  FileObject-&gt;ReadAccess = (BOOLEAN) ((DesiredAccess &amp; (FILE_EXECUTE | FILE_READ_DATA)) != <span class="number">0</span>);</span><br><span class="line">  FileObject-&gt;WriteAccess = (BOOLEAN) ((DesiredAccess &amp; (FILE_WRITE_DATA | FILE_APPEND_DATA)) != <span class="number">0</span>);</span><br><span class="line">  FileObject-&gt;DeleteAccess = (BOOLEAN) ((DesiredAccess &amp; DELETE) != <span class="number">0</span>);</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span> (FileObject-&gt;ReadAccess || FileObject-&gt;WriteAccess || FileObject-&gt;DeleteAccess)</span><br><span class="line">  &#123;      </span><br><span class="line">    <span class="comment">// 获取本次调用时，指定的 读/写/删除 共享模式标志</span></span><br><span class="line">    FileObject-&gt;SharedRead = (BOOLEAN) ((DesiredShareAccess &amp; FILE_SHARE_READ) != <span class="number">0</span>);</span><br><span class="line">    FileObject-&gt;SharedWrite = (BOOLEAN) ((DesiredShareAccess &amp; FILE_SHARE_WRITE) != <span class="number">0</span>);</span><br><span class="line">    FileObject-&gt;SharedDelete = (BOOLEAN) ((DesiredShareAccess &amp; FILE_SHARE_DELETE) != <span class="number">0</span>);</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">if</span> (FileObject-&gt;Flags &amp; FO_FILE_OBJECT_HAS_EXTENSION)</span><br><span class="line">    &#123;</span><br><span class="line">      PIOP_FILE_OBJECT_EXTENSION  fileObjectExtension =(PIOP_FILE_OBJECT_EXTENSION)(FileObject + <span class="number">1</span>);</span><br><span class="line">      <span class="keyword">if</span> (fileObjectExtension-&gt;FileObjectExtensionFlags &amp; FO_EXTENSION_IGNORE_SHARE_ACCESS_CHECK)</span><br><span class="line">        <span class="keyword">return</span> STATUS_SUCCESS;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    ULONG ocount = ShareAccess-&gt;OpenCount;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">if</span> ( <span class="comment">// 本次调用时 DesiredAccess 包含了读/写/删除标志，并且</span></span><br><span class="line">         <span class="comment">// 在之前的调用中，DesiredShareAccess 缺少对应的读/写/删除标志（ShareXXX &lt; ocount）</span></span><br><span class="line">         (FileObject-&gt;ReadAccess &amp;&amp; (ShareAccess-&gt;SharedRead &lt; ocount))</span><br><span class="line">      || (FileObject-&gt;WriteAccess &amp;&amp; (ShareAccess-&gt;SharedWrite &lt; ocount))</span><br><span class="line">      || (FileObject-&gt;DeleteAccess &amp;&amp; (ShareAccess-&gt;SharedDelete &lt; ocount))</span><br><span class="line">         <span class="comment">// 之前的调用中 DesiredAccess 包含了读/写/删除标志，并且</span></span><br><span class="line">         <span class="comment">// 本次调用时 DesiredShareAccess 缺少对应读/写/删除标志 </span></span><br><span class="line">      || ((ShareAccess-&gt;Readers != <span class="number">0</span>) &amp;&amp; !FileObject-&gt;SharedRead)</span><br><span class="line">      || ((ShareAccess-&gt;Writers != <span class="number">0</span>) &amp;&amp; !FileObject-&gt;SharedWrite)</span><br><span class="line">      || ((ShareAccess-&gt;Deleters != <span class="number">0</span>) &amp;&amp; !FileObject-&gt;SharedDelete)</span><br><span class="line">    )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">return</span> STATUS_SHARING_VIOLATION;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (Update)</span><br><span class="line">    &#123;</span><br><span class="line">      ShareAccess-&gt;OpenCount++; <span class="comment">// 每次权限检查通过后，打开计数 +1</span></span><br><span class="line">    </span><br><span class="line">      <span class="comment">// 本次调用时 DesiredAccess 包含了读/写/删除标志，对应的计数 +1</span></span><br><span class="line">      ShareAccess-&gt;Readers += FileObject-&gt;ReadAccess;</span><br><span class="line">      ShareAccess-&gt;Writers += FileObject-&gt;WriteAccess;</span><br><span class="line">      ShareAccess-&gt;Deleters += FileObject-&gt;DeleteAccess;</span><br><span class="line">    </span><br><span class="line">      <span class="comment">// 本次调用时 DesiredShareAccess 包含了读/写/删除标志，对应的计数 +1</span></span><br><span class="line">      ShareAccess-&gt;SharedRead += FileObject-&gt;SharedRead;</span><br><span class="line">      ShareAccess-&gt;SharedWrite += FileObject-&gt;SharedWrite;</span><br><span class="line">      ShareAccess-&gt;SharedDelete += FileObject-&gt;SharedDelete;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> STATUS_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><strong>说明：</strong> <code>DesiredAccess</code> 表示 访问权限，<code>DesiredShareAccess</code> 表示 共享模式。</p></blockquote><p>代码中的注释已经写的很清楚了，再整体梳理一下：</p><p><strong>更新逻辑（else if 分支）：</strong></p><p>每次权限检查成功后，如果指定了 <code>Update</code> 参数，<code>SharedAccess-&gt;OpenCount</code> 计数会加一。</p><p>当 <code>DesiredAccess</code> 包含<strong>读</strong> / <strong>写</strong> / <strong>删除</strong>标志的时候，<code>SharedAccess-&gt;Readers / Writers / Deleters</code> 计数会加一。</p><p>当 <code>DesiredShareAccess</code> 包含<strong>读</strong> / <strong>写</strong> / <strong>删除</strong>标志的时候，<code>ShareAccess-&gt;SharedRead / SharedWrite / SharedDelete</code> 计数会加一。</p><p><strong>检查逻辑（if 分支）：</strong></p><ul><li><p>如果本次调用时 <code>DesiredAccess</code> 包含了<strong>读</strong> / <strong>写</strong> / <strong>删除</strong>标志（<code>FileObject-&gt;ReadAccess / WriteAccess / DeleteAccess</code> 为真）并且在之前的调用中 <code>DesiredShareAccess</code> 缺少对应的<strong>读</strong> / <strong>写</strong> / <strong>删除</strong>标志（<code>ShareAccess-&gt;SharedRead / SharedWrite / SharedDelete &lt; ocount</code>），违反<strong>规则 1</strong>，权限检查会失败。</p></li><li><p>如果在之前的调用中 <code>DesiredAccess</code> 包含了<strong>读</strong> / <strong>写</strong> / <strong>删除</strong>标志（<code>ShareAccess-&gt;Readers / Writers / Deleters != 0</code>），并且本次调用时 <code>DesiredShareAccess</code> 缺少对应<strong>读</strong> / <strong>写</strong> / <strong>删除</strong>标志（<code>FileObject-&gt;SharedRead / SharedWrite / SharedDelete</code> 为假），违反<strong>规则 2</strong>，权限检查会失败。</p></li></ul><p>我把各种情况下的打开结果整理成了表格，供大家参考。</p><h2 id="结果表"><a href="#结果表" class="headerlink" title="结果表"></a>结果表</h2><table><thead><tr><th>访问权限 1</th><th>共享模式 1</th><th>访问权限 2</th><th>共享模式 2</th><th>结果</th><th>说明</th></tr></thead><tbody><tr><td>—</td><td>N</td><td>R / W / RW</td><td>—</td><td>失败</td><td>违反了 <strong>规则1</strong></td></tr><tr><td>—</td><td>R</td><td>W / RW</td><td>—</td><td>失败</td><td>违反了 <strong>规则1</strong></td></tr><tr><td>—</td><td>W</td><td>R / RW</td><td>—</td><td>失败</td><td>违反了 <strong>规则1</strong></td></tr><tr><td>R / W / RW</td><td>—</td><td>—</td><td>N</td><td>失败</td><td>违反了 <strong>规则2</strong></td></tr><tr><td>W / RW</td><td>—</td><td>—</td><td>R</td><td>失败</td><td>违反了 <strong>规则2</strong></td></tr><tr><td>R / RW</td><td>—</td><td>—</td><td>W</td><td>失败</td><td>违反了 <strong>规则2</strong></td></tr><tr><td>R</td><td>R</td><td>R</td><td>R / RW</td><td>成功</td><td>第二次的<strong>访问权限</strong>与第一次的<strong>共享模式</strong>不冲突。 <br>第二次的<strong>共享模式</strong>与第一次的<strong>访问权限</strong>不冲突。</td></tr><tr><td>R</td><td>W</td><td>W</td><td>R / RW</td><td>成功</td><td>同上</td></tr><tr><td>R</td><td>RW</td><td>R / W / RW</td><td>R / RW</td><td>成功</td><td>同上</td></tr><tr><td>W</td><td>W</td><td>W</td><td>W / RW</td><td>成功</td><td>同上</td></tr><tr><td>W</td><td>R</td><td>R</td><td>W / RW</td><td>成功</td><td>同上</td></tr><tr><td>W</td><td>RW</td><td>R / W / RW</td><td>W / RW</td><td>成功</td><td>同上</td></tr><tr><td>RW</td><td>R</td><td>R</td><td>RW</td><td>成功</td><td>同上</td></tr><tr><td>RW</td><td>W</td><td>W</td><td>RW</td><td>成功</td><td>同上</td></tr><tr><td>RW</td><td>RW</td><td>R / W / RW</td><td>RW</td><td>成功</td><td>同上</td></tr></tbody></table><p>各项的意义解释如下：</p><ul><li><p><code>访问权限</code> 代表 <code>dwDesiredAccess</code> 参数，<code>共享模式</code> 代表 <code>dwShareAccess</code> 参数。<code>1</code> 表示第一次调用，<code>2</code> 表示第二次调用。</p></li><li><p><code>R</code> <code>Read</code>，表示<strong>读</strong>。<code>W</code> <code>Write</code>，表示<strong>写</strong>。<code>RW</code> <code>ReadWrite</code>，表示<strong>读写</strong>。<code>N</code> <code>None</code>， 表示<strong>独占</strong>。</p></li><li><p><code>/</code> 表示或者。为了减少组合数量。比如第一行中的 <strong>访问权限 2</strong> 可以是<strong>读</strong> / <strong>写</strong> / <strong>读写</strong>中的任意一种。</p></li><li><p><code>---</code> 表示对应位置是什么都可以，不影响结果。比如，第一行的 <strong>访问权限 1</strong> 可以是<strong>读</strong> / <strong>写</strong> / <strong>读写</strong>中的任意一种，不论是哪种都会打开失败。</p></li><li><p><strong>结果</strong>列只统计了第二次的结果，因为第一次总是成功的。</p></li></ul><p>以上结论我在 <code>win10</code> 系统上亲自验证过，整体验证思路是用不同的参数调用 <code>CreateFile</code> 打开同一个文件。关键验证代码如下：</p><h2 id="验证代码"><a href="#验证代码" class="headerlink" title="验证代码"></a>验证代码</h2><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> System.CommandLine;</span><br><span class="line"><span class="keyword">using</span> System.IO;</span><br><span class="line"><span class="keyword">using</span> System.Linq;</span><br><span class="line"><span class="keyword">using</span> System.Text;</span><br><span class="line"><span class="keyword">using</span> System.Threading.Tasks;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">CreateFile</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// ref https://learn.microsoft.com/en-us/dotnet/standard/commandline/define-commands</span></span><br><span class="line">        <span class="function"><span class="keyword">static</span> Command <span class="title">SetupCommandHandler</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>        &#123;</span><br><span class="line">            <span class="keyword">var</span> filePathOption = <span class="keyword">new</span> Option&lt;<span class="keyword">string</span>&gt;(name: <span class="string">"--path"</span>, getDefaultValue: () =&gt; <span class="string">"test.txt"</span>, description: <span class="string">"file path"</span>);</span><br><span class="line">            filePathOption.AddAlias(<span class="string">"-f"</span>);</span><br><span class="line">            filePathOption.AddAlias(<span class="string">"-p"</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">var</span> fileModeOption = <span class="keyword">new</span> Option&lt;<span class="keyword">string</span>&gt;(name: <span class="string">"--mode"</span>, getDefaultValue: () =&gt; <span class="string">"Open"</span>, description: <span class="string">"file mode"</span>)</span><br><span class="line">                .FromAmong(<span class="string">"CreateNew"</span>, <span class="string">"Create"</span>, <span class="string">"Open"</span>, <span class="string">"OpenOrCreate"</span>, <span class="string">"Truncate"</span>, <span class="string">"Append"</span>);</span><br><span class="line">            fileModeOption.AddAlias(<span class="string">"-m"</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">var</span> fileShareOption = <span class="keyword">new</span> Option&lt;<span class="keyword">string</span>&gt;(<span class="string">"--share"</span>, <span class="string">"file share"</span>) &#123; IsRequired = <span class="literal">true</span> &#125;</span><br><span class="line">                .FromAmong(<span class="string">"None"</span>, <span class="string">"Read"</span>, <span class="string">"Write"</span>, <span class="string">"ReadWrite"</span>, <span class="string">"Delete"</span>, <span class="string">"Inheritable"</span>);</span><br><span class="line">            fileShareOption.AddAlias(<span class="string">"-s"</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">var</span> fileAccessOption = <span class="keyword">new</span> Option&lt;<span class="keyword">string</span>&gt;(<span class="string">"--access"</span>, <span class="string">"file access"</span>) &#123; IsRequired = <span class="literal">true</span> &#125;</span><br><span class="line">                .FromAmong(<span class="string">"Read"</span>, <span class="string">"Write"</span>, <span class="string">"ReadWrite"</span>);</span><br><span class="line">            fileAccessOption.AddAlias(<span class="string">"-a"</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">var</span> autoQuitOption = <span class="keyword">new</span> Option&lt;<span class="keyword">bool</span>&gt;(name: <span class="string">"--autoquit"</span>, getDefaultValue: () =&gt; <span class="literal">false</span>, description: <span class="string">"auto quit"</span>);</span><br><span class="line">            autoQuitOption.AddAlias(<span class="string">"-q"</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">var</span> command = <span class="keyword">new</span> RootCommand();</span><br><span class="line">            command.Add(filePathOption);</span><br><span class="line">            command.Add(fileModeOption);</span><br><span class="line">            command.Add(fileShareOption);</span><br><span class="line">            command.Add(fileAccessOption);</span><br><span class="line">            command.Add(autoQuitOption);</span><br><span class="line"></span><br><span class="line">            command.SetHandler((filePath, fileMode, fileShare, fileAccess, autoQuit) =&gt;</span><br><span class="line">            &#123;</span><br><span class="line">                OpenFileAndWait(filePath, fileMode, fileShare, fileAccess, autoQuit);</span><br><span class="line">            &#125;, filePathOption, fileModeOption, fileShareOption, fileAccessOption, autoQuitOption);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> command;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="keyword">string</span>[] args</span>)</span></span><br><span class="line"><span class="function"></span>        &#123;</span><br><span class="line">            <span class="keyword">var</span> command = SetupCommandHandler();</span><br><span class="line">            command.Invoke(args);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">OpenFileAndWait</span>(<span class="params"><span class="keyword">string</span> strFilePath, <span class="keyword">string</span> strFileMode, <span class="keyword">string</span> strFileShare, <span class="keyword">string</span> strFileAccess, <span class="keyword">bool</span> autoQuit</span>)</span></span><br><span class="line"><span class="function"></span>        &#123;</span><br><span class="line">            FileStream stream = <span class="literal">null</span>;</span><br><span class="line">            <span class="keyword">try</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">var</span> fileMode = (FileMode)System.Enum.Parse(<span class="keyword">typeof</span>(FileMode), strFileMode);</span><br><span class="line">                <span class="keyword">var</span> fileShare = (FileShare)System.Enum.Parse(<span class="keyword">typeof</span>(FileShare), strFileShare);</span><br><span class="line">                <span class="keyword">var</span> fileAccess = (FileAccess)System.Enum.Parse(<span class="keyword">typeof</span>(FileAccess), strFileAccess);</span><br><span class="line"></span><br><span class="line">                System.Console.WriteLine(<span class="keyword">string</span>.Format(<span class="string">"[&#123;0&#125;] file:&#123;1&#125;, mode: &#123;2&#125;, share: &#123;3&#125;, access: &#123;4&#125;!"</span></span><br><span class="line">                  , System.DateTime.Now.ToString(<span class="string">"yyyy-MM-dd HH:mm:ss.fff"</span>), strFilePath, strFileMode, strFileShare, strFileAccess));</span><br><span class="line"></span><br><span class="line">                stream = File.Open(strFilePath, fileMode, fileAccess, fileShare);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">catch</span> (Exception ex)</span><br><span class="line">            &#123;</span><br><span class="line">                System.Console.WriteLine(<span class="keyword">string</span>.Format(<span class="string">"opening file [&#123;0&#125;] failed with &#123;1&#125;!"</span>, strFilePath, ex));</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (!autoQuit)</span><br><span class="line">            &#123;</span><br><span class="line">                System.Console.WriteLine(<span class="string">"press any key to continue..."</span>);</span><br><span class="line">                System.Console.ReadKey();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (stream != <span class="literal">null</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                stream.Dispose();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>生成的程序名是 <code>CreateFile.exe</code>，该程序可以接收命令行参数，通过 <code>-f</code> 指定文件名，通过 <code>-a</code> 指定访问权限，通过 <code>-s</code> 指定共享模式， 通过 <code>-h</code> 显示帮助。</p><h2 id="验证脚本"><a href="#验证脚本" class="headerlink" title="验证脚本"></a>验证脚本</h2><p>为了更方便的验证，我又写了批处理脚本，关键脚本如下：</p><figure class="highlight bat"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">:: read-readwrite-write-none.bat</span><br><span class="line">CreateFileBatchCaller.bat <span class="variable">%~n0%</span></span><br></pre></td></tr></table></figure><figure class="highlight bat"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">:: CreateFileBatchCaller.bat</span><br><span class="line">@<span class="built_in">echo</span> off</span><br><span class="line"><span class="built_in">cd</span> /d %~dp0</span><br><span class="line"></span><br><span class="line"><span class="built_in">setlocal</span> enabledelayedexpansion</span><br><span class="line"></span><br><span class="line"><span class="built_in">set</span> AccessParams=<span class="variable">%1%</span></span><br><span class="line"><span class="built_in">set</span> AccessParams=<span class="variable">%AccessParams:read=Read%</span></span><br><span class="line"><span class="built_in">set</span> AccessParams=<span class="variable">%AccessParams:write=Write%</span></span><br><span class="line"><span class="built_in">set</span> AccessParams=<span class="variable">%AccessParams:none=None%</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">For</span> /f "tokens=<span class="number">1</span>-<span class="number">4</span> delims=_/. " <span class="variable">%%i</span> <span class="keyword">In</span> ("<span class="variable">%AccessParams%</span>") <span class="keyword">do</span> (</span><br><span class="line">  <span class="built_in">set</span> Access1=<span class="variable">%%i</span></span><br><span class="line">  <span class="built_in">set</span> SharedAccess1=<span class="variable">%%j</span></span><br><span class="line">  <span class="built_in">set</span> Access2=<span class="variable">%%k</span></span><br><span class="line">  <span class="built_in">set</span> SharedAccess2=<span class="variable">%%l</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="built_in">start</span> CreateFile -f test.txt -a <span class="variable">%Access1%</span> -s <span class="variable">%SharedAccess1%</span></span><br><span class="line"></span><br><span class="line">:: will this success?</span><br><span class="line">timeout /T <span class="number">1</span></span><br><span class="line"><span class="built_in">start</span> CreateFile -f test.txt -a <span class="variable">%Access2%</span> -s <span class="variable">%SharedAccess2%</span></span><br></pre></td></tr></table></figure><p>脚本 <code>CreateFileBatchCaller.bat</code> 接收一个参数，内部会根据 <code>-</code> 分割参数，前四项有固定意义，分别表示第一次调用 <code>CreateFile.exe</code> 的访问权限和共享模式、第二次调用 <code>CreateFile.exe</code> 的访问权限和共享模式。</p><p><code>read-readwrite-write-none-failed.bat</code> 是众多调用脚本中的一个，内部会把当前脚本的文件名（不包括扩展名）当作参数调用 <code>CreateFileBatchCaller.bat</code> 。 该脚本可以验证第一次以<strong>读</strong>访问权限、<strong>读写</strong>共享模式打开文件，第二次以<strong>写</strong>访问权限、<strong>独占</strong>共享模式打开文件的情况。 </p><h2 id="亲自动手"><a href="#亲自动手" class="headerlink" title="亲自动手"></a>亲自动手</h2><p>所有脚本及源码我已经上传到我的个人仓库了。如果你也想亲自动手验证一下，可以从如下位置获取测试代码，编译好的程序及测试脚本。</p><p>github:</p><p><a href="https://github.com/BianChengNan/MyBlogStuff/tree/master/review-CreateFile-DesireAccess-ShareMode" target="_blank" rel="noopener">https://github.com/BianChengNan/MyBlogStuff/tree/master/review-CreateFile-DesireAccess-ShareMode</a></p><p>gitee:</p><p><a href="https://gitee.com/bianchengnan/my-blog-stuff/tree/master/review-CreateFile-DesireAccess-ShareMode" target="_blank" rel="noopener">https://gitee.com/bianchengnan/my-blog-stuff/tree/master/review-CreateFile-DesireAccess-ShareMode</a></p><p>百度云盘：</p><p><a href="https://pan.baidu.com/s/10BMMhPGiiBYjlMFrbQH-3g?pwd=tibm" target="_blank" rel="noopener">https://pan.baidu.com/s/10BMMhPGiiBYjlMFrbQH-3g?pwd=tibm</a></p><p>至此，文章开头的几个问题的答案应该已经很明显了。一起来看一下。</p><h2 id="解惑"><a href="#解惑" class="headerlink" title="解惑"></a>解惑</h2><ol><li><p>第一次尝试以<strong>读</strong>访问权限，<strong>写</strong>共享模式打开文件，会成功吗？</p><p><strong>答：会成功。</strong></p><p>第一次打开时总会成功。</p></li></ol><ol start="2"><li><p>如果第一次打开成功了，第二次尝试以<strong>写</strong>访问权限，<strong>读</strong>共享模式打开。会成功吗？</p><p><strong>答：会成功。</strong></p><p>第一次的共享模式是<strong>写</strong>，第二次的访问权限是<strong>写</strong>，第二次的访问权限与第一次的共享模式不冲突。</p><p>第二次的共享模式是<strong>读</strong>，第一次的访问权限是<strong>读</strong>，第二次的共享模式与第一次的访问权限不冲突。</p><p><img src="http://resources.bianchengnan.tech/review-CreateFile-DesireAccess-ShareMode/open-result-2.png" alt="open-result-2"></p></li></ol><ol start="3"><li><p>如果第二次打开成功了，第三次尝试以<strong>读</strong>/<strong>写</strong>/<strong>读写</strong>访问权限，<strong>读写</strong>共享模式打开，会成功吗？</p><p><strong>答：不会成功。</strong></p><p>第三次的访问权限是<strong>读</strong>的话，与第一次的共享模式（<strong>写</strong>）冲突。</p><p>第三次的访问权限是<strong>写</strong>的话，与第二次的共享模式（<strong>读</strong>）冲突。</p><p>第三次的访问权限是<strong>读写</strong>的话，既与第一次的共享模式（<strong>写</strong>）冲突，又与第二次的共享模式（<strong>读</strong>）冲突。<br><img src="http://resources.bianchengnan.tech/review-CreateFile-DesireAccess-ShareMode/open-result-3.png" alt="open-result-3"></p><p>这里只贴了第三次的访问权限是<strong>写</strong>的情况，其它两种情况也会失败。</p></li><li><p>第一次尝试以<strong>读</strong>访问权限，<strong>写</strong>共享模式打开文件，第二次尝试以<strong>写</strong>访问权限，<strong>读写</strong>共享模式打开。第三次尝试以<strong>写</strong>访问权限，<strong>读写</strong>共享模式打开，会成功吗？</p><p><strong>答：会成功。</strong></p><p>第三次的访问权限（<strong>写</strong>），既不与第一次的共享模式（<strong>写</strong>）冲突，又不与第二次的共享模式（<strong>读写</strong>）冲突。</p><p>第三次的共享模式（<strong>读写</strong>），既不与第一次的访问权限（<strong>读</strong>）冲突，又不与第二次的访问权限（<strong>写</strong>）冲突。<br><img src="http://resources.bianchengnan.tech/review-CreateFile-DesireAccess-ShareMode/open-result-4.png" alt="open-result-4"></p></li></ol><p>最后，贴一下之前整理的笔记，基本正确，但是不够全面，不够深刻。</p><h2 id="CreateFile-参数"><a href="#CreateFile-参数" class="headerlink" title="CreateFile 参数"></a>CreateFile 参数</h2><p>一直对 <code>CreateFile</code> 的参数 <code>dwDesiredAccess</code> 和 <code>dwShareMode</code> 的具体作用不是很清楚，今天重读《windows 核心编程》的时候有了一些新感悟。 简要总结如下：</p><ul><li><code>dwDesiredAccess</code> 表示本次 <code>CreateFile</code> 想要获取的权限: 只读(<code>GENERIC_READ</code>)，只写(<code>GENERIC_WRITE</code>)，可读写 (<code>GENERIC_READ | GENERIC_WRITE</code>)。</li><li><code>dwShareMode</code> 表示后续 <code>CreateFile</code> 可以取得什么权限。</li></ul><p>对 <code>dwDesiredAccess</code> 各种值及含义抄录如下（摘自 《Windows核心编程》第 <code>5</code> 版 第<code>10</code> 章 <code>p279</code>）：</p><table><thead><tr><th>值</th><th>含义</th></tr></thead><tbody><tr><td>0</td><td>我们不希望从设备读取数据或向设备写入数据。如果只想改变设备的配置（比如只是修改文件的时间戳），那么可以传 <code>0</code></td></tr><tr><td>GENERIC_READ</td><td>允许对设备进行只读访问</td></tr><tr><td>GENERIC_WRITE</td><td>允许对设备进行只写访问。例如，备份软件会用到这个标志，如果想把数据发送到打印机，也可以使用这个标志。注意，<code>GENERIC_WRITE</code> 标志并没有隐式地包含 <code>GENERIC_READ</code> 标志</td></tr><tr><td>GENERIC_READ | GENERIC_WRITE</td><td>允许对设备进行读写操作。由于这个标志允许我们和设备之间自由地交换数据，因此最为常用</td></tr></tbody></table><p>对 <code>dwShareMode</code> 的各种值及含义抄录如下（摘自 《Windows核心编程》第 <code>5</code> 版 第<code>10</code> 章 <code>p279</code>）：</p><table><thead><tr><th>值</th><th>含义</th></tr></thead><tbody><tr><td>0</td><td>要求独占对设备的访问。 如果设备己经打开，<code>CreateFile</code> 调用会失败。如果我们成功地打开了设备，那么后续的 <code>CreateFile</code> 调用会失败</td></tr><tr><td>FILE_SHARE_READ</td><td>如果有其他内核对象要使用该设备，我们要求它们不得修改设备的数据。 如果设备已经以写入方式或独占方式打开，那么我们的 <code>CreateFile</code> 会失败。 如果我们成功地打开了设备，那么后续的使用了 <code>GENERIC_WRITE</code> 访问标志的 <code>CreateFile</code> 调用会失败</td></tr><tr><td>FILE_SHARE_WRITE</td><td>如果有其他内核对象要使用该设备，我们要求它们不得读取设备的数据。 如果设备已经以读取方式或独占方式打开，那么我们的 <code>CreateFile</code> 调用会失败。 如果我们成功地打开了设备，那么后续的使用了<code>GENERIC_READ</code> 访问标志的 <code>CreateFile</code> 调用会失畋</td></tr><tr><td>FILE_SHARE_READ | FILE_SHARE_WRITE</td><td>如果有其他内核对象要使用该设备，我们不关心它们会从设备读取数据还是会向设备写入数据。如果设备已经以独占方式打开，那么我们的 <code>CreateFile</code> 调用会失败。如果我们成功地打开了设备，那么后续的要求独占读取访问、独占写入访问或独占读写访问的 <code>CreateFile</code> 调用会失败</td></tr><tr><td>FILE_SHARE_DELETE</td><td>当对文件进行操作的时候，我们不关心文件是否被逻辑删除或是被移动。在 <code>Windows</code> 内部，系统会先将文件标记为待删除，然后当该文件所有已打开的句柄都被关闭的时候，再将其真正的删除</td></tr></tbody></table><blockquote><p><strong>友情提示：</strong> 上表中的 <code>如果设备已经以 xxx 方式打开</code> 指的是先前调用的 <code>dwShareMode</code> 参数。</p></blockquote><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://0cch.com/2011/05/22/e585b3e4ba8ee69687e4bbb6shareaccess/" target="_blank" rel="noopener">https://0cch.com/2011/05/22/e585b3e4ba8ee69687e4bbb6shareaccess/</a>  强烈推荐阅读！！！</li><li><a href="https://docs.microsoft.com/en-us/windows/win32/api/fileapi/nf-fileapi-createfilea" target="_blank" rel="noopener">https://docs.microsoft.com/en-us/windows/win32/api/fileapi/nf-fileapi-createfilea</a></li><li><a href="https://community.osr.com/discussion/32329/file-object-fscontext9" target="_blank" rel="noopener">https://community.osr.com/discussion/32329/file-object-fscontext9</a></li><li>《windows 核心编程》第 <code>5</code> 版 第<code>10</code> 章</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;前一阵子，我在编写文件变化监控程序的时候遇到了文件被占用的问题。很早之前写过一篇关于 &lt;code&gt;CreateFile&lt;/code&gt; 函数的 &lt;code&gt;dwDesiredAccess&lt;/code&gt; 和 &lt;code&gt;dwShareMode&lt;/code&gt; 参数的笔记。我发现之前的理解不够全面、准确。为了更好的理解这两个参数的作用，我搜索了大量资料，编写了测试程序及测试脚本，参考了 &lt;code&gt;xp&lt;/code&gt; 源码，终于搞清楚这两个参数的作用。简而言之，需要遵循以下两个规则：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;规则 1&lt;/strong&gt;：后续的&lt;strong&gt;访问权限&lt;/strong&gt;与先前的&lt;strong&gt;共享模式&lt;/strong&gt;不能冲突。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;规则 2&lt;/strong&gt;：后续的&lt;strong&gt;共享模式&lt;/strong&gt;与先前的&lt;strong&gt;访问权限&lt;/strong&gt;不能冲突。&lt;/p&gt;
&lt;p&gt;如果你对下面的几个问题有明确的答案并且清楚的知道原因，那么可以跳过本文了。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;第一次以&lt;strong&gt;读&lt;/strong&gt;访问权限，&lt;strong&gt;写&lt;/strong&gt;共享模式打开文件，会成功吗？&lt;/li&gt;
&lt;li&gt;如果第一次打开成功了，第二次以&lt;strong&gt;写&lt;/strong&gt;访问权限，&lt;strong&gt;读&lt;/strong&gt;共享模式打开。会成功吗？&lt;/li&gt;
&lt;li&gt;如果第二次打开成功了，第三次以&lt;strong&gt;读&lt;/strong&gt; / &lt;strong&gt;写&lt;/strong&gt; / &lt;strong&gt;读写&lt;/strong&gt;访问权限，&lt;strong&gt;读写&lt;/strong&gt;共享模式打开，会成功吗？&lt;/li&gt;
&lt;li&gt;第一次以&lt;strong&gt;读&lt;/strong&gt;访问权限，&lt;strong&gt;写&lt;/strong&gt;共享模式打开文件，第二次以&lt;strong&gt;写&lt;/strong&gt;访问权限，&lt;strong&gt;读写&lt;/strong&gt;共享模式打开。第三次以&lt;strong&gt;写&lt;/strong&gt;访问权限，&lt;strong&gt;读写&lt;/strong&gt;共享模式打开，会成功吗？&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="开发" scheme="https://bianchengnan.github.io/categories/%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="开发" scheme="https://bianchengnan.github.io/tags/%E5%BC%80%E5%8F%91/"/>
    
      <category term="win10" scheme="https://bianchengnan.github.io/tags/win10/"/>
    
      <category term="xp" scheme="https://bianchengnan.github.io/tags/xp/"/>
    
      <category term="权限" scheme="https://bianchengnan.github.io/tags/%E6%9D%83%E9%99%90/"/>
    
      <category term="基础知识" scheme="https://bianchengnan.github.io/tags/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
      <category term="CreateFile" scheme="https://bianchengnan.github.io/tags/CreateFile/"/>
    
  </entry>
  
  <entry>
    <title>如何确定线程栈的基址？</title>
    <link href="https://bianchengnan.github.io//articles/how-to-check-thread-stack-base/"/>
    <id>https://bianchengnan.github.io//articles/how-to-check-thread-stack-base/</id>
    <published>2023-10-28T23:44:04.000Z</published>
    <updated>2024-05-18T08:56:43.903Z</updated>
    
    <content type="html"><![CDATA[<h2 id="缘起"><a href="#缘起" class="headerlink" title="缘起"></a>缘起</h2><p>很早之前，我遇到过几个与栈相关的问题，当时总结过几篇关于线程栈的文章，分别是 <a href="https://bianchengnan.gitee.io/articles/interesting-exception-0xc00000fd-continue-how-to-increase-stack-size/" target="_blank" rel="noopener">《栈大小可以怎么改？》</a>、<a href="https://bianchengnan.gitee.io/articles/stack-variable-usage-optimization-investigation/" target="_blank" rel="noopener">《栈局部变量优化探究，意外发现了 vs 的一个 bug ？》</a>、<a href="https://bianchengnan.gitee.io/articles/another-interesting-stackoverflow/" target="_blank" rel="noopener">《栈又溢出了》</a>、<a href="https://bianchengnan.gitee.io/articles/interesting-exception-0xc00000fd/" target="_blank" rel="noopener">《有趣的异常》</a>。在这几篇总结中，简单的总结了栈溢出的原因，设置线程栈大小的方法。但是还有一点没弄清楚：操作系统是怎么知道一个线程的栈大小的？一定记录在某个位置了，否则就不能正确的在栈溢出的时候抛出异常了。不能根据 <code>PE</code> 头中的字段判断，因为在创建线程的时候可以指定线程栈大小。<code>TEB</code> 中的 <code>StackLimit</code> 是真正的栈底吗？带着这些疑问一起来刨根问底吧~</p><blockquote><p><strong>友情提示</strong>：结论在文章末尾。</p></blockquote><a id="more"></a><h2 id="teb-命令"><a href="#teb-命令" class="headerlink" title="!teb 命令"></a>!teb 命令</h2><p>相信，很多小伙伴儿都知道，可以使用 <code>!teb</code> 查看线程相关的信息。</p><p><img src="http://resources.bianchengnan.tech/how-to-check-thread-stack-base/view-thread-using-teb-command.png" alt="view-thread-using-teb-command"></p><p>其中的 <code>StackBase</code> 和 <code>StackLimit</code> 分别指示了栈顶和当前栈使用情况。因为栈是从上向下增长的，所以 <code>StackBase</code> 的值比较大。</p><p>我之前一直认为这两个字段分别指向了栈顶和栈底（线程栈可以到达的最低位置），可以通过这两个字段计算出线程栈大小。后来才发现 <code>StackLimit</code> 并没有指向栈底，而是指向了线程栈当前所到达的最低位置。</p><p>线程栈默认的大小是 <code>1MB</code>。如果计算一下 <code>StackBase - StackLimit</code> 的值即可知道，它们的差值是 <code>256KB</code>，而不是 <code>1MB</code>。</p><p><img src="http://resources.bianchengnan.tech/how-to-check-thread-stack-base/calculate-current-thread-stack-size.png" alt="calculate-current-thread-stack-size"></p><p>那么当前线程栈的大小是不是 <code>1MB</code> 呢？该如何确认呢？可以通过 <code>vmmap</code> 确定。</p><h2 id="vmmap"><a href="#vmmap" class="headerlink" title="vmmap"></a>vmmap</h2><p>打开 <code>vmmap.exe</code>，并选择想要查看的进程，即可进行查看。</p><blockquote><p><strong>注意：</strong> 当选择的进程已经中断到调试器时，<code>vmmap.exe</code> 会一直等待，需要让目标进程运行起来。</p></blockquote><p><img src="http://resources.bianchengnan.tech/how-to-check-thread-stack-base/view-stack-size-in-vmmap.png" alt="view-stack-size-in-vmmap"></p><p>可以看到，线程 <code>9804</code> 的线程栈大小确实是 <code>1MB</code>。</p><p>根据以上信息，可以确定 <code>StackLimit</code> 并不是真正的线程栈栈底。那么，栈底位置到底记录在哪里了呢？</p><p>最近在重翻《软件调试》的时候，发现了一个关键函数。</p><h2 id="栈空间自动增长的关键函数"><a href="#栈空间自动增长的关键函数" class="headerlink" title="栈空间自动增长的关键函数"></a>栈空间自动增长的关键函数</h2><p>在第 <code>22</code> 章 <code>22.8.1</code> 节 栈空间的自动增长（<code>P617</code>）中提到了一个关键函数 <code>MiCheckForUserStackOverflow</code>。该函数是判断栈空间能否增长的关键函数。如果知道该函数是如何实现的，就能找到栈底了。</p><p>脑子里很快有了三个选项：<code>google</code> 搜索，<code>ReactOS</code> 和 <code>server03</code> 源码。正好电脑上有源码，不用考虑其它两个选项了。</p><h2 id="参考源码"><a href="#参考源码" class="headerlink" title="参考源码"></a>参考源码</h2><p>知道了函数名，但是还不知道这个函数在哪个文件中实现的。这个简单，在 <code>File Locator</code> 中输入 <code>MiCheckForUserStackOverflow</code>，很快就找到了关键的文件。</p><p><img src="http://resources.bianchengnan.tech/how-to-check-thread-stack-base/search-MiCheckForUserStackOverflow.png" alt="search-MiCheckForUserStackOverflow"></p><p>双击打开 <code>accesschk.c</code>，找到 <code>MiCheckForUserStackOverflow</code>。注释很清晰的解释了这个函数的作用。</p><p><img src="http://resources.bianchengnan.tech/how-to-check-thread-stack-base/MiCheckForUserStackOverflow-description.png" alt="MiCheckForUserStackOverflow-description"></p><blockquote><p><strong>说明：</strong> 该函数的实现在 <code>wrk</code> 中也可以找到，地址是 <a href="https://github.com/mic101/windows/blob/master/WRK-v1.2/base/ntos/mm/acceschk.c。" target="_blank" rel="noopener">https://github.com/mic101/windows/blob/master/WRK-v1.2/base/ntos/mm/acceschk.c。</a></p></blockquote><p>整个函数虽然行数很多，但是有大部分是注释，而且考虑了各种情况。我截取了最关键的部分，如下图：</p><p><img src="http://resources.bianchengnan.tech/how-to-check-thread-stack-base/MiCheckForUserStackOverflow-key-flow.png" alt="MiCheckForUserStackOverflow-key-flow"></p><p>看样子 <code>teb-&gt;DeallocationStack</code> 记录了栈底。 <code>StackBase</code> 减去 <code>teb-&gt;DeallocationStack</code> 的值应该是栈大小（默认是 <code>1MB</code>）。在 <code>windbg</code> 中验证一下。</p><h2 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h2><p>在 <code>windbg</code> 中输入如下命令 <code>dt _teb 0043f000 -y DeallocationStack -y NtTib.StackBase</code>，只查看 <code>DeallocationStack</code> 和 <code>NtTib.StackBase</code> 的值。然后计算差值，发现正好是 <code>1MB</code> （<code>0x100000</code>）。</p><p><img src="http://resources.bianchengnan.tech/how-to-check-thread-stack-base/view-stack-base-and-stack-size.png" alt="view-stack-base-and-stack-size"></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li><p><code>_TEB</code> 结构体的 <code>DeallocationStack</code> 指向线程栈底，而 <code>NtTib.StackLimit</code> 指向的是线程栈当前所到达的最低位置。</p></li><li><p>可以在 <code>dt</code> 命令中通过 <code>-y</code> 选项来显示特定字段。</p></li><li><p><code>vmmap.exe</code> 可以非常详细的展示进程虚拟内存情况。</p></li></ul><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li>《软件调试》第一版 第 <code>22</code> 章</li><li><code>srv03rtm</code> 源码</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;缘起&quot;&gt;&lt;a href=&quot;#缘起&quot; class=&quot;headerlink&quot; title=&quot;缘起&quot;&gt;&lt;/a&gt;缘起&lt;/h2&gt;&lt;p&gt;很早之前，我遇到过几个与栈相关的问题，当时总结过几篇关于线程栈的文章，分别是 &lt;a href=&quot;https://bianchengnan.gitee.io/articles/interesting-exception-0xc00000fd-continue-how-to-increase-stack-size/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;《栈大小可以怎么改？》&lt;/a&gt;、&lt;a href=&quot;https://bianchengnan.gitee.io/articles/stack-variable-usage-optimization-investigation/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;《栈局部变量优化探究，意外发现了 vs 的一个 bug ？》&lt;/a&gt;、&lt;a href=&quot;https://bianchengnan.gitee.io/articles/another-interesting-stackoverflow/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;《栈又溢出了》&lt;/a&gt;、&lt;a href=&quot;https://bianchengnan.gitee.io/articles/interesting-exception-0xc00000fd/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;《有趣的异常》&lt;/a&gt;。在这几篇总结中，简单的总结了栈溢出的原因，设置线程栈大小的方法。但是还有一点没弄清楚：操作系统是怎么知道一个线程的栈大小的？一定记录在某个位置了，否则就不能正确的在栈溢出的时候抛出异常了。不能根据 &lt;code&gt;PE&lt;/code&gt; 头中的字段判断，因为在创建线程的时候可以指定线程栈大小。&lt;code&gt;TEB&lt;/code&gt; 中的 &lt;code&gt;StackLimit&lt;/code&gt; 是真正的栈底吗？带着这些疑问一起来刨根问底吧~&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;友情提示&lt;/strong&gt;：结论在文章末尾。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="调试实战" scheme="https://bianchengnan.github.io/categories/%E8%B0%83%E8%AF%95%E5%AE%9E%E6%88%98/"/>
    
      <category term="工具" scheme="https://bianchengnan.github.io/categories/%E8%B0%83%E8%AF%95%E5%AE%9E%E6%88%98/%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="原" scheme="https://bianchengnan.github.io/tags/%E5%8E%9F/"/>
    
      <category term="总结" scheme="https://bianchengnan.github.io/tags/%E6%80%BB%E7%BB%93/"/>
    
      <category term="调试" scheme="https://bianchengnan.github.io/tags/%E8%B0%83%E8%AF%95/"/>
    
      <category term="windbg" scheme="https://bianchengnan.github.io/tags/windbg/"/>
    
      <category term="转储" scheme="https://bianchengnan.github.io/tags/%E8%BD%AC%E5%82%A8/"/>
    
      <category term="stack" scheme="https://bianchengnan.github.io/tags/stack/"/>
    
      <category term="vmmap" scheme="https://bianchengnan.github.io/tags/vmmap/"/>
    
  </entry>
  
  <entry>
    <title>调试实战 | 记一次有教益的 MFC 程序崩溃分析</title>
    <link href="https://bianchengnan.github.io//articles/troubleshoot-crash-after-tidy-dialog-control-id/"/>
    <id>https://bianchengnan.github.io//articles/troubleshoot-crash-after-tidy-dialog-control-id/</id>
    <published>2023-10-22T03:50:01.000Z</published>
    <updated>2024-05-18T08:56:44.252Z</updated>
    
    <content type="html"><![CDATA[<h2 id="缘起"><a href="#缘起" class="headerlink" title="缘起"></a>缘起</h2><p>实际项目中，<code>resource.h</code> 文件中的控件太多太乱了，合并代码的时候非常痛苦。为了解决这个问题，需要对 <code>resource.h</code> 中的 <code>ID</code> 进行整理。根据之前整理的成果，很快把控件 <code>ID</code> 按对话框分类整理好了。没想到测试的时候遇到了各种崩溃，废了好大劲儿才解决。究其原因，是对 <code>MFC</code> 资源管理机制认识不够深刻。尝试创建某个模块内的对话框的时候，意外地找到了其它模块中的对话框资源。<code>MFC</code> 到底是怎么查找资源模块的呢？应该如何排查这种问题呢？一起来看看吧。</p><a id="more"></a><h2 id="背景介绍"><a href="#背景介绍" class="headerlink" title="背景介绍"></a>背景介绍</h2><p>根据之前的认知，同一个模块中，对话框 <code>ID</code> 不能重复，对话框之间的控件 <code>ID</code> 是可以重复的。因为查找资源的时候是分层查找的，先找到对应的对话框资源，然后在此对话框范围内再查找控件。如果认知没错，那么不同对话框可以使用重复的控件 <code>ID</code> ，也就是说对话框 <code>A</code> 用到的控件 <code>ID</code> 值可以与对话框 <code>B</code> 用到的控件 <code>ID</code> 值一样。以此为依据，我遍历并解析了 <code>.rc</code> 文件中的所有对话框及其控件 <code>ID</code>，并以对话框为组，把每个对话框用到的控件 <code>ID</code> 重新归类。整理后的 <code>resource.h</code> 如下图所示：</p><p><img src="http://resources.bianchengnan.tech/troubleshoot-crash-after-tidy-dialog-control-id/grouped_resource_h.png" alt="grouped_resource_h"></p><p><code>IDD_DIALOG1</code> 和 <code>IDD_DIALOG2</code> 都用到宏名为 <code>IDC_BUTTON1</code> 和 <code>IDC_BUTTON2</code> 的按钮。因为有多个对话框用到了同样的控件名，需要把重复的控件名整理到 <code>IdGroup.Common</code> 组下，<code>IDC_BUTTON3</code> 和 <code>IDC_BUTTON4</code> 的值都被设置为了 <code>20003</code>。整理前，控件 <code>ID</code> 是递增排列的，整理后两个对话框中的控件 <code>ID</code> 值是完全重复的。</p><h2 id="理想很丰满，现实很骨感"><a href="#理想很丰满，现实很骨感" class="headerlink" title="理想很丰满，现实很骨感"></a>理想很丰满，现实很骨感</h2><p>在本地测试通过后，就开始在实际项目中实战了。没想到遇到了各种各样的编译问题。</p><p>比如，<code>.rc</code> 中用了一个控件名，实际代码中用了另外一个名字（使用 <code>vs</code> 修改控件名就会产生名称不同，但是值相同的宏）。</p><p>又比如，代码中用到了 <code>.rc</code> 中没有的控件，<code>GetDlgItem(IDC_NOT_EXISTED)-&gt;ShowWindow(SW_HIDE)</code>，这个肯定是错误，只不过相关的代码已经废弃不用了，所以一直没出问题。</p><blockquote><p><strong>说明：</strong> 因为整理后的 <code>resource.h</code> 中的控件 <code>id</code> 完全是根据 <code>.rc</code> 文件来的，所以会有编译问题。</p></blockquote><p>解决完这些编译问题后，终于可以测试功能是否受影响了。没想到刚开始测试就“翻车”了……</p><h2 id="意外的崩溃"><a href="#意外的崩溃" class="headerlink" title="意外的崩溃"></a>意外的崩溃</h2><p>没想到测试到第 <code>2</code> 个功能的时候就崩溃了。心里咯噔一下。难道之前的认知错了？不管怎么样，需要先把崩溃问题解决掉。先看看是哪里崩溃了，原来是下面的代码导致了崩溃：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GetDlgItem(IDC_BTN_TITLE)-&gt;ShowWindow(SW_HIDE);</span><br></pre></td></tr></table></figure><p>而且从错误提示看，是个内存访问违例，很显然应该是 <code>GetDlgItem(IDC_BTN_TITLE)</code> 没取到对应的控件，返回了 <code>NULL</code>。这让我更虚了，因为这次主要的改动就是整理控件 <code>ID</code>。根据经验，很可能是 <code>IDC_BTN_TITLE</code> 宏的值与生成后的二进制资源没对应上。</p><p>使用 <code>resource hacker</code> 查看编译生成模块中的对话框资源，可以正常解析。又在 <code>vs</code> 中确认了 <code>IDC_BTN_TITLE</code> 的值，跟模块中的结果是匹配的。因为 <code>vs</code> 有时候会出现一些诡异的 <code>bug</code>，我又确认了对应的反汇编代码，确定一切都是正常的。</p><p>难道真的是我之前的认知出现了偏差？于是赶紧又写了一段测试代码，还是没问题。<code>google</code>、<code>bing</code>、<code>baidu</code> 都没搜到有用的资料。</p><p>难道就这样放弃，不处理了？放弃是不可能放弃的。找不到资料，只能自己调试了。</p><h2 id="上调试器"><a href="#上调试器" class="headerlink" title="上调试器"></a>上调试器</h2><p>一般调用某个 <code>API</code> 失败都会有错误码，可以通过 <code>GetLastError()</code> 或者在 <code>vs</code> 的 <code>watch</code> 窗口中输入 <code>$err,hr</code> 查看。</p><p><img src="http://resources.bianchengnan.tech/troubleshoot-crash-after-tidy-dialog-control-id/invalid_window_handle.png" alt="invalid_window_handle"></p><p>从错误提示可知，<strong>无效的窗口句柄</strong>，说明创建对话框的时候就失败了，而不是调用 <code>GetDlgItem(IDC_BTN_TITLE)</code> 在对话框中查找控件的时候才失败。这说得通，因为使用 <code>resource hacker</code> 查看到的资源确实是对的。</p><blockquote><p><strong>说明：</strong> </p><ol><li><p>为了更好的调查问题，我把原代码中的 <code>GetDlgItem(IDC_BTN_TITLE)-&gt;ShowWindow(SW_HIDE);</code> 拆分成了两句 <code>auto title = ::GetDlgItem(m_hWnd, IDC_BTN_TITLE); title-&gt;ShowWindow(SW_HIDE);</code></p></li><li><p><code>GetDlgItem(IDC_BTN_TITLE)</code> 内部会调用 <code>CWnd::FromHandle(::GetDlgItem(m_hWnd, nID));</code>，会导致 <code>LastError</code> 的值被覆盖。如下图：</p><p><img src="http://resources.bianchengnan.tech/troubleshoot-crash-after-tidy-dialog-control-id/failed_but_last_error_success.png" alt="failed_but_last_error_success"></p></li></ol></blockquote><p>但是对话框为什么会创建失败呢？调呗，单步步入对话框创建函数（这里用的是 <code>Create()</code>），发现跟不进去，因为没有对应的调试符号。<code>Create()</code> 失败后，使用<code>$err,hr</code> 或者手动调用 <code>GetLastError()</code> 函数得到的都是 <code>ERROR_SUCCESS</code>，没有任何帮助。到这里真有打退堂鼓的想法了。查也查不到，调也调不了（缺少调试符号，没法调试源码）。</p><blockquote><p><strong>说明：</strong> 当时调试的时候，是在内网环境，无法连接微软的符号服务器。</p></blockquote><h2 id="救星来了"><a href="#救星来了" class="headerlink" title="救星来了"></a>救星来了</h2><p>费了好大劲儿终于把调试符号拷贝到内网环境。但是因为调试符号与内网的 <code>dll</code> 不匹配，<code>vs</code> 又不能像 <code>windbg</code> 那样强制加载不匹配的调试符号。又折腾了半天符号加载的问题，使用 <code>chkmatch</code> 修改调试符号后， <code>vs</code> 还是加载不上。最后无奈，只能使用 <code>windbg</code> 调试了。</p><blockquote><p><strong>说明：</strong> 关于 <code>chkmatch</code> 还有一段故事，后面有机会总结成文，分享给大家</p></blockquote><h2 id="上-windbg"><a href="#上-windbg" class="headerlink" title="上 windbg"></a>上 windbg</h2><p>使用 <code>windbg</code> 附加进程后，加载好对应模块的调试符号并在调用 <code>Create()</code> 函数的地方设置好断点，然后让程序重新运行起来，中断后，单步步入（跟 <code>vs</code> 一样，<code>F11</code>），简单跟踪了一下，没发现异常。<code>::CreateDialogIndirect()</code> 返回 <code>NULL</code>，<code>LastError</code> 的值是 <code>0</code>。后面调试时，发现 <code>hInst</code> 的值有些奇怪，不是预期的模块。<code>hInst</code> 本来应该是 <code>AssemblyDesign_Tools.dll</code>，但是现在却是 <code>PBimsPCDrawing.dll</code>。</p><p><img src="http://resources.bianchengnan.tech/troubleshoot-crash-after-tidy-dialog-control-id/view-hInst-and-find-it-not-right.png" alt="view-hInst-and-find-it-not-right"></p><p>这很不正常！说明在创建对话框的时候，在错误的模块 <code>PBimsPCDrawing.dll</code> 中找到了对应 <code>ID</code> 值的对话框。手动修改 <code>PBimsPCDrawing.dll</code>  中相应的对话框 <code>ID</code> 为其它值，再次编译运行，果然不再崩溃了。</p><p>但是为什么在创建对话框的时候，会到 <code>PBimsPCDrawing.dll</code> 中查找，而不是到预期的  <code>AssemblyDesign_Tools.dll</code> 中查找呢？</p><h2 id="hInst-从哪来"><a href="#hInst-从哪来" class="headerlink" title="hInst 从哪来"></a>hInst 从哪来</h2><p>简单排查后发现 <code>hInst</code> 来自 <code>AfxFindResourceHandle()</code> 的返回值。此函数内部会按照如下顺序查找：</p><ol><li><p>如果 <code>AfxGetModuleState()</code> 不是系统模块（通过 <code>m_bSystem</code> 判断），则调用 <code>AfxGetResourceHandle()</code>，内部又会调用 <code>afxCurrentResourceHandle</code> 宏，展开后是 <code>AfxGetModuleState()-&gt;m_hCurrentResourceHandle</code>。</p></li><li><p>如果步骤 1 没找到的话，会继续到 <code>AfxGetModuleState()-&gt;m_libraryList</code> 列表里的<strong>非系统模块</strong>中查找。</p></li><li><p>如果步骤 2 也没找到的话，会到 <code>AfxGetModuleState()-&gt;m_appLangDll</code> 中找。</p></li><li><p>如果步骤 3 也没找到的话，并且当前是系统模块，会到 <code>AfxGetResourceHandle()</code> 中找。</p></li><li><p>如果步骤 4 也没找到的话，会继续到 <code>AfxGetModuleState()-&gt;m_libraryList</code> 列表里的<strong>系统模块</strong>中查找。</p></li><li><p>如果以上步骤都没找到的话，会直接返回 <code>AfxGetResourceHandle()</code>。</p></li></ol><p>在我们的程序中，在 <code>步骤 2</code> 找到了错误的模块。因为在我们的程序中，会把模块信息添加到 <code>AfxGetModuleState()-&gt;m_libraryList</code> 中，而且 <code>PBimsPCDrawing.dll</code> 在 <code>AssemblyDesign_Tools.dll</code> 前面。</p><blockquote><p><strong>说明：</strong> 根据上述逻辑，只要在创建对话框之前，调用 <code>AfxSetResourceHandle()</code> 把对话框所在的模块设置为当前的资源模块即可保证加载正确的对话框资源。</p></blockquote><h2 id="CDynLinkLibrary"><a href="#CDynLinkLibrary" class="headerlink" title="CDynLinkLibrary"></a>CDynLinkLibrary</h2><p>经过简单代码搜索，发现每个模块都会使用 <code>CDynLinkLibrary</code> 把自己加到 <code>AfxGetModuleState()-&gt;m_libraryList</code> 中。</p><p><code>CDynLinkLibrary</code> 的构造函数会保存传入的 <code>hModule</code>，并把自己加到 <code>m_pModuleState-&gt;m_libraryList</code> 中。</p><p><img src="http://resources.bianchengnan.tech/troubleshoot-crash-after-tidy-dialog-control-id/cdynlinklibrary-constructor.png" alt="cdynlinklibrary-constructor"></p><p>至此，基本弄清了创建对话框失败的原因 —— <code>AfxFindResourceHandle()</code>  返回了错误的模块。</p><p><code>AssemblyDesign_Tools.dll</code> 模块<strong>先</strong>被加载，在其 <code>DllMain()</code> 中把自己加到 <code>AfxGetModuleState()-&gt;m_libraryList</code> 中，然后 <code>PBimsPCDrawing.dll</code> 模块也被加载，也在 <code>DllMain()</code> 中把自己添加到 <code>AfxGetModuleState()-&gt;m_libraryList</code> 中，而且添加到 <code>AssemblyDesign_Tools.dll</code> 模块的前面。当创建 <code>AssemblyDesign_Tools.dll</code> 中的对话框时，如果 <code>PBimsPCDrawing.dll</code> 模块中包含相同 <code>ID</code> 的对话框，那么会加载错误模块中的对话框资源。</p><h2 id="收工？"><a href="#收工？" class="headerlink" title="收工？"></a>收工？</h2><p>本以为到此就可以再水一篇文章了。但是当我在本地按照上述逻辑新建测试工程，准备重现时，发现测试程序能正常创建对话框。调试确认在创建 <code>Dialog1</code> 中的对话框时，<code>AfxFindResourceHandle()</code> 返回的确实是另外一个模块的句柄。</p><p>为什么同样是找到了错误的模块，在测试程序中创建对话框成功了，但是在实际项目中却创建失败了？看来，虽然加载了其它模块的对话框资源，但是创建对话框不一定会失败。难道是其它原因导致的崩溃？</p><h2 id="继续调查"><a href="#继续调查" class="headerlink" title="继续调查"></a>继续调查</h2><p>使用 <code>windbg</code> 附加到进程，中断下来后，执行到创建对话框的关键函数 <code>::CreateDialogIndirect()</code> （实际上是从此函数开始没有源码可跟了）。在此函数开头位置执行 <code>wt</code>，经过漫长的等待，查看统计结果，发现有对 <code>win32u!NtUserCreateWindowEx</code> 的调用。</p><p>在 <code>win32u!NtUserCreateWindowEx()</code> 中设置断点，重新运行程序。中断后，执行 <code>gu</code> 让该函数执行完，然后执行 <code>r</code> 命令查看寄存器，<code>rax</code> 寄存器保存了执行结果。当 <code>rax</code> 的值是 <code>0</code> 时，说明创建窗体失败了。这时候执行 <code>!gle</code> 可知错误码是 <code>0x57f</code>（也就是十进制的 <code>1407</code>）。</p><p><img src="http://resources.bianchengnan.tech/troubleshoot-crash-after-tidy-dialog-control-id/createwindow-return-0-last-error-1407.png" alt="createwindow-return-0-last-error-1407"></p><p>经过查询可知，这个错误码是 <strong>ERROR_CANNOT_FIND_WND_CLASS</strong>，也就是 <strong>找不到窗口类</strong>。居然是窗口类没有注册！要知道一般的控件已经注册过了。遇到窗口类没注册的错误，大概率是使用了自定义控件类。</p><blockquote><p><strong>说明：</strong> 可以使用如下命令在 <code>NtUserCreateWindowEx()</code> 失败时自动中断下来，并显示 <code>LastError</code>。</p><p><code>bp win32u!NtUserCreateWindowEx &quot;bp /1 @$ra \&quot;.if (@rax == 0) {.echo ****; r; !gle } .else {gc;}\&quot;;gc;&quot;</code></p><p><code>@$ra</code> 表示返回地址。<code>bp /1 @$ra</code> 表示在函数返回地址处设置一次性断点。</p></blockquote><h2 id="MFCGridCtrl"><a href="#MFCGridCtrl" class="headerlink" title="MFCGridCtrl"></a>MFCGridCtrl</h2><p>于是赶紧查看 <code>.rc</code> 中对应的对话框内容，发现了一个可疑的控件 —— <code>MFCGridCtrl</code>。</p><p><img src="http://resources.bianchengnan.tech/troubleshoot-crash-after-tidy-dialog-control-id/dialog-custom-control-MFCGridCtrl.png" alt="dialog-custom-control-MFCGridCtrl"></p><p>这个名字太有迷惑性了，乍一看还以为是 <code>MFC</code> 提供的呢。<code>google</code> 之后发现是三方控件，源码可以在 <a href="https://www.codeproject.com/Articles/8/MFC-Grid-control-2-27" target="_blank" rel="noopener">codeproject</a> 上找到。</p><p>下载相应源码并把关键文件添加到项目中，关联好对应的控件后，重新编译运行，这次果然没报错了。</p><h2 id="破案"><a href="#破案" class="headerlink" title="破案"></a>破案</h2><p>至此，这个问题算是水落石出了 —— 实际项目中创建对话框失败是因为对话框中使用了未注册窗口类的控件。创建对话框的时候会依次创建对话框中的控件，在创建这个没注册窗口类的控件时失败了，从而导致整个对话框创建失败。</p><h2 id="这个-bug-这么长寿？"><a href="#这个-bug-这么长寿？" class="headerlink" title="这个 bug 这么长寿？"></a>这个 bug 这么长寿？</h2><p>按理说，这个问题应该很容易被测试出来才对。带着这个疑问，搜索了一下项目代码，发现已经没有代码在使用这个对话框了。所以，实际项目中不会出问题。直到这次意外的 “撞衫”，这个问题才显现出来，有点“坑”。</p><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>后来在折腾符号加载时，发现 <code>chkmatch</code> 修改完的调试符号是可以被 <code>vs</code> 加载的。是我当时手动修改 <code>dll</code> 名字的时候改错了，<code>vs</code> 在加载 <code>mfc140u.dll</code> 的调试符号时，只会查找名字为 <code>mfc140u.amd64.pdb</code> 的调试符号，而我却手动改成了 <code>mfc140u.pdb</code>，所以 <code>vs</code> 加载调试符号失败了。可以在<strong>模块</strong>对话框（可以通过 <code>ctrl + alt + u</code> 打开）中指定的模块上<strong>右键</strong>，<strong>符号加载信息</strong> 查看某个模块对应的符号文件加载信息。</p><p><img src="http://resources.bianchengnan.tech/troubleshoot-crash-after-tidy-dialog-control-id/mfc140u.amd64.pdb.png" alt="mfc140u.amd64.pdb"></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li><p>调试符号对于调试简直太重要了。</p></li><li><p>创建对话框之前，务必确保对话框所在的模块是默认的资源模块，否则可能加载到其它模块中的对话框资源。</p></li><li><p>不同对话框中的控件 <code>ID</code> 可以重复，但是同一个对话框中的控件 <code>ID</code> 不能重复。</p></li><li><p>一般 <code>vs</code> 不能加载不匹配的调试符号，可以使用 <code>chkmatch</code> 修改 <code>pdb</code> 使其与 <code>dll</code> 匹配。</p></li></ul><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://learn.microsoft.com/en-us/windows/win32/debug/system-error-codes--1300-1699-" target="_blank" rel="noopener">https://learn.microsoft.com/en-us/windows/win32/debug/system-error-codes--1300-1699-</a></p><p><a href="https://learn.microsoft.com/en-us/cpp/mfc/reference/afx-extension-module-structure?view=msvc-170" target="_blank" rel="noopener">https://learn.microsoft.com/en-us/cpp/mfc/reference/afx-extension-module-structure?view=msvc-170</a></p><p><a href="https://learn.microsoft.com/en-us/previous-versions/visualstudio/visual-studio-2010/0asx94f7(v=vs.100)" target="_blank" rel="noopener">https://learn.microsoft.com/en-us/previous-versions/visualstudio/visual-studio-2010/0asx94f7(v=vs.100)</a></p><p><a href="https://learn.microsoft.com/en-us/previous-versions/visualstudio/visual-studio-2010/30c674tx(v=vs.100)?redirectedfrom=MSDN" target="_blank" rel="noopener">https://learn.microsoft.com/en-us/previous-versions/visualstudio/visual-studio-2010/30c674tx(v=vs.100)?redirectedfrom=MSDN</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;缘起&quot;&gt;&lt;a href=&quot;#缘起&quot; class=&quot;headerlink&quot; title=&quot;缘起&quot;&gt;&lt;/a&gt;缘起&lt;/h2&gt;&lt;p&gt;实际项目中，&lt;code&gt;resource.h&lt;/code&gt; 文件中的控件太多太乱了，合并代码的时候非常痛苦。为了解决这个问题，需要对 &lt;code&gt;resource.h&lt;/code&gt; 中的 &lt;code&gt;ID&lt;/code&gt; 进行整理。根据之前整理的成果，很快把控件 &lt;code&gt;ID&lt;/code&gt; 按对话框分类整理好了。没想到测试的时候遇到了各种崩溃，废了好大劲儿才解决。究其原因，是对 &lt;code&gt;MFC&lt;/code&gt; 资源管理机制认识不够深刻。尝试创建某个模块内的对话框的时候，意外地找到了其它模块中的对话框资源。&lt;code&gt;MFC&lt;/code&gt; 到底是怎么查找资源模块的呢？应该如何排查这种问题呢？一起来看看吧。&lt;/p&gt;
    
    </summary>
    
      <category term="调试" scheme="https://bianchengnan.github.io/categories/%E8%B0%83%E8%AF%95/"/>
    
    
      <category term="原" scheme="https://bianchengnan.github.io/tags/%E5%8E%9F/"/>
    
      <category term="总结" scheme="https://bianchengnan.github.io/tags/%E6%80%BB%E7%BB%93/"/>
    
      <category term="调试" scheme="https://bianchengnan.github.io/tags/%E8%B0%83%E8%AF%95/"/>
    
      <category term="pdb" scheme="https://bianchengnan.github.io/tags/pdb/"/>
    
      <category term="windbg" scheme="https://bianchengnan.github.io/tags/windbg/"/>
    
      <category term="chkmatch" scheme="https://bianchengnan.github.io/tags/chkmatch/"/>
    
      <category term="mfc" scheme="https://bianchengnan.github.io/tags/mfc/"/>
    
  </entry>
  
  <entry>
    <title>如何查找已注册消息的名称?</title>
    <link href="https://bianchengnan.github.io//articles/how-to-find-registered-message-name/"/>
    <id>https://bianchengnan.github.io//articles/how-to-find-registered-message-name/</id>
    <published>2023-10-22T03:40:01.000Z</published>
    <updated>2024-05-18T08:56:43.919Z</updated>
    
    <content type="html"><![CDATA[<h2 id="TL-DR"><a href="#TL-DR" class="headerlink" title="TL;DR"></a>TL;DR</h2><p>在 <code>Windows</code> 中，通过 <a href="https://learn.microsoft.com/en-us/windows/win32/api/winuser/nf-winuser-registerwindowmessagew" target="_blank" rel="noopener">RegisterWindowMessage()</a> 注册的消息，其消息 <code>ID</code> 在 <code>0xC000 ~ 0xFFFF</code> 之间。可以使用 <a href="https://learn.microsoft.com/en-us/windows/win32/api/winuser/nf-winuser-getclipboardformatnamew" target="_blank" rel="noopener">GetClipboardFormatName()</a> 根据消息 <code>ID</code> 反向查找已注册消息的名称。</p><a id="more"></a><h2 id="缘起"><a href="#缘起" class="headerlink" title="缘起"></a>缘起</h2><p>前一阵子，我在学习 <code>c#</code> 中的 <code>async/await</code> 工作机制时遇到了一个有趣的现象 —— 在下列代码片段中，<code>await</code> 后面的代码是在 <code>UI</code> 线程执行的，不论执行多少次，都是在 <code>UI</code> 线程中执行的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">private async void Button2_Click(object sender, EventArgs e)</span><br><span class="line">&#123;</span><br><span class="line">  Debug.WriteLine(string.Format(&quot;Btn Click Begin(), in thread &#123;0&#125;&quot;, Thread.CurrentThread.ManagedThreadId));</span><br><span class="line">  await Task.Delay(10000);</span><br><span class="line">  Debug.WriteLine(string.Format(&quot;Btn Click End(), in thread &#123;0&#125;&quot;, Thread.CurrentThread.ManagedThreadId));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果把 <code>Button2_Click</code> 中的三行代码放到控制台程序中，<code>await</code> 后面的代码会在哪个线程执行，是不确定的，很有可能与 <code>await</code> 前面的那行代码不在同一个线程中。</p><p><code>await</code> 后面的代码会在哪个线程中执行，情况非常复杂，不在本文讨论范围。</p><p>那么问题来了，为什么 <code>await</code> 后面的代码可以在 <code>UI</code> 线程执行呢？或者说是怎么做到的呢？</p><h2 id="查看调用栈"><a href="#查看调用栈" class="headerlink" title="查看调用栈"></a>查看调用栈</h2><p>通过下图中的调用栈可以猜测，<code>await</code> 后面的代码能在 <code>UI</code> 线程执行是通过消息机制实现的。</p><p><img src="http://resources.bianchengnan.tech/how-to-find-registered-message-name/async-await-msg.png" alt="async-await-msg"></p><p>而且根据上图中调用栈信息可知，这是一个已注册的消息，因为消息 <code>ID</code> 为<code>0xc396</code>，位于<code>0xC000 ~ 0xFFFF</code> 的范围内。根据 <a href="https://learn.microsoft.com/en-us/windows/win32/winmsg/about-messages-and-message-queues#system-defined-messages" target="_blank" rel="noopener">MSDN 文档</a> 可知，这个消息是通过 <code>RegisterWindowMessage()</code> 注册的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">The system returns a message identifier in the range 0xC000 through 0xFFFF when an application calls the RegisterWindowMessage function to register a message. The message identifier returned by this function is guaranteed to be unique throughout the system. Use of this function prevents conflicts that can arise if other applications use the same message identifier for different purposes.</span><br></pre></td></tr></table></figure><p>那么本文的重点来了，这个注册的消息对应的名字是什么？因为数字对我们来说是冰冷的，无意义的，名字才是有意义的。</p><h2 id="注册消息的名字"><a href="#注册消息的名字" class="headerlink" title="注册消息的名字"></a>注册消息的名字</h2><p>在 <code>google</code> 中输入 <code>get registered message name</code>，第一条记录是 <code>stackoverflow</code> 上的一篇<a href="https://stackoverflow.com/questions/40417023/get-name-of-message-registered-by-registerwindowmessage" target="_blank" rel="noopener">文章</a>，里面介绍了可以通过 <a href="https://learn.microsoft.com/en-us/windows/win32/api/winuser/nf-winuser-getclipboardformatnamew" target="_blank" rel="noopener">GetClipboardFormatName()</a> 来根据消息 <code>ID</code> 获取对应的消息名字。这是因为操作系统内部将已注册的消息视为剪贴板格式，并且 <code>GetClipboardFormatName()</code> 函数可以根据特定格式获取名称。</p><h2 id="测试代码"><a href="#测试代码" class="headerlink" title="测试代码"></a>测试代码</h2><p>以下是使用 <code>C#</code> 编写的获取注册消息名称的示例代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">[DllImport(&quot;user32.dll&quot;)]</span><br><span class="line">static extern int GetClipboardFormatName(int format, StringBuilder lpszFormatName, int cchMaxCount);</span><br><span class="line"></span><br><span class="line">public static string GetRegisteredMessageName(int msg)</span><br><span class="line">&#123;</span><br><span class="line">  var sb = new StringBuilder(256);</span><br><span class="line">  GetClipboardFormatName(msg, sb, sb.Capacity);</span><br><span class="line">  return sb.ToString();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static void Main(string[] args)</span><br><span class="line">&#123;</span><br><span class="line">  try</span><br><span class="line">  &#123;</span><br><span class="line">    int msgId = Convert.ToInt32(args[0], 16);</span><br><span class="line">    Console.WriteLine(string.Format(&quot;MsgName: &#123;0&#125;&quot;, GetRegisteredMessageName(msgId)));</span><br><span class="line">  &#125;</span><br><span class="line">  catch (Exception)</span><br><span class="line">  &#123;</span><br><span class="line">    Console.WriteLine(&quot;Usage: GetRegisteredMessageName 0xc001&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>希望本篇文章可以帮助您了解如何查找已注册消息的名称。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><code>await</code> 后面的代码执行在哪个线程中是不确定的，写代码的时候要注意线程相关问题。</p><p>可以使用 <code>GetClipboardFormatName()</code> 获取注册的消息名称。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://stackoverflow.com/questions/40417023/get-name-of-message-registered-by-registerwindowmessage" target="_blank" rel="noopener">https://stackoverflow.com/questions/40417023/get-name-of-message-registered-by-registerwindowmessage</a></p><p><a href="https://linux.m2osw.com/recover-name-message-registered-registerwindowmessage" target="_blank" rel="noopener">https://linux.m2osw.com/recover-name-message-registered-registerwindowmessage</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;TL-DR&quot;&gt;&lt;a href=&quot;#TL-DR&quot; class=&quot;headerlink&quot; title=&quot;TL;DR&quot;&gt;&lt;/a&gt;TL;DR&lt;/h2&gt;&lt;p&gt;在 &lt;code&gt;Windows&lt;/code&gt; 中，通过 &lt;a href=&quot;https://learn.microsoft.com/en-us/windows/win32/api/winuser/nf-winuser-registerwindowmessagew&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;RegisterWindowMessage()&lt;/a&gt; 注册的消息，其消息 &lt;code&gt;ID&lt;/code&gt; 在 &lt;code&gt;0xC000 ~ 0xFFFF&lt;/code&gt; 之间。可以使用 &lt;a href=&quot;https://learn.microsoft.com/en-us/windows/win32/api/winuser/nf-winuser-getclipboardformatnamew&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;GetClipboardFormatName()&lt;/a&gt; 根据消息 &lt;code&gt;ID&lt;/code&gt; 反向查找已注册消息的名称。&lt;/p&gt;
    
    </summary>
    
      <category term="调试" scheme="https://bianchengnan.github.io/categories/%E8%B0%83%E8%AF%95/"/>
    
    
      <category term="原" scheme="https://bianchengnan.github.io/tags/%E5%8E%9F/"/>
    
      <category term="总结" scheme="https://bianchengnan.github.io/tags/%E6%80%BB%E7%BB%93/"/>
    
      <category term="async" scheme="https://bianchengnan.github.io/tags/async/"/>
    
      <category term="await" scheme="https://bianchengnan.github.io/tags/await/"/>
    
      <category term="消息" scheme="https://bianchengnan.github.io/tags/%E6%B6%88%E6%81%AF/"/>
    
      <category term="windows" scheme="https://bianchengnan.github.io/tags/windows/"/>
    
  </entry>
  
  <entry>
    <title>调试实战 | 解决另外一个链接错误</title>
    <link href="https://bianchengnan.github.io//articles/troubleshoot-LNK2001-unresovled-external-symbol-error/"/>
    <id>https://bianchengnan.github.io//articles/troubleshoot-LNK2001-unresovled-external-symbol-error/</id>
    <published>2023-10-22T03:30:01.000Z</published>
    <updated>2024-05-18T08:56:44.276Z</updated>
    
    <content type="html"><![CDATA[<h2 id="缘起"><a href="#缘起" class="headerlink" title="缘起"></a>缘起</h2><p>最近，在加班的过程中遇到一个链接错误 —— <code>fatal error LNK1120: 1 unresolved externals</code>。这种错误是老朋友了，对我这种常年写 <code>bug</code> 的老手来说，完全不是事儿，轻松+愉快。</p><p>根据以下的排查思路基本上能解决大多数链接错误：</p><p>既然报了链接错误，说明编译已经通过了，问题基本出现在库文件上。</p><p>有可能是找不到库文件（缺少库，或者库文件搜索路径不对），可以先确认工程配置是否正确或者使用 <code>/verbose:lib</code> 查看链接过程。</p><p>也可能是库文件不对（没包含对应的导出符号），可以通过 <code>dumpbin /exports error.lib &gt; error.txt</code> 查看 <code>lib</code> 库中的导出符号。按照以上步骤排查基本上可以解决绝大多数链接错误。</p><p>好的，让我们一起来实战一下吧。</p><a id="more"></a><blockquote><p><strong>说明：</strong> 实际项目需要保密，本文的截图是我在本地用测试工程做的。</p></blockquote><h2 id="确保-lib-存在并且路径正确"><a href="#确保-lib-存在并且路径正确" class="headerlink" title="确保 lib 存在并且路径正确"></a>确保 lib 存在并且路径正确</h2><p>通过查看工程设置可以得知，依赖的库文件是 <code>TestLNK1120Dll.lib</code>，附加库目录中也添加了这个 <code>lib</code> 所在的路径。肉眼看上去没问题。为了保险（之前遇到过更诡异的错误，配置看上去都对，但是实际的值不对），还是通过 <code>/verbose:lib</code> 选项看一下链接过程。</p><p>在对应工程上，<code>右键 -&gt; 属性 -&gt; Configuration Property -&gt; Linker -&gt; Command Line</code>，在 <code>Additional Options</code> 下面输入 <code>/verbose:lib</code> 即可。</p><p><img src="http://resources.bianchengnan.tech/troubleshoot-LNK2001-unresovled-external-symbol-error/link-option-verbose-lib.png" alt="link-option-verbose-lib"></p><p>设置好后，重新编译。可以看到链接时整个库查找过程，如下图。</p><p><img src="http://resources.bianchengnan.tech/troubleshoot-LNK2001-unresovled-external-symbol-error/verbose-lib-link-process.png" alt="verbose-lib-link-process"></p><p>至此，可以确定库文件路径配置没错，那大概率是库文件中的符号与程序中的符号不匹配导致的。</p><blockquote><p><strong>说明：</strong> 如果找不到 <code>.lib</code> 文件，报错应该类似下面这样：</p><p><code>fatal error LNK1104: cannot open file &#39;TestLNK1120Dll.lib&#39;</code></p></blockquote><h2 id="查看-lib-文件中的导出符号"><a href="#查看-lib-文件中的导出符号" class="headerlink" title="查看 lib 文件中的导出符号"></a>查看 lib 文件中的导出符号</h2><p>使用 <code>dumpbin</code> 可以查看 <code>lib</code> 库中的所有导出符号，命令如下：</p><p><code>dumpbin /exports d:\test\TestLNK1120.lib &gt; d:\TestLNK1120.txt</code></p><blockquote><p><strong>注意：</strong> 以上命令需要在 <code>dumpbin.exe</code> 所在目录下执行，或者启动 <code>Developer Command Prompt for VS xxx</code>。</p></blockquote><p>然后根据 <code>vs</code> 编译错误提示中的符号在 <code>TestLNK1120.txt</code> 中搜索，应该是没有匹配项目。</p><h2 id="搜索报错的符号"><a href="#搜索报错的符号" class="headerlink" title="搜索报错的符号"></a>搜索报错的符号</h2><p>确实可以在 <code>TestLNK1120.txt</code> 中根据函数名 <code>GetStaticData</code> 搜到相关记录，但是根据完整的符号名称搜不到。</p><p><code>TestLNK1120.txt</code> 文件中与 <code>GetStaticData</code> 相关的内容是：</p><p><code>?GetStaticData@@YAAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ (class std::basic_string&lt;char,struct std::char_traits&lt;char&gt;,class std::allocator&lt;char&gt; &gt; &amp; __cdecl GetStaticData(void))</code></p><p>而 <code>vs</code> 报错提示是：</p><p><code>TestLNK1120.obj : error LNK2001: unresolved external symbol &quot;class std::basic_string&lt;char,struct std::char_traits&lt;char&gt;,class std::allocator&lt;char&gt; &gt; __cdecl GetStaticData(void)&quot; (?GetStaticData@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ)</code></p><p>让我们对比一下这两个结果哪里不一样。</p><h2 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h2><p>别看上面的输出很多很乱，其实我们最需要关心的是经过名字改编的符号名。</p><p><code>vs</code> 中经过名字改编后的符号名是</p><p><code>?GetStaticData@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ</code></p><p><code>lib</code> 库中经过名字改编后的符号名是</p><p><code>?GetStaticData@@YAAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ</code></p><p>如果仔细看，确实能发现这两个输出结果是不一样的，但是经过编译器处理的符号名非常不适合人类阅读。如果能看到函数原型就太好了。</p><p>其实，上面的输出结果既包含了函数原型，又包含了经过名字改编后的符号名。</p><p><code>vs</code> 中的函数名：</p><p><code>class std::basic_string&lt;char,struct std::char_traits&lt;char&gt;,class std::allocator&lt;char&gt; &gt; __cdecl GetStaticData(void)</code></p><p><code>lib</code> 库中的函数名：</p><p><code>class std::basic_string&lt;char,struct std::char_traits&lt;char&gt;,class std::allocator&lt;char&gt; &gt; &amp; __cdecl GetStaticData(void)</code></p><p>可以发现，<code>lib</code> 库中提供的函数的返回值是引用类型的，而 <code>vs</code> 中函数的返回值是不带引用的。</p><p>至此就破案了！</p><h2 id="undname-工具"><a href="#undname-工具" class="headerlink" title="undname 工具"></a>undname 工具</h2><p>如果只有经过名字改编后的符号名，可以通过微软提供的 <code>undname.exe</code> 工具来翻译成人类友好的名称。</p><p><img src="http://resources.bianchengnan.tech/troubleshoot-LNK2001-unresovled-external-symbol-error/compare-undname.png" alt="compare-undname"></p><h2 id="示例工程"><a href="#示例工程" class="headerlink" title="示例工程"></a>示例工程</h2><p>可以到 <a href="https://gitee.com/bianchengnan/my-blog/tree/master/troubleshoot-LNK2001-unresovled-external-symbol-error/TestLnk2001" target="_blank" rel="noopener">gitee</a> 上下载示例工程。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><code>dumpbin.exe</code> 可以查看 <code>lib</code> 库中的符号信息</p><p><code>undname.exe</code> 可以非常方便的查看未经过编译器处理的函数名</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;缘起&quot;&gt;&lt;a href=&quot;#缘起&quot; class=&quot;headerlink&quot; title=&quot;缘起&quot;&gt;&lt;/a&gt;缘起&lt;/h2&gt;&lt;p&gt;最近，在加班的过程中遇到一个链接错误 —— &lt;code&gt;fatal error LNK1120: 1 unresolved externals&lt;/code&gt;。这种错误是老朋友了，对我这种常年写 &lt;code&gt;bug&lt;/code&gt; 的老手来说，完全不是事儿，轻松+愉快。&lt;/p&gt;
&lt;p&gt;根据以下的排查思路基本上能解决大多数链接错误：&lt;/p&gt;
&lt;p&gt;既然报了链接错误，说明编译已经通过了，问题基本出现在库文件上。&lt;/p&gt;
&lt;p&gt;有可能是找不到库文件（缺少库，或者库文件搜索路径不对），可以先确认工程配置是否正确或者使用 &lt;code&gt;/verbose:lib&lt;/code&gt; 查看链接过程。&lt;/p&gt;
&lt;p&gt;也可能是库文件不对（没包含对应的导出符号），可以通过 &lt;code&gt;dumpbin /exports error.lib &amp;gt; error.txt&lt;/code&gt; 查看 &lt;code&gt;lib&lt;/code&gt; 库中的导出符号。按照以上步骤排查基本上可以解决绝大多数链接错误。&lt;/p&gt;
&lt;p&gt;好的，让我们一起来实战一下吧。&lt;/p&gt;
    
    </summary>
    
      <category term="调试" scheme="https://bianchengnan.github.io/categories/%E8%B0%83%E8%AF%95/"/>
    
    
      <category term="原" scheme="https://bianchengnan.github.io/tags/%E5%8E%9F/"/>
    
      <category term="总结" scheme="https://bianchengnan.github.io/tags/%E6%80%BB%E7%BB%93/"/>
    
      <category term="调试" scheme="https://bianchengnan.github.io/tags/%E8%B0%83%E8%AF%95/"/>
    
      <category term="vs" scheme="https://bianchengnan.github.io/tags/vs/"/>
    
      <category term="链接错误" scheme="https://bianchengnan.github.io/tags/%E9%93%BE%E6%8E%A5%E9%94%99%E8%AF%AF/"/>
    
      <category term="LNK" scheme="https://bianchengnan.github.io/tags/LNK/"/>
    
  </entry>
  
  <entry>
    <title>一个 32 位程序的用户空间区域可以有多大？</title>
    <link href="https://bianchengnan.github.io//articles/how-many-virtual-memory-a-32bit-program-can-use/"/>
    <id>https://bianchengnan.github.io//articles/how-many-virtual-memory-a-32bit-program-can-use/</id>
    <published>2023-10-22T03:00:01.000Z</published>
    <updated>2024-05-18T08:56:43.889Z</updated>
    
    <content type="html"><![CDATA[<h2 id="缘起"><a href="#缘起" class="headerlink" title="缘起"></a>缘起</h2><p>我在<a href="https://bianchengnan.gitee.io/articles/analyze-a-crash-dump-and-find-the-root-cause-memory-fragmentation/" target="_blank" rel="noopener">《调试实战 | 记一次有教益的内存碎片转储文件分析》</a>中分析了一个由于内存碎片导致的崩溃转储。发现一个很“奇怪”的现象——程序是 <code>32</code> 位的，但是在查看堆空间大小的时候，居然有将近 <code>4GB</code>。</p><p>相信各位小伙伴儿应该听过下面这种说法：<code>32</code> 位进程有 <code>4GB</code> 的虚拟内存，其中低 <code>2GB</code> 是用户空间，应用程序可以访问，高 <code>2GB</code> 是内核空间，应用程序不能访问，但是内核可以访问。在系统开启 <code>/3GB</code> 的情况下，用户空间可以提升至 <code>3GB</code>，内核空间被压缩到 <code>1GB</code>。</p><p>这也是我学到的关于 <code>32</code> 位进程虚拟内存相关的知识，但是上述描述不够准确。比如，开启了 <code>/3GB</code>，进程用户空间就一定可以提升至 <code>3GB</code> 吗？在 <code>64</code> 位系统上，上述说法还成立吗？</p><p>带着上述疑问，我翻看了微软官方文档，本文尽可能全面的总结进程的虚拟内存空间划分。因为能力有限，本文只涉及 <code>x86/x64</code> 平台，不涉及 <code>ARM</code> 平台。</p><a id="more"></a><blockquote><p> <strong>说明：</strong> 本文总结的限制主要指的是虚拟内存的限制。物理内存与虚拟内存的关系可以简单想象成 <code>1v1</code> 的关系。如果用户空间代码只能访问 <code>2GB</code> 大小的虚拟内存，那么最多访问 <code>2GB</code> 的物理内存，即使机器上装了 <code>16GB</code> 的内存。</p></blockquote><h2 id="32-位程序用户态内存空间的限制"><a href="#32-位程序用户态内存空间的限制" class="headerlink" title="32 位程序用户态内存空间的限制"></a>32 位程序用户态内存空间的限制</h2><p><code>32</code> 位进程用户空间大小受两方面的限制：</p><ol><li>系统级别的限制：是否开启 <code>4GT</code>（<a href="https://docs.microsoft.com/en-us/windows/win32/memory/4-gigabyte-tuning" target="_blank" rel="noopener">4 gigabyte tuning</a>），也就是 <code>/3GB</code> 开关。</li><li>进程本身的限制：是否设置 <code>IMAGE_FILE_LARGE_ADDRESS_AWARE</code> 标志。</li></ol><blockquote><p><strong>说明：</strong> 只有以上两个条件同时满足，在 <code>32</code> 位操作系统上的应用程序用户态虚拟内存空间才可以达到 <code>3GB</code>。</p></blockquote><h2 id="32-位程序在-32-位系统上的情况"><a href="#32-位程序在-32-位系统上的情况" class="headerlink" title="32 位程序在 32 位系统上的情况"></a>32 位程序在 32 位系统上的情况</h2><p>下面的表格总结了各种设置下进程用户空间大小的限制：</p><table><thead><tr><th>虚拟地址范围</th><th>未开启 <code>IMAGE_FILE_LARGE_ADDRESS_AWARE</code></th><th>开启 <code>IMAGE_FILE_LARGE_ADDRESS_AWARE</code></th></tr></thead><tbody><tr><td>未开启 <code>4GT</code></td><td>低 2GB (0x00000000 ~ 0x7FFFFFFF)</td><td>低 2GB (0x00000000 ~ 0x7FFFFFFF)</td></tr><tr><td>开启 <code>4GT</code></td><td>低 2GB (0x00000000 ~ 0x7FFFFFFF)</td><td>低 3GB (0x00000000 ~ 0xBFFFFFFF)</td></tr><tr><td>开启 <code>4GT</code> 并设置 <code>USERVA</code> 为 <code>M</code></td><td>低 2GB (0x00000000 ~ 0x7FFFFFFF)</td><td>低 (0x00000000 ~ <em>M</em>-1)</td></tr></tbody></table><blockquote><p> <strong>说明：</strong> 开启 <code>4GT</code> 的情况下，用户空间上限默认是 <code>3GB</code>，但是可以手动指定一个 <code>2GB~3GB</code> 之间的值作为上限。</p></blockquote><h2 id="32-位程序在-64-位系统上的情况"><a href="#32-位程序在-64-位系统上的情况" class="headerlink" title="32 位程序在 64 位系统上的情况"></a>32 位程序在 64 位系统上的情况</h2><p><code>32</code> 位程序在 <code>64</code> 位系统上的情况比较单一。如果设置了 <code>IMAGE_FILE_LARGE_ADDRESS_AWARE</code> 标志，那么用户空间大小可以达到 <code>4GB</code>，否则只能使用低 <code>2GB</code>。</p><table><thead><tr><th>虚拟地址范围</th><th>未开启 <code>IMAGE_FILE_LARGE_ADDRESS_AWARE</code></th><th>开启 <code>IMAGE_FILE_LARGE_ADDRESS_AWARE</code></th></tr></thead><tbody><tr><td>不论是否开启 <code>4GT</code></td><td>低 2GB (0x00000000 ~ 0x7FFFFFFF)</td><td>4GB (0x00000000 ~ 0xFFFFFFFF)</td></tr></tbody></table><p>上面两个表格的关键内容是我从微软官方文档中摘录的，关于内存和地址空间的更多限制的可以参考下图（同样截自<a href="https://docs.microsoft.com/en-us/windows/win32/memory/memory-limits-for-windows-releases" target="_blank" rel="noopener">微软官方文档</a>）：</p><p><img src="http://resources.bianchengnan.tech/how-many-virtual-memory-a-32bit-program-can-use/memory-and-address-space-limits.png" alt="memory-and-address-space-limits"></p><h2 id="如何开启-4GT"><a href="#如何开启-4GT" class="headerlink" title="如何开启 4GT"></a>如何开启 <code>4GT</code></h2><p>因为 <code>4GT</code> 只对 <code>32</code> 位系统有意义，所以下述设置方法仅针对 <code>32</code> 位系统生效。</p><h3 id="xp-server2003"><a href="#xp-server2003" class="headerlink" title="xp server2003"></a>xp server2003</h3><p>在 <code>xp</code> 或者 <code>server2003</code> 上，可以通过修改 <code>Boot.ini</code> 文件来开启 <code>4GT</code>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[boot loader]</span><br><span class="line">timeout=30</span><br><span class="line">default=multi(0)disk(0)rdisk(0)partition(1)\WINDOWS</span><br><span class="line">[operating systems]</span><br><span class="line">multi(0)disk(0)rdisk(0)partition(1)\WINDOWS=&quot;Server03, Standard&quot; /fastdetect</span><br><span class="line">multi(0)disk(0)rdisk(0)partition(1)\WINDOWS=&quot;Server03, Standard /3GB Enabled&quot; /fastdetect /3GB</span><br><span class="line">multi(0)disk(0)rdisk(0)partition(1)\WINDOWS=&quot;Server03, Standard /3GB Enabled 2.5GB&quot; /fastdetect /3GB /USERVA=2560</span><br></pre></td></tr></table></figure><p>倒数第 <code>2</code> 行表示开启 <code>4GT</code>，并且用户地址空间最大值是默认的 <code>3GB</code>。</p><p>最后一行表示开启 <code>4GT</code>，并且设置用户地址空间的最大地址值为自定义的 <code>2.5GB</code>。</p><h3 id="Vista-及以上"><a href="#Vista-及以上" class="headerlink" title="Vista 及以上"></a>Vista 及以上</h3><p>在 <code>vista</code> 及以上的操作系统上，可以通过 <code>bcdedit</code> 进行设置。我以 <code>win7</code> 为例。</p><p>以<strong>管理员权限</strong>运行 <code>cmd</code>，输入 <code>bcdedit /set increaseuerva target_user_virtual_address_mb</code>。</p><p>比如，如果想设置最大地址值为 <code>2.5GB</code>，则可以输入 <code>bcdedit /set increaseuerva 2560</code>。如果想设置最大地址值为 <code>3GB</code>，则可以输入 <code>bcdedit /set increaseuerva 3072</code>。</p><p>如果不想设置了，可以输入 <code>bcdedit /deletevalue increaseuserva</code>。</p><blockquote><p><strong>说明：</strong>以上设置需要管理员权限，并且重启后生效</p></blockquote><p>介绍完调整系统设置的方法后，我们看看如何设置应用程序。</p><h2 id="如何设置-IMAGE-FILE-LARGE-ADDRESS-AWARE"><a href="#如何设置-IMAGE-FILE-LARGE-ADDRESS-AWARE" class="headerlink" title="如何设置 IMAGE_FILE_LARGE_ADDRESS_AWARE"></a>如何设置 <code>IMAGE_FILE_LARGE_ADDRESS_AWARE</code></h2><p>如果有源码，可以直接调整 <code>vs</code> 的工程设置。</p><p>在工程文件上右键，属性，打开工程属性设置对话框。找到 <code>Configuration Property -&gt; Linker -&gt; System</code> 选项，设置 <code>Enable Large Addresess</code> 的值为 <code>Yes</code>。如下图：</p><p><img src="http://resources.bianchengnan.tech/how-many-virtual-memory-a-32bit-program-can-use/enable-large-address-aware-flag.png" alt="enable-large-address-aware-flag"></p><p>当然，也可以直接在 <code>Linker</code> 下的 <code>Command Line</code> 中手动加上 <code>/LARGEADDRESSAWARE</code> 选项。效果是一样的。</p><p><img src="http://resources.bianchengnan.tech/how-many-virtual-memory-a-32bit-program-can-use/manually-set-large-address-aware-option.png" alt="manually-set-large-address-aware-option"></p><p>通过以上设置，可以为新编译出来的程序设置 <code>Large Address Aware</code> 标志。</p><p>如果没有源码，或者程序已经生成了，该如何修改呢？直接修改 <code>PE</code> 文件中对应的标志位即可。下图是我使用 <code>CFF Explorer</code> 修改应用程序的 <code>Large Address Aware</code> 标志的截图。</p><p><img src="http://resources.bianchengnan.tech/how-many-virtual-memory-a-32bit-program-can-use/manually-modify-pe-header-to-support-large-address.png" alt="manually-modify-pe-header-to-support-large-address"></p><h2 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h2><p>为了加深自己的印象，也为了验证参考资料的准确性，我特意写了一个非常简单的程序，该程序可以获取到用户态内存最高地址。代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"stdafx.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"windows.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">ToGb</span><span class="params">(<span class="keyword">size_t</span> bytes)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> bytes / <span class="number">1024.0</span> / <span class="number">1024.0</span> / <span class="number">1024.0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> _tmain(<span class="keyword">int</span> argc, _TCHAR* argv[])</span><br><span class="line">&#123;</span><br><span class="line">  LPVOID result = VirtualAllocEx(GetCurrentProcess(), (LPVOID)<span class="number">0</span>, <span class="number">0x1000</span>, MEM_RESERVE | MEM_TOP_DOWN, PAGE_READWRITE);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"highest address : %0x, about %.3lfGB\r\n"</span>, result, ToGb((<span class="keyword">size_t</span>)result));</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>相关的测试工程已经上传到了 <a href="https://gitee.com/bianchengnan/my-blog/tree/master/how-many-virtual-memory-a-32bit-program-can-use/FindLargestUserAddress" target="_blank" rel="noopener">gitee</a>，有需要的小伙伴儿可以自行下载。</p><h3 id="验证-32-位程序在-32-位系统下的运行效果"><a href="#验证-32-位程序在-32-位系统下的运行效果" class="headerlink" title="验证 32 位程序在 32 位系统下的运行效果"></a>验证 <code>32</code> 位程序在 <code>32</code> 位系统下的运行效果</h3><p>第一张图是未开启 <code>4GT</code> 的运行结果：</p><p><img src="http://resources.bianchengnan.tech/how-many-virtual-memory-a-32bit-program-can-use/highest-available-address-4gt-disabled-32-bit-system.png" alt="highest-available-address-4gt-disabled-32-bit-system"></p><p>第二张图是开启 <code>4GT</code> 并且使用默认值（<code>3GB</code>）的的运行结果：</p><p><img src="http://resources.bianchengnan.tech/how-many-virtual-memory-a-32bit-program-can-use/highest-available-address-4gt-enabled-32-bit-system.png" alt="highest-available-address-4gt-enabled-32-bit-system"></p><p>第三张图是开启 <code>4GT</code> 并且指定 <code>/USERVA</code> 大小为 <code>2.5GB</code> 的运行结果：</p><p><img src="http://resources.bianchengnan.tech/how-many-virtual-memory-a-32bit-program-can-use/highest-available-address-4gt-enabled-userva-2.5gb-32-bit-system.png" alt="highest-available-address-4gt-enabled-userva-2.5gb-32-bit-system"></p><h3 id="验证-32-位程序在-64-位系统下的运行效果"><a href="#验证-32-位程序在-64-位系统下的运行效果" class="headerlink" title="验证 32 位程序在 64 位系统下的运行效果"></a>验证 <code>32</code> 位程序在 <code>64</code> 位系统下的运行效果</h3><p>我直接在我的 <code>win10</code> 系统中运行了，结果如下：</p><p><img src="http://resources.bianchengnan.tech/how-many-virtual-memory-a-32bit-program-can-use/highest-available-address-on-64bit-system.png" alt="highest-available-address-on-64bit-system"></p><p>从以上输出结果可知，微软的文档没有骗我们。</p><h2 id="PAE"><a href="#PAE" class="headerlink" title="PAE"></a>PAE</h2><p>除了 <code>/3GB</code>，各位小伙伴儿可能还听过一个叫 <code>PAE</code> 的东东，全称是 <a href="https://docs.microsoft.com/en-us/windows/win32/memory/physical-address-extension" target="_blank" rel="noopener">Physical Address Extension</a>，直译过来就是物理地址扩展。从名字可以看出是跟物理地址有关的。</p><p>我认为 <code>PAE</code> 解决的最重要的一个问题是，让 <code>32</code> 位操作系统可以使用更多的物理内存。假设，一台装有 <code>16GB</code> 的物理内存的机器上，装了 <code>32</code> 位的 <code>windows</code> 操作系统，在没开启 <code>PAE</code> 情况下，只能使用低 <code>4GB</code> 的物理内存，无法使用高 <code>12GB</code> 的物理内存。如果开启了 <code>PAE</code>，那么这 <code>16GB</code> 都可以使用。</p><p>我目前理解这个选项是通过控制分页模式来达到访问更多物理内存的效果的。如果不开启 <code>PAE</code>，那么将使用 <code>10-10-12</code> 分页，开启 <code>PAE</code> 后，会使用 <code>2-9-9-12</code> 分页。关于分页模式，强烈推荐大家听一听海哥的内核课程。</p><h3 id="开启或关闭-PAE"><a href="#开启或关闭-PAE" class="headerlink" title="开启或关闭 PAE"></a>开启或关闭 PAE</h3><p>在 <code>xp</code> 或者 <code>server2003</code> 上，可以通过修改 <code>Boot.ini</code> 文件来开启或关闭 <code>PAE</code>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">; 开启 PAE</span><br><span class="line">multi(0)disk(0)rdisk(0)partition(1)\WINDOWS=&quot;Server03, Standard&quot; /fastdetect /PAE</span><br><span class="line"></span><br><span class="line">; 关闭 PAE</span><br><span class="line">multi(0)disk(0)rdisk(0)partition(1)\WINDOWS=&quot;Server03, Standard&quot; /fastdetect /NOPAE</span><br></pre></td></tr></table></figure><p>在 <code>vista</code> 及以上的操作系统上，可以通过 <code>bcdedit /set</code> 命令来开启或关闭 <code>PAE</code>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">; 开启 PAE</span><br><span class="line">bcdedit /set [&#123;ID&#125;] pae ForceEnable</span><br><span class="line"></span><br><span class="line">; 关闭 PAE（开启 DEP 的时候不能关闭 PAE，必须同时关闭 DEP）</span><br><span class="line">bcdedit /set [&#123;ID&#125;] nx AlwaysOff</span><br><span class="line">bcdedit /set [&#123;ID&#125;] pae ForceDisable</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>应用程序开启了 <code>Large Address Aware</code> 标志后可以访问更大的虚拟内存空间。如果可能，一定要开启！</p><p>可以在 <code>vs</code> 工程中通过 <code>/LargeAddressAware</code> 选项开启，也可以直接修改 <code>PE</code> 文件中对应的标志位进行修改。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://docs.microsoft.com/en-us/windows/win32/memory/virtual-address-space" target="_blank" rel="noopener">https://docs.microsoft.com/en-us/windows/win32/memory/virtual-address-space</a></li><li><a href="https://docs.microsoft.com/en-us/windows/win32/memory/4-gigabyte-tuning" target="_blank" rel="noopener">https://docs.microsoft.com/en-us/windows/win32/memory/4-gigabyte-tuning</a></li><li><a href="https://docs.microsoft.com/en-us/windows/win32/memory/physical-address-extension" target="_blank" rel="noopener">https://docs.microsoft.com/en-us/windows/win32/memory/physical-address-extension</a></li><li><a href="https://docs.microsoft.com/en-us/windows/win32/memory/memory-limits-for-windows-releases" target="_blank" rel="noopener">https://docs.microsoft.com/en-us/windows/win32/memory/memory-limits-for-windows-releases</a></li><li><a href="https://docs.microsoft.com/en-us/windows-hardware/drivers/devtest/bcdedit--set" target="_blank" rel="noopener">https://docs.microsoft.com/en-us/windows-hardware/drivers/devtest/bcdedit--set</a></li><li><a href="https://docs.microsoft.com/en-us/windows-hardware/drivers/devtest/boot-parameters-to-configure-dep-and-pae" target="_blank" rel="noopener">https://docs.microsoft.com/en-us/windows-hardware/drivers/devtest/boot-parameters-to-configure-dep-and-pae</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;缘起&quot;&gt;&lt;a href=&quot;#缘起&quot; class=&quot;headerlink&quot; title=&quot;缘起&quot;&gt;&lt;/a&gt;缘起&lt;/h2&gt;&lt;p&gt;我在&lt;a href=&quot;https://bianchengnan.gitee.io/articles/analyze-a-crash-dump-and-find-the-root-cause-memory-fragmentation/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;《调试实战 | 记一次有教益的内存碎片转储文件分析》&lt;/a&gt;中分析了一个由于内存碎片导致的崩溃转储。发现一个很“奇怪”的现象——程序是 &lt;code&gt;32&lt;/code&gt; 位的，但是在查看堆空间大小的时候，居然有将近 &lt;code&gt;4GB&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;相信各位小伙伴儿应该听过下面这种说法：&lt;code&gt;32&lt;/code&gt; 位进程有 &lt;code&gt;4GB&lt;/code&gt; 的虚拟内存，其中低 &lt;code&gt;2GB&lt;/code&gt; 是用户空间，应用程序可以访问，高 &lt;code&gt;2GB&lt;/code&gt; 是内核空间，应用程序不能访问，但是内核可以访问。在系统开启 &lt;code&gt;/3GB&lt;/code&gt; 的情况下，用户空间可以提升至 &lt;code&gt;3GB&lt;/code&gt;，内核空间被压缩到 &lt;code&gt;1GB&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;这也是我学到的关于 &lt;code&gt;32&lt;/code&gt; 位进程虚拟内存相关的知识，但是上述描述不够准确。比如，开启了 &lt;code&gt;/3GB&lt;/code&gt;，进程用户空间就一定可以提升至 &lt;code&gt;3GB&lt;/code&gt; 吗？在 &lt;code&gt;64&lt;/code&gt; 位系统上，上述说法还成立吗？&lt;/p&gt;
&lt;p&gt;带着上述疑问，我翻看了微软官方文档，本文尽可能全面的总结进程的虚拟内存空间划分。因为能力有限，本文只涉及 &lt;code&gt;x86/x64&lt;/code&gt; 平台，不涉及 &lt;code&gt;ARM&lt;/code&gt; 平台。&lt;/p&gt;
    
    </summary>
    
      <category term="调试" scheme="https://bianchengnan.github.io/categories/%E8%B0%83%E8%AF%95/"/>
    
    
      <category term="原" scheme="https://bianchengnan.github.io/tags/%E5%8E%9F/"/>
    
      <category term="总结" scheme="https://bianchengnan.github.io/tags/%E6%80%BB%E7%BB%93/"/>
    
      <category term="调试" scheme="https://bianchengnan.github.io/tags/%E8%B0%83%E8%AF%95/"/>
    
      <category term="wow64" scheme="https://bianchengnan.github.io/tags/wow64/"/>
    
      <category term="x64" scheme="https://bianchengnan.github.io/tags/x64/"/>
    
      <category term="虚拟内存" scheme="https://bianchengnan.github.io/tags/%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/"/>
    
      <category term="x86" scheme="https://bianchengnan.github.io/tags/x86/"/>
    
  </entry>
  
  <entry>
    <title>调试实战 | 调试一个由内存分配失败导致的崩溃</title>
    <link href="https://bianchengnan.github.io//articles/debug-another-memory-allocation-failed-crash/"/>
    <id>https://bianchengnan.github.io//articles/debug-another-memory-allocation-failed-crash/</id>
    <published>2023-10-17T10:50:42.000Z</published>
    <updated>2024-05-18T08:56:43.703Z</updated>
    
    <content type="html"><![CDATA[<h2 id="缘起"><a href="#缘起" class="headerlink" title="缘起"></a>缘起</h2><p>前一阵子，朋友开发的 <code>QT</code> 程序遇到了一个崩溃问题，抓了 <code>dump</code> 。我跟着一起分析的。最后发现是由于内存分配失败导致的。</p><p>一起来练习一下排查思路吧。</p><a id="more"></a><blockquote><p><strong>说明：</strong> 本文很早就写好了草稿，一直没整理成文，Finally~</p></blockquote><h2 id="万能的-analyze-v"><a href="#万能的-analyze-v" class="headerlink" title="万能的 !analyze -v"></a>万能的 !analyze -v</h2><p>拿到转储文件，第一件事就是点击 <code>!analyze -v</code> 超链接，让 <code>windbg</code> 帮忙自动分析。</p><p><img src="http://resources.bianchengnan.tech/debug-another-memory-allocation-failed-crash/analyze-v.png" alt="analyze-v"></p><p>从输出结果中的 <code>Qt5Core!qBadAlloc+0x1a</code> 可以猜测是内存分配失败导致的问题。</p><h2 id="分配了多大内存？"><a href="#分配了多大内存？" class="headerlink" title="分配了多大内存？"></a>分配了多大内存？</h2><p>加载好符号文件，输入 <code>k</code> 命令查看调用栈。</p><p><img src="http://resources.bianchengnan.tech/debug-another-memory-allocation-failed-crash/view-callstack.png" alt="view-callstack"></p><p>显示的调用栈，需要使用 <code>!analyze -v</code> 分析结果中的 <code>.cxr 0x59cba8</code> 切换上下文，然后再执行 <code>k</code> 命令即可查看到有意义的调用栈了。</p><p><img src="http://resources.bianchengnan.tech/debug-another-memory-allocation-failed-crash/view-meaningful-callstack.png" alt="view-meaningful-callstack"></p><p>查看栈帧 <code>03</code> 对应的代码，可以发现是在通过 <code>file-&gt;readAll()</code> 读取整个文件的内容。</p><p><img src="http://resources.bianchengnan.tech/debug-another-memory-allocation-failed-crash/view-frame-03.png" alt="view-frame-03"></p><p>根据代码逻辑及函数局部变量的值，可以确定要读取的文件大小大概是 <code>288.6MB</code>。</p><h2 id="空闲空间够大吗？"><a href="#空闲空间够大吗？" class="headerlink" title="空闲空间够大吗？"></a>空闲空间够大吗？</h2><p>相比于之前分析空闲内存空间是否足够的办法（感兴趣的小伙伴儿可以点击 <a href="https://bianchengnan.gitee.io/articles/analyze-a-crash-dump-and-find-the-root-cause-memory-fragmentation/" target="_blank" rel="noopener">这里</a> 查看），我们可以使用更高级的命令进行查找。命令如下：</p><p><code>!address -f:Free -c:&quot;.if ( %3 &gt;= 0n302630400) {.echo %1 %2 %3}&quot;</code></p><p>执行后可以发现，输出结果是空，如果减小 <code>0n302630400</code> 为 <code>0n102630400</code>，可以发现有两条记录。说明命令是有效的，而且进程中已经没有一块空闲地址空间可以满足本次分配请求。</p><p><img src="http://resources.bianchengnan.tech/debug-another-memory-allocation-failed-crash/search-free-region-larger-than-0n302630400.png" alt="search-free-region-larger-than-0n302630400"></p><h2 id="更进一步"><a href="#更进一步" class="headerlink" title="更进一步"></a>更进一步</h2><p>如果使用 <code>!address -summary</code> 查看地址空间情况，可以发现空闲空间大小是 <code>1.025GB</code>，占整个内存空间的 <code>51.24%</code>。说明当前程序是一个 <code>32</code> 位的程序。</p><p><img src="http://resources.bianchengnan.tech/debug-another-memory-allocation-failed-crash/address-summary.png" alt="address-summary"></p><p>使用 <code>!dh client</code> 查看 <code>client</code> 模块的 <code>PE</code> 文件头信息，可以发现确实是 32 位程序，而且没有开启 <code>Large Address Aware</code> 标志。</p><p><img src="http://resources.bianchengnan.tech/debug-another-memory-allocation-failed-crash/view-pe-header-with-dh.png" alt="view-pe-header-with-dh"></p><h2 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h2><ol><li><p>不要一次性读取全部文件到内存中</p><p>这样修改后，可以处理非常大的文件。但是需要修改代码逻辑，相对复杂。</p></li><li><p>修改程序为 <code>64</code> 位</p><p>非常简单，只需要重新编译即可。</p></li><li><p>设置 <code>Large Address Aware</code> 标志</p><p>用户内存空间可以达到 <code>3GB</code>，可以在一定程度上避免内存分配失败的问题。<img src="http://resources.bianchengnan.tech/debug-another-memory-allocation-failed-crash/set-large-address-aware-in-vs.png" alt="set-large-address-aware-in-vs"></p></li></ol><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本次排查相对顺利，解决也比较简单，虽然简单，还是有一些收获的。</p><ul><li><p>可以在 <code>windbg</code> 中使用 <code>!address -f:Free -c:&quot;.if ( %3 &gt;= mem_size) {.echo %1 %2 %3}&quot;</code> 快速查找大于 <code>mem_size</code> 的空闲空间。</p></li><li><p>可以在 <code>windbg</code> 中使用 <code>!dh</code> 命令查看 <code>PE</code> 文件头信息。可以快速确定一些关键信息，比如模块是 <code>32</code> 位的还是 <code>64</code> 位的，是否开启 <code>Large Address Aware</code> 标志等。</p></li><li><p>如果可以尽量使用 <code>64</code> 位程序，如果必须使用 <code>32</code> 位程序，至少也要开启 <code>Large Address Aware</code> 标志。</p><p>可以通过工程属性页中的 <code>链接器 -&gt; 系统 -&gt; 启用大地址</code> 进行开启。</p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;缘起&quot;&gt;&lt;a href=&quot;#缘起&quot; class=&quot;headerlink&quot; title=&quot;缘起&quot;&gt;&lt;/a&gt;缘起&lt;/h2&gt;&lt;p&gt;前一阵子，朋友开发的 &lt;code&gt;QT&lt;/code&gt; 程序遇到了一个崩溃问题，抓了 &lt;code&gt;dump&lt;/code&gt; 。我跟着一起分析的。最后发现是由于内存分配失败导致的。&lt;/p&gt;
&lt;p&gt;一起来练习一下排查思路吧。&lt;/p&gt;
    
    </summary>
    
      <category term="调试" scheme="https://bianchengnan.github.io/categories/%E8%B0%83%E8%AF%95/"/>
    
    
      <category term="原" scheme="https://bianchengnan.github.io/tags/%E5%8E%9F/"/>
    
      <category term="调试" scheme="https://bianchengnan.github.io/tags/%E8%B0%83%E8%AF%95/"/>
    
      <category term="dump" scheme="https://bianchengnan.github.io/tags/dump/"/>
    
      <category term="windbg" scheme="https://bianchengnan.github.io/tags/windbg/"/>
    
      <category term="转储" scheme="https://bianchengnan.github.io/tags/%E8%BD%AC%E5%82%A8/"/>
    
      <category term="内存碎片" scheme="https://bianchengnan.github.io/tags/%E5%86%85%E5%AD%98%E7%A2%8E%E7%89%87/"/>
    
  </entry>
  
  <entry>
    <title>调试实战 | 记一次有教益的 vs2022 内存分配失败崩溃分析（续）</title>
    <link href="https://bianchengnan.github.io//articles/crazy-vs2022-allocate-memory-failed-part2/"/>
    <id>https://bianchengnan.github.io//articles/crazy-vs2022-allocate-memory-failed-part2/</id>
    <published>2023-10-15T22:50:42.000Z</published>
    <updated>2024-05-18T08:56:43.696Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>前一阵子遇到了 <code>vs2022</code> 卡死的问题，在上一篇<a href="https://bianchengnan.gitee.io/articles/crazy-vs2022-allocate-memory-failed-part1/" target="_blank" rel="noopener">文章</a>中重点分析了崩溃的原因 —— 当 <code>vs2022</code> 尝试分配 <code>923MB</code> 的内存时，物理内存+页文件大小不足以满足这次分配请求，于是抛出异常。</p><p>本篇文章将重点挖掘一下 <code>vs2022</code> 在崩溃之前已经分配的内容。</p><blockquote><p><strong>说明：</strong> 本文很早就写了草稿，一直没时间整理发布，Finally~</p></blockquote><a id="more"></a><p>还是先从调用栈入手，找到关键参数，然后查看参数内容。</p><h2 id="查找-vector-对象地址"><a href="#查找-vector-对象地址" class="headerlink" title="查找 vector 对象地址"></a>查找 vector 对象地址</h2><p>栈帧 <code>0b</code> 对应的函数是 <code>std::vector&lt;T&gt;::_Emplace_reallocate()</code>，栈帧 <code>0c</code> 会调用这个函数。根据调用约定可知，调用类成员函数时，<code>rcx</code> 会指向类对象，在这里 <code>rcx</code> 会指向 <code>std::vector&lt;std::shared_ptr&lt;std::stringstream&gt;&gt;</code> 类型的实例。可以通过查看栈帧 <code>0c</code> 的反汇编代码确定 <code>rcx</code> 的来源。</p><p><img src="http://resources.bianchengnan.tech/crazy-vs2022-allocate-memory-failed-part2/view-vector-instance-from-stackframe-0c.png" alt="view-vector-instance-from-stackframe-0c"></p><p>从图中可知，<code>rcx</code> 的值来自 <code>rbp-0x70</code>。那 <code>rbp</code> 的值是多少呢？使用 <code>uf</code> 查看 <code>vcpkg!code_store::a_store::a_thread_impl::append_code_item_name()</code> 函数的反汇编代码。</p><p><img src="http://resources.bianchengnan.tech/crazy-vs2022-allocate-memory-failed-part2/view-rbp-in-frame-0c.png" alt="view-rbp-in-frame-0c"></p><p>由上图可知，先把 <code>rsp-0x920</code> 赋值给  <code>rbp</code>，然后 <code>rsp</code> 会减小 <code>0xa20</code>。所以可以通过 <code>rsp+0xa20-0x920</code> 计算出对应的 <code>rbp</code> 的值，再减去 <code>0x70</code> 即可得到 <code>rcx</code> 的值。由此可知 <code>vector</code> 对象的地址是 <code>0x000000b1 6547e5d0</code>。</p><p><img src="http://resources.bianchengnan.tech/crazy-vs2022-allocate-memory-failed-part2/view-rbp-rcx-in-frame-0c.png" alt="view-rbp-rcx-in-frame-0c"></p><h2 id="查看-vector-内容"><a href="#查看-vector-内容" class="headerlink" title="查看 vector 内容"></a>查看 vector 内容</h2><p>查阅 <code>vs</code> 提供的 <code>STL</code> 源码可知，<code>vector</code> 对象起始偏移 <code>0</code> 的位置存储了第一个元素的地址，起始偏移 <code>8</code> （<code>64</code>位程序）的位置存储了最后一个元素后面的地址。可以查看 <code>vector</code> 中前 <code>20</code> 个元素。</p><p><img src="http://resources.bianchengnan.tech/crazy-vs2022-allocate-memory-failed-part2/view-vector-front-20-data.png" alt="view-vector-front-20-data"></p><p>由调用栈可知，<code>vector</code> 中的元素类型是 <code>shared_ptr&lt;stringstream&gt;</code>。根据源码可知，<code>shared_ptr&lt;T&gt;</code> 类型的大小是 <code>16</code> 字节，偏移 <code>0</code> 的位置存储了对象的地址，偏移 <code>8</code> 的位置存储了引用计数对象的地址。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">Ty</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">shared_ptr</span> :</span> <span class="keyword">public</span> _Ptr_base&lt;_Ty&gt; &#123; <span class="comment">// class for reference counted resource management</span></span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">Ty</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> _<span class="title">Ptr_base</span> &#123;</span> <span class="comment">// base class for shared_ptr and weak_ptr</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    element_type* _Ptr;</span><br><span class="line">    _Ref_count_base* _Rep;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="vector-中有多少个元素"><a href="#vector-中有多少个元素" class="headerlink" title="vector 中有多少个元素"></a>vector 中有多少个元素</h2><p>大家应该都知道，<code>vector</code> 中的元素是顺序存储的，知道了起始地址及结束地址，也知道每个元素的大小，可以很容易计算出 <code>vector</code> 中的元素数量。</p><p>在 <code>windbg</code> 中输入 <code>? (000001c2434b7170-000001c21ccdd060) / 0n16</code> 可以得到元素个数 <code>40360465</code>。</p><p>根据上次分析的结果可知，分配的元素数量是<code>60540697</code>。 通过查看 <code>vs</code> 提供的源码可知，容器扩容时会按 <code>1.5</code> 倍进行扩容。</p><p>来验证以一下是否符合这个规律。在 <code>windbg</code> 中输入 <code>? 0n40360465 + 0n40360465 / 2</code> 可以得到结果 <code>60540697</code>。</p><p><img src="http://resources.bianchengnan.tech/crazy-vs2022-allocate-memory-failed-part2/view-vector-size.png" alt="view-vector-size"></p><p>可见，当时 <code>vs</code> 在调用类似 <code>push_back()</code> 之类的方法向容器中增加元素，但是容器正好满了，触发了扩容操作。由此也可以验证之前的分析是正确的。</p><h2 id="验证引用计数对象数据"><a href="#验证引用计数对象数据" class="headerlink" title="验证引用计数对象数据"></a>验证引用计数对象数据</h2><p>拿第一个元素进行验证，实际对象的地址是 <code>000001be 580056f0</code>，引用计数对象的地址是 <code>000001be 580056e0</code>。先验证引用计数对象是否正确。</p><p><code>_Ref_count_base</code> 结构如下图所示：</p><p><img src="http://resources.bianchengnan.tech/crazy-vs2022-allocate-memory-failed-part2/view-_Ref_count_base_detail.png" alt="view-_Ref_count_base_detail"></p><blockquote><p><strong>说明：</strong> <code>devenv</code> 加载的模块所对应的调试符号已经去除了 <code>Type</code> 信息，没办法通过 <code>dt</code> 显示类型信息。上图是我用 <code>windbg</code> 调试新建的测试工程时的截图。</p></blockquote><p>从下图可知，引用计数相关数据是完美匹配的。</p><p><img src="http://resources.bianchengnan.tech/crazy-vs2022-allocate-memory-failed-part2/verify-reference-count-object.png" alt="verify-reference-count-object"></p><p>一般 <code>shared_ptr&lt;T&gt;</code> 的引用计数和实际的数据是没有关系的，比如下面的代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>* p = <span class="keyword">new</span> <span class="keyword">int</span>();</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;<span class="keyword">int</span>&gt; sp(p);</span><br></pre></td></tr></table></figure><p><img src="http://resources.bianchengnan.tech/crazy-vs2022-allocate-memory-failed-part2/view_normal_shared_ptr.png" alt="view_normal_shared_ptr"></p><p><code>sp._Ptr</code> 的值是 <code>0x017b9450</code>，<code>sp._Rep</code> 的地址是 <code>0x017b9640</code>，两者之间没有明显关系。</p><p>但是，如果你观察的比较仔细，可以发现一个非常有趣的现象 ——  <code>vector</code> 中的每个元素（智能指针）的引用计数对象的地址 <code>+0x10</code> 正好等于实际对象的地址。</p><p>以第一个元素为例，引用计数对象的地址是 <code>000001be 580056e0</code>，实际对象的地址是 <code>000001be 580056f0</code>，两者正好相差了 <code>0x10</code>。</p><p>这是怎么回事呢？如果你对 <code>stl</code> 比较熟悉，可能已经想到了 <code>std::make_shared()</code>，<code>vector</code> 中存储的对象都是通过 <code>std::make_shared()</code> 创建出来的。</p><h2 id="make-shared"><a href="#make-shared" class="headerlink" title="make_shared"></a>make_shared</h2><p>我摘录了 <code>vs</code> 中提供的源码</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">Ty</span>, <span class="title">class</span>... _<span class="title">Types</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">shared_ptr</span>&lt;_Ty&gt; <span class="title">make_shared</span>(_<span class="title">Types</span>&amp;&amp;... _<span class="title">Args</span>) &#123;</span> <span class="comment">// make a shared_ptr to non-array object</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">auto</span> _Rx = <span class="keyword">new</span> _Ref_count_obj2&lt;_Ty&gt;(_STD forward&lt;_Types&gt;(_Args)...);</span><br><span class="line">    <span class="built_in">shared_ptr</span>&lt;_Ty&gt; _Ret;</span><br><span class="line">    _Ret._Set_ptr_rep_and_enable_shared(_STD addressof(_Rx-&gt;_Storage._Value), _Rx);</span><br><span class="line">    <span class="keyword">return</span> _Ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意代码中 <code>_Ret._Set_ptr_rep_and_enable_shared()</code> 第一个参数的值是 <code>_Rx-&gt;_Storage._Value</code> 的地址。</p><p><code>_Rx</code> 的类型是 <code>_Ref_count_obj2&lt;_Ty&gt;*</code>，<code>_Ref_count_obj2</code> 继承自 <code>_Ref_count_base</code>。而  <code>_Ref_count_base</code> 的大小是 <code>16</code> 字节:虚表指针 <code>8</code> 字节，两个引用计数各占 <code>4</code> 字节，一共 <code>16</code> 字节。</p><p>大概的内存结构图如下：</p><p><img src="http://resources.bianchengnan.tech/crazy-vs2022-allocate-memory-failed-part2/make_shared_relation.png" alt="make_shared_relation"></p><p>务必注意 <code>_Ref_count_obj2</code> 中的 <code>_Storage</code> 存储了整个目标对象，而不是指针。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li><p><code>procdump</code> 真是事后调试的好帮手。以管理员权限运行 <code>procdump -i -ma d:\dumps\</code> 即可安装。<code>-i</code> 表示安装（如果要卸载，可以使用 <code>-u</code> 参数）。<code>-ma</code> 表示执行完整转储，<code>d:\dumps\</code> 表示 <code>.dmp</code> 文件保存的位置。</p></li><li><p>相较于 <code>32</code> 位进程的 <code>4GB</code> （<code>2</code> 的 <code>32</code> 次方）虚拟内存空间而言， <code>64</code> 位进程的虚拟内存空间超级大，目前是  <code>256TB</code>（总共 <code>64</code> 位，目前只用了 <code>48</code> 位），内核态和用户态平均分，用户态可以使用一半，也就是 <code>128TB</code>。</p></li><li><p>如果使用 <code>malloc()</code> 或者 <code>new()</code> （内部会调用 <code>malloc()</code>）分配的内存大小超出堆阈值，那么内部会使用 <code>NtAllocateVirtualMemory()</code> 分配内存，而且 <code>AllocationType</code> 的值是 <code>MEM_COMMIT</code>。分配 <code>MEM_COMMIT</code> 类型的内存是受<strong>物理内存+分页文件大小</strong>限制的。</p></li></ul><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><code>vs</code> 源码</li><li><a href="https://learn.microsoft.com/en-us/openspecs/windows_protocols/ms-erref/596a1078-e883-4972-9bbc-49e60bebca55" target="_blank" rel="noopener">NTSTATUS Values</a> </li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;前一阵子遇到了 &lt;code&gt;vs2022&lt;/code&gt; 卡死的问题，在上一篇&lt;a href=&quot;https://bianchengnan.gitee.io/articles/crazy-vs2022-allocate-memory-failed-part1/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;文章&lt;/a&gt;中重点分析了崩溃的原因 —— 当 &lt;code&gt;vs2022&lt;/code&gt; 尝试分配 &lt;code&gt;923MB&lt;/code&gt; 的内存时，物理内存+页文件大小不足以满足这次分配请求，于是抛出异常。&lt;/p&gt;
&lt;p&gt;本篇文章将重点挖掘一下 &lt;code&gt;vs2022&lt;/code&gt; 在崩溃之前已经分配的内容。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;说明：&lt;/strong&gt; 本文很早就写了草稿，一直没时间整理发布，Finally~&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="调试" scheme="https://bianchengnan.github.io/categories/%E8%B0%83%E8%AF%95/"/>
    
    
      <category term="原" scheme="https://bianchengnan.github.io/tags/%E5%8E%9F/"/>
    
      <category term="调试" scheme="https://bianchengnan.github.io/tags/%E8%B0%83%E8%AF%95/"/>
    
      <category term="dump" scheme="https://bianchengnan.github.io/tags/dump/"/>
    
      <category term="转储" scheme="https://bianchengnan.github.io/tags/%E8%BD%AC%E5%82%A8/"/>
    
      <category term="vs2022" scheme="https://bianchengnan.github.io/tags/vs2022/"/>
    
      <category term="part2" scheme="https://bianchengnan.github.io/tags/part2/"/>
    
  </entry>
  
  <entry>
    <title>调试实战 | 记一次有教益的 vs2022 内存分配失败崩溃分析</title>
    <link href="https://bianchengnan.github.io//articles/crazy-vs2022-allocate-memory-failed-part1/"/>
    <id>https://bianchengnan.github.io//articles/crazy-vs2022-allocate-memory-failed-part1/</id>
    <published>2023-10-15T09:25:42.000Z</published>
    <updated>2024-05-18T08:56:43.686Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>之前一直以为 <code>64</code> 位进程很难出现内存分配异常，因为 <code>64</code> 位进程的虚拟内存空间非常大（总共 <code>64</code> 位，目前只用了 <code>48</code> 位，也就是 <code>256TB</code>，用户态可以使用一半，也就是 <code>128TB</code>）。没想到，前一阵子居然遇到了 <code>vs2022</code>（ <code>vs</code> 终于有了 <code>64</code> 位的版本）分配内存失败的情况。分析到最后是因为分配 <code>MEM_COMMIT</code> 类型的内存失败导致的异常。一起来看看吧。</p><blockquote><p><strong>说明：</strong> 本文很早就写了草稿，一直没时间整理发布，Finally~</p></blockquote><a id="more"></a><h2 id="vs2022-卡死了"><a href="#vs2022-卡死了" class="headerlink" title="vs2022 卡死了"></a>vs2022 卡死了</h2><p>前一阵子，我在使用 <code>vs2022</code> 编辑代码的时候，不知道做了什么操作导致 <code>vs2022</code> 卡住了。过了一段时间后，<code>procdump</code> 自动运行起来了（因为我把 <code>procdump</code> 设置为了 <code>JIT</code> 调试器。当有进程崩溃的时候，<code>procdump</code> 会自动执行转储操作），等了好一会儿才退出。查看 <code>d:\dumps\</code> 目录下的转储文件，真是不看不知道，一看吓一跳，对应的转储文件居然有将近 <code>20GB</code>。</p><p><img src="http://resources.bianchengnan.tech/crazy-vs2022-allocate-memory-failed-part1/vs2022-dump-file.png" alt="vs2022-dump-file"></p><p>看来，<code>vs2022</code> 应该是遇到了内存方面的异常。</p><h2 id="查看调用栈"><a href="#查看调用栈" class="headerlink" title="查看调用栈"></a>查看调用栈</h2><p>使用 <code>windbg</code> 打开对应的转储文件，执行 <code>k</code> 查看调用栈。如下图：</p><p><img src="http://resources.bianchengnan.tech/crazy-vs2022-allocate-memory-failed-part1/callstack-of-new-memory-throw-exception.png" alt="callstack-of-new-memory-throw-exception"></p><p>可以很明显的看到是在调用 <code>new()</code> 分配内存失败后抛出了异常。再多查看几个栈帧，可以发现是由 <code>vector</code> 的 <code>_Emplace_reallocate()</code> 函数触发的内存分配。<code>vs2022</code> 是 <code>64</code> 位的进程，虚拟内存空间可以说是大的离谱。居然内存分配会失败！有点意思，那到底分配了多大内存呢？</p><h2 id="分配了多大内存？"><a href="#分配了多大内存？" class="headerlink" title="分配了多大内存？"></a>分配了多大内存？</h2><p> 查看栈帧 <code>0a</code> 和 <code>0b</code> 的反汇编代码，如下图：</p><p><img src="http://resources.bianchengnan.tech/crazy-vs2022-allocate-memory-failed-part1/search-new-size.png" alt="search-new-size"></p><p>从上图可知，<code>new()</code> 的参数 <code>rcx</code> 来自栈帧 <code>0a</code> 中的 <code>rax</code>，<code>rax</code> 又来自 <code>rcx+0x27</code>。<code>rcx</code> 来自栈帧 <code>0b</code> 中的 <code>rax</code>，<code>rax</code> 是 <code>vcpkg!std::_Get_size_of_n&lt;16&gt;()</code> 的返回值，<code>vcpkg!std::_Get_size_of_n&lt;16&gt;()</code> 的参数 <code>rcx</code> 来自 <code>rax</code>，而这个 <code>rax</code> 保存到栈上 <code>rsp+0x78</code> 的位置。可以先拿到  <code>rsp+0x78</code> 处的值，然后一步步推导出传递给 <code>new()</code> 的参数。</p><p>在开始之前，先了解一下 <code>vcpkg!std::_Get_size_of_n&lt;size_t&gt;()</code> 的逻辑。<code>vcpkg!std::_Get_size_of_n&lt;size_t&gt;()</code> 是一个模板函数，模板参数是元素类型的大小，这里是 <code>0n16</code>。该函数的实现很简单，就是返回 <code>_Count * _Ty_size</code> （当然还有一些界限检查，下面是精简后的代码）。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">size_t</span> _Ty_size&gt;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="keyword">size_t</span> _Get_size_of_n(<span class="keyword">const</span> <span class="keyword">size_t</span> _Count) &#123;</span><br><span class="line">    <span class="keyword">return</span> _Count * _Ty_size;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以通过查看栈帧 <code>0b</code> <code>rsp+0x78</code> 位置的值得到要分配的元素个数，然后乘以 <code>0n16</code> 就可以得到最终传递给 <code>new()</code> 的值。</p><p><img src="http://resources.bianchengnan.tech/crazy-vs2022-allocate-memory-failed-part1/get-allocate-size-pass-to-new.png" alt="get-allocate-size-pass-to-new"></p><p>计算后得知，本次分配的空间大约为 <code>923MB</code> 。</p><blockquote><p><strong>注意：</strong> 虽然分配的内存空间不是超级大，但是本次尝试分配的元素个数是 <code>0x039bc719</code>，通过 <code>.formats 0x039bc719</code> 可以查看对应的十进制数是 <code>60540697</code>，也就是大约 <code>6</code> 千万个对象！</p></blockquote><p>说实话，分析到这里的时候，我是有点儿没底气的。<code>vs2022</code> 可是 <code>64</code> 位的进程啊！没想到只分配大概 <code>923MB</code> 就失败了！带着这个疑问，继续查看当前进程的地址空间情况。</p><h2 id="查看空闲空间"><a href="#查看空闲空间" class="headerlink" title="查看空闲空间"></a>查看空闲空间</h2><p>可以使用 <code>!address -summary</code> 看一下内存使用情况，如下图：</p><p><img src="http://resources.bianchengnan.tech/crazy-vs2022-allocate-memory-failed-part1/address-summary.png" alt="address-summary"></p><p>可以发现最大的空闲空间大概有 <code>119.96TB</code> 这么大。</p><blockquote><p><strong>说明：</strong> 既可以通过上面的 <code>Largest Region by Usage</code> 查看最大的空闲空间，还可以通过 <code>!address -f:Free -c:&quot;.if(%3 &gt; 0x80000000) {.echo %1 %2 %3}&quot;</code> 显示出大于 <code>0x80000000</code> 的空闲段，如下图：</p><p><img src="http://resources.bianchengnan.tech/crazy-vs2022-allocate-memory-failed-part1/get-address-region-larger-than-0x80000000.png" alt="get-address-region-larger-than-0x80000000"></p><p>顺便说一句，第一次执行的时候是真的慢！</p></blockquote><p>既然有足够大的空闲空间，为什么分配内存还会失败呢？看到这里我更疑惑了，同时心里有了另外一个疑问—— 在 <code>x64</code> 进程中，用户态代码到底可以分配多大内存？</p><h2 id="测试内存分配"><a href="#测试内存分配" class="headerlink" title="测试内存分配"></a>测试内存分配</h2><p>于是我写了一段使用 <code>malloc</code> 分配内存的测试代码。如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">size_t</span> size = <span class="number">1024</span> * <span class="number">1024</span> * <span class="number">1024</span>;</span><br><span class="line">    size *= <span class="number">20</span>;</span><br><span class="line">    <span class="keyword">auto</span> p = <span class="built_in">malloc</span>(size);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>经过几次调整后发现，大概分配 <code>20GB</code> 的时候就失败了。</p><p>当使用 <code>malloc()</code> 分配大块内存时，会调用 <code>ntdll!NtAllocateVirtualMemory()</code> 进行分配。使用 <code>windbg</code> 运行程序，当执行到 <code>auto p = malloc(size);</code> 这一行的时候，执行 <code>bp ntdll!NtAllocateVirtualMemory</code> 设置好断点。然后执行 <code>g</code> 让程序继续运行，很快就中断下来了。执行 <code>gu</code> 跳出当前函数，使用 <code>r</code> 命令查看寄存器，主要关注 <code>rax</code>，因为它保存了函数的返回值。发现 <code>rax</code> 的值是 <code>00000000c000012d</code>。由 <code>ntdll!NtAllocateVirtualMemory()</code> 的函数原型可知，返回值是 <code>NTSTATUS</code> 类型的。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">NTSTATUS <span class="title">NtAllocateVirtualMemory</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  [in]      HANDLE    ProcessHandle,</span></span></span><br><span class="line"><span class="function"><span class="params">  [in, out] PVOID     *BaseAddress,</span></span></span><br><span class="line"><span class="function"><span class="params">  [in]      ULONG_PTR ZeroBits,</span></span></span><br><span class="line"><span class="function"><span class="params">  [in, out] PSIZE_T   RegionSize,</span></span></span><br><span class="line"><span class="function"><span class="params">  [in]      ULONG     AllocationType,</span></span></span><br><span class="line"><span class="function"><span class="params">  [in]      ULONG     Protect</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br></pre></td></tr></table></figure><p>查看官方文档可知，<code>0xc000012d</code> 的意义是 <code>STATUS_COMMITMENT_LIMIT</code>。</p><p><img src="http://resources.bianchengnan.tech/crazy-vs2022-allocate-memory-failed-part1/c000012d_status_commitment_limit.png" alt="c000012d_status_commitment_limit"></p><p>根据 <code>Description</code> 列的描述可知，增大页面文件的大小可能会有帮助。看到这里的时候，我突然想起来，好像 <code>malloc()</code> 在调用<code>ntdll!NtAllocateVirtualMemory()</code> 的时候，传递的 <code>AllocationType</code> 应该是包含 <code>MEM_COMMIT</code> 标志的（因为可以直接对返回的地址空间进行读写操作了）。而分配这种类型的内存，<code>windows</code> 会检查是否有足够的内存（物理内存+页文件）支撑，如果剩余的物理内存+页文件（会被系统中的所有进程共同使用）的大小不能满足本次分配，那么会报错。</p><p> 如果把 <code>MEM_COMMIT</code> 换成 <code>MEM_RESERVE</code>，能分配多大的内存呢？</p><h2 id="测试-MEM-RESERVE-最大分配尺寸"><a href="#测试-MEM-RESERVE-最大分配尺寸" class="headerlink" title="测试 MEM_RESERVE 最大分配尺寸"></a>测试 MEM_RESERVE 最大分配尺寸</h2><p>于是我又写了一段测试代码，直接调用 <code>VirtualAlloc()</code> 进行内存分配。测试代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"windows.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">size_t</span> one_gb = <span class="number">1L</span>L * <span class="number">1024L</span>L * <span class="number">1024L</span>L * <span class="number">1024L</span>L; <span class="comment">// 1 GB</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">ToGb</span><span class="params">(<span class="keyword">size_t</span> bytes)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> bytes / <span class="number">1024.0</span> / <span class="number">1024.0</span> / <span class="number">1024.0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">ToTb</span><span class="params">(<span class="keyword">size_t</span> bytes)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> bytes / <span class="number">1024.0</span> / <span class="number">1024.0</span> / <span class="number">1024.0</span> / <span class="number">1024.0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">size_t</span> TestMaxAllocateMemory(<span class="keyword">size_t</span> init_size, <span class="keyword">size_t</span> decrease_size, DWORD allocation_type)</span><br><span class="line">&#123;</span><br><span class="line">    LPVOID p = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">nullptr</span> == (p = VirtualAlloc(<span class="literal">nullptr</span>, init_size, allocation_type, PAGE_READWRITE)))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">auto</span> last_error = GetLastError();</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"allocate "</span> &lt;&lt; ToGb(init_size) &lt;&lt; <span class="string">" GB failed. last error:"</span> &lt;&lt; last_error</span><br><span class="line">            &lt;&lt; <span class="string">". try allocate "</span> &lt;&lt; ToGb(init_size - decrease_size) &lt;&lt; <span class="string">" GB."</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">        init_size -= decrease_size;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> init_size;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TestMaxReserveMemory</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">size_t</span> size_reserve = <span class="number">128L</span>L * <span class="number">1024L</span>L * one_gb;  <span class="comment">// 128 TB</span></span><br><span class="line">    size_reserve = TestMaxAllocateMemory(size_reserve, one_gb, MEM_RESERVE);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"allocate "</span> &lt;&lt; ToTb(size_reserve) &lt;&lt; <span class="string">" TB reserver memory success."</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    TestMaxReserveMemory();</span><br><span class="line">    <span class="built_in">std</span>::getchar();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果如下：</p><p><img src="http://resources.bianchengnan.tech/crazy-vs2022-allocate-memory-failed-part1/test-max-reserve-memory.png" alt="test-max-reserve-memory"></p><p>当分配类型是 <code>MEM_RESERVE</code> 的时候，一次性最多可以分配大概 <code>126 TB</code> 的虚拟内存。基本符合之前的认知。</p><blockquote><p><strong>注意：</strong> 每次运行结果不完全一致，不过相差不多。</p></blockquote><h2 id="测试-MEM-COMMIT-最大分配尺寸"><a href="#测试-MEM-COMMIT-最大分配尺寸" class="headerlink" title="测试 MEM_COMMIT 最大分配尺寸"></a>测试 MEM_COMMIT 最大分配尺寸</h2><p>为了更好的展示不同情况下分配 <code>MEM_COMMIT</code> 的结果，我又添加如下测试代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TestMaxCommitMemory</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">size_t</span> size_commit = <span class="number">128L</span>L * one_gb; <span class="comment">// 128 GB</span></span><br><span class="line">    size_commit = TestMaxAllocateMemory(size_commit, one_gb, MEM_COMMIT);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"allocate "</span> &lt;&lt; ToGb(size_commit) &lt;&lt; <span class="string">" GB commit memory success."</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//TestMaxReserveMemory();</span></span><br><span class="line">    TestMaxCommitMemory();</span><br><span class="line">    <span class="built_in">std</span>::getchar();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我分别在不同系统内存占用的情况下运行了三次，三次运行结果如下：</p><p>当系统内存相对充裕的时候，运行结果如下：</p><p><img src="http://resources.bianchengnan.tech/crazy-vs2022-allocate-memory-failed-part1/allocate-memory-commit-1.png" alt="allocate-memory-commit-1"></p><p>当系统内存被消耗了一部分的时候，运行结果如下：</p><p><img src="http://resources.bianchengnan.tech/crazy-vs2022-allocate-memory-failed-part1/allocate-memory-commit-2.png" alt="allocate-memory-commit-1"></p><p>当使用 <code>TestLimit64 -m 2048 -c 10</code> 分配 <code>20GB</code> 的 <code>MEM_COMMIT</code> 内存后，运行结果如下：</p><p><img src="http://resources.bianchengnan.tech/crazy-vs2022-allocate-memory-failed-part1/allocate-memory-commit-3.png" alt="allocate-memory-commit-1"></p><blockquote><p><strong>画外音：</strong> 当我尝试模拟系统内存吃紧的时候，突然想起来 <code>Testlimit</code>  就是用来测试各种资源极限的。<code>-m</code> 模拟的是分配 <code>MEM_COMMIT</code> 类型内存的，<code>-r</code> 模拟的是分配 <code>MEM_RESERVER</code> 类型内存的。<code>-c</code> 是分配数量，如果不指定，则无限分配。</p></blockquote><p>现在还剩下两个问题待证实：</p><ol><li>明确 <code>malloc()</code> 调用 <code>ntdll!NtAllocateVirtualMemory()</code>  传递的 <code>AllocationType</code> 参数。</li><li>确定分配失败时，剩余物理内存+页文件的大小是否足够大。</li></ol><h2 id="明确-AllocationType"><a href="#明确-AllocationType" class="headerlink" title="明确 AllocationType"></a>明确 AllocationType</h2><p>使用 <code>k 3</code> 显示 <code>3</code> 个调用栈帧。栈帧 <code>01</code> 会调用 <code>ntdll!NtAllocateVirtualMemory()</code>，所以栈帧 <code>01</code> 会传递参数给<code>ntdll!NtAllocateVirtualMemory()</code>。使用 <code>ub 00007ffe30492762 L1a</code> 查看相关调用代码，可以发现 <code>AllocationType</code> 保存在 <code>rsp+0x20</code> 的位置，<code>Protect</code> 保存在 <code>rsp+0x28</code> 的位置，前四个参数分别由 <code>rcx, rdx, r8, r9</code> 进行传递。</p><p><img src="http://resources.bianchengnan.tech/crazy-vs2022-allocate-memory-failed-part1/view-AllocationType-param.png" alt="view-AllocationType-param"></p><p>由此，可以确定之前的理解是正确的。 <code>malloc()</code> 调用 <code>ntdll!NtAllocateVirtualMemory()</code> 时，<code>AllocationType</code> 的值是 <code>MEM_COMMIT</code>。</p><h2 id="剩余的内存是否足够大"><a href="#剩余的内存是否足够大" class="headerlink" title="剩余的内存是否足够大"></a>剩余的内存是否足够大</h2><p>因为转储文件只包含当前进程的信息，没有系统级的转储文件，不好确认系统中的其它进程的内存使用情况。但是转储文件的大小已经达到了 <code>18.3GB</code>，本次尝试分配的大小是 <code>923MB</code>，加上 <code>18.3GB</code>，大概是 <code>19GB</code>。</p><p>通过 <code>.time</code> 命令，可以发现系统已经运行了接近 <code>2</code> 天，当前进程已经运行了大概 <code>18.5</code> 个小时。由系统开机时间可以推算，当时应该有不少进程在运行（我的系统上，<code>chrome</code> 和 <code>firefox</code> 基本是常开状态）。</p><p><img src="http://resources.bianchengnan.tech/crazy-vs2022-allocate-memory-failed-part1/show-system-and-process-running-time.png" alt="show-system-and-process-running-time"></p><p>而且在 <code>vs2022</code> 无响应的时候，整个系统确实有些卡顿。以上种种迹象表明，系统当时的内存吃紧。这时候出现内存分配异常，确实合情合理。</p><h2 id="彩蛋"><a href="#彩蛋" class="headerlink" title="彩蛋"></a>彩蛋</h2><p>前几天，客户的程序也遇到了一个类似的问题。她机器上内存紧张的时候，执行程序中的一个功能需要分配 <code>196MB</code> 的内存，由于物理内存不足，失败了。因为我之前已经调查过类似的问题了，在调查客户的问题的时候，非常快速而且有信心。我想这就是写文章记录的价值之一吧！</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li><code>procdump</code> 真是事后调试的好帮手。以管理员权限运行 <code>procdump -i -ma d:\dumps\</code> 即可安装。<code>-i</code> 表示安装（如果要卸载，可以使用 <code>-u</code> 参数）。<code>-ma</code> 表示执行完整转储，<code>d:\dumps\</code> 表示 <code>.dmp</code> 文件保存的位置。</li></ul><ul><li>相较于 <code>32</code> 位进程的 <code>4GB</code> （<code>2</code> 的 <code>32</code> 次方）虚拟内存空间而言， <code>64</code> 位进程的虚拟内存空间超级大，目前是  <code>256TB</code>（总共 <code>64</code> 位，目前只用了 <code>48</code> 位），内核态和用户态平均分，用户态可以使用一半，也就是 <code>128TB</code>。</li></ul><ul><li>如果使用 <code>malloc()</code> 或者 <code>new()</code> （内部会调用 <code>malloc()</code>）分配的内存大小超出堆阈值，那么内部会使用 <code>NtAllocateVirtualMemory()</code> 分配内存，而且 <code>AllocationType</code> 的值是 <code>MEM_COMMIT</code>。分配 <code>MEM_COMMIT</code> 类型的内存是受<strong>物理内存+分页文件大小</strong>限制的。</li></ul><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p>NTSTATUS Values</p><p><a href="https://learn.microsoft.com/en-us/openspecs/windows_protocols/ms-erref/596a1078-e883-4972-9bbc-49e60bebca55" target="_blank" rel="noopener">https://learn.microsoft.com/en-us/openspecs/windows_protocols/ms-erref/596a1078-e883-4972-9bbc-49e60bebca55</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;之前一直以为 &lt;code&gt;64&lt;/code&gt; 位进程很难出现内存分配异常，因为 &lt;code&gt;64&lt;/code&gt; 位进程的虚拟内存空间非常大（总共 &lt;code&gt;64&lt;/code&gt; 位，目前只用了 &lt;code&gt;48&lt;/code&gt; 位，也就是 &lt;code&gt;256TB&lt;/code&gt;，用户态可以使用一半，也就是 &lt;code&gt;128TB&lt;/code&gt;）。没想到，前一阵子居然遇到了 &lt;code&gt;vs2022&lt;/code&gt;（ &lt;code&gt;vs&lt;/code&gt; 终于有了 &lt;code&gt;64&lt;/code&gt; 位的版本）分配内存失败的情况。分析到最后是因为分配 &lt;code&gt;MEM_COMMIT&lt;/code&gt; 类型的内存失败导致的异常。一起来看看吧。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;说明：&lt;/strong&gt; 本文很早就写了草稿，一直没时间整理发布，Finally~&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="调试" scheme="https://bianchengnan.github.io/categories/%E8%B0%83%E8%AF%95/"/>
    
    
      <category term="原" scheme="https://bianchengnan.github.io/tags/%E5%8E%9F/"/>
    
      <category term="调试" scheme="https://bianchengnan.github.io/tags/%E8%B0%83%E8%AF%95/"/>
    
      <category term="dump" scheme="https://bianchengnan.github.io/tags/dump/"/>
    
      <category term="转储" scheme="https://bianchengnan.github.io/tags/%E8%BD%AC%E5%82%A8/"/>
    
      <category term="vs2022" scheme="https://bianchengnan.github.io/tags/vs2022/"/>
    
  </entry>
  
  <entry>
    <title>如何判断转储文件是在 32 位系统还是 64 位系统下生成的？</title>
    <link href="https://bianchengnan.github.io//articles/how-to-tell-a-process-dump-was-generated-on-x64-or-x86-machine/"/>
    <id>https://bianchengnan.github.io//articles/how-to-tell-a-process-dump-was-generated-on-x64-or-x86-machine/</id>
    <published>2023-10-15T07:51:42.000Z</published>
    <updated>2024-05-18T08:56:43.932Z</updated>
    
    <content type="html"><![CDATA[<h2 id="缘起"><a href="#缘起" class="headerlink" title="缘起"></a>缘起</h2><p>曾经在 <code>2022</code> 年分析过一个崩溃转储，文章在<a href="https://bianchengnan.gitee.io/articles/analyze-a-crash-dump-and-find-the-root-cause-memory-fragmentation/" target="_blank" rel="noopener">这里</a>。在那个案例中，堆空间大小将近 <code>4GB</code>。根据上次的结论，这应该是一个运行在 <code>64</code> 位系统下的 <code>32</code> 位进程崩溃产生的转储文件。这让我有了一个疑问？怎么从进程转储文件中得知进程是 <code>32</code> 位的还是 <code>64</code> 位的？如果是 <code>32</code> 位进程，怎么判断是运行在 <code>32</code> 位系统上还是运行在 <code>64</code> 位系统上呢？</p><a id="more"></a><blockquote><p><strong>说明：</strong> <code>64</code> 位进程只能运行在 <code>64</code> 位系统下，不能运行在 <code>32</code> 位系统下。如果进程是 <code>64</code> 位的，那么系统一定是 <code>64</code> 位的。</p></blockquote><h2 id="判断进程位数"><a href="#判断进程位数" class="headerlink" title="判断进程位数"></a>判断进程位数</h2><p>判断进程是 <code>32</code> 位进程还是 <code>64</code> 位进程比较简单。通过很多地方都可以判断。</p><ol><li><p>根据寄存器进行判断。</p><p>运行在 <code>32</code> 位系统上的进程，并没有用到 <code>gs</code> 寄存器，<code>gs</code> 的值一般为 <code>0</code>。</p><p>如果 <code>gs</code> 的值不是 <code>0</code>，说明是 <code>32</code> 位进程运行在 <code>64</code> 位系统上或者是 <code>64</code> 位进程运行在 <code>64</code> 位系统上。</p><p>具体是 <code>32</code> 位进程还是 <code>64</code> 位进程，可以通过 <code>r</code> 命令查看寄存器进行判断，如果是 <code>32</code> 位寄存器（<code>Exx</code>），说明是 <code>32</code> 位进程。如果是 <code>64</code> 位寄存器（<code>Rxx</code>），说明是 <code>64</code> 位进程。</p></li><li><p>使用 <code>!dh</code> 命令查看模块的文件头信息，如果显示了 <code>14C machine (i386)</code> 或者 <code>characteristic</code> 下显示了 <code>32 bit word machine</code> 说明是 <code>32</code> 位进程。如果显示了 <code>8664 machine (X64)</code> 说明是 <code>64</code> 位进程。</p><blockquote><p><strong>说明：</strong> <code>!dh</code> 的输出很长，可以用如下命令过滤 <code>.shell -ci &quot;!dh -f module_name&quot; findstr &quot;machine&quot;</code>。</p></blockquote></li></ol><p><img src="http://resources.bianchengnan.tech/how-to-tell-a-process-dump-was-generated-on-x64-or-x86-machine/compare-32-64-bit-process.png" alt="compare-32-64-bit-process"></p><ol start="3"><li><p>使用 <code>lm</code> 命令查看模块，如果模块中有 <code>wow64cpu, wow64win, wow64</code> 中的一个，说明是 <code>32</code> 位进程运行在 <code>64</code> 位系统下。</p><p>如果不包含，或者是 <code>32</code> 位进程运行在 <code>32</code> 位系统上，或者是 <code>64</code> 位进程运行在 <code>64</code> 位系统上。具体是哪种情况，可以通过查看寄存器位数进行判断。</p></li></ol><blockquote><p><strong>说明：</strong> 如果是 <code>32</code> 位进程运行在 <code>64</code> 位系统上， <code>4</code> 和 <code>5</code> 有可能不准确。</p></blockquote><h2 id="判断系统位数"><a href="#判断系统位数" class="headerlink" title="判断系统位数"></a>判断系统位数</h2><p>如果进程是 <code>64</code> 位的，其运行的系统一定是 <code>64</code> 位的。如果进程是 <code>32</code> 位的，其运行的系统可能是 <code>32</code> 位的，也可能是 <code>64</code> 位的。如果进程是 <code>32</code> 位的，有可能运行在 <code>32</code> 位系统上，也有可能运行在 <code>64</code> 位系统上。接下来只关心 <code>32</code> 位进程是否运行在 <code>64</code> 位系统上的情况。</p><ol><li><p>通过 <code>!peb</code> 命令查看环境变量进行判断</p><p>如果环境变量名包含 <code>PROCESSOR_ARCHITEW6432</code>，说明是 <code>32</code> 位进程运行在 <code>64</code> 系统上。</p><p>如果环境变量名以 <code>W6432</code> 结尾（例如， <code>CommonProgramW6432</code>， <code>PROCESSOR_ARCHITEW6432</code>，<code>ProgramW6432</code> 等）或者名字中包含 <code>(x86)</code>（例如， <code>CommonProgramFiles(x86)</code>，<code>ProgramFiles(x86)</code> 等）说明是 <code>64</code> 位系统。</p></li></ol><ol start="2"><li><p>通过 <code>lm</code> 查看模块进行判断</p><p>如果包含 <code>wow64, wow64cpu, wow64win, wowcon, wow64base</code>  中的一个模块，说明是 <code>32</code> 位进程运行在 <code>64</code> 系统上。</p></li></ol><ol start="3"><li><p>通过 <code>gs</code> 寄存器判断</p><p>运行在 <code>32</code> 位系统上的进程，并没有用到 <code>gs</code> 寄存器，<code>gs</code> 的值一般为 <code>0</code>。如果 <code>gs</code> 的值不是 <code>0</code>，说明 <code>64</code> 位系统。</p></li></ol><ol start="4"><li><p>通过 <code>wow64exts</code> 进行判断</p><p>使用 <code>.load wow64exts</code> 加载模块，然后执行 <code>!info</code> 命令进程查看。如果 <code>Guest (WoW) PEB:</code> 或者  <code>Guest (WoW) TEB:</code> 不是 <code>0</code>，说明是 <code>32</code> 位进程运行在 <code>64</code> 位系统上。</p></li></ol><p>你还知道哪些判断方法呢？欢迎分享。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://stackoverflow.com/questions/8084538/determine-if-process-dump-was-generated-on-x64-or-x86-machine" target="_blank" rel="noopener">https://stackoverflow.com/questions/8084538/determine-if-process-dump-was-generated-on-x64-or-x86-machine</a></p><p><a href="https://stackoverflow.com/questions/43308814/is-there-a-windbg-command-to-find-out-if-a-process-is-a-32-bit-one-or-a-64-bit-o" target="_blank" rel="noopener">https://stackoverflow.com/questions/43308814/is-there-a-windbg-command-to-find-out-if-a-process-is-a-32-bit-one-or-a-64-bit-o</a></p><p><a href="https://www.tessferrandez.com/blog/2010/09/29/capturing-memory-dumps-for-32-bit-processes-on-an-x64-machine.html" target="_blank" rel="noopener">https://www.tessferrandez.com/blog/2010/09/29/capturing-memory-dumps-for-32-bit-processes-on-an-x64-machine.html</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;缘起&quot;&gt;&lt;a href=&quot;#缘起&quot; class=&quot;headerlink&quot; title=&quot;缘起&quot;&gt;&lt;/a&gt;缘起&lt;/h2&gt;&lt;p&gt;曾经在 &lt;code&gt;2022&lt;/code&gt; 年分析过一个崩溃转储，文章在&lt;a href=&quot;https://bianchengnan.gitee.io/articles/analyze-a-crash-dump-and-find-the-root-cause-memory-fragmentation/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;这里&lt;/a&gt;。在那个案例中，堆空间大小将近 &lt;code&gt;4GB&lt;/code&gt;。根据上次的结论，这应该是一个运行在 &lt;code&gt;64&lt;/code&gt; 位系统下的 &lt;code&gt;32&lt;/code&gt; 位进程崩溃产生的转储文件。这让我有了一个疑问？怎么从进程转储文件中得知进程是 &lt;code&gt;32&lt;/code&gt; 位的还是 &lt;code&gt;64&lt;/code&gt; 位的？如果是 &lt;code&gt;32&lt;/code&gt; 位进程，怎么判断是运行在 &lt;code&gt;32&lt;/code&gt; 位系统上还是运行在 &lt;code&gt;64&lt;/code&gt; 位系统上呢？&lt;/p&gt;
    
    </summary>
    
      <category term="调试" scheme="https://bianchengnan.github.io/categories/%E8%B0%83%E8%AF%95/"/>
    
    
      <category term="原" scheme="https://bianchengnan.github.io/tags/%E5%8E%9F/"/>
    
      <category term="调试" scheme="https://bianchengnan.github.io/tags/%E8%B0%83%E8%AF%95/"/>
    
      <category term="dump" scheme="https://bianchengnan.github.io/tags/dump/"/>
    
      <category term="转储" scheme="https://bianchengnan.github.io/tags/%E8%BD%AC%E5%82%A8/"/>
    
  </entry>
  
  <entry>
    <title>如何快速从 32 位转储文件中找到异常发生时的线程上下文</title>
    <link href="https://bianchengnan.github.io//articles/find-the-right-exception-context-in-x64-dump-continue/"/>
    <id>https://bianchengnan.github.io//articles/find-the-right-exception-context-in-x64-dump-continue/</id>
    <published>2023-10-15T05:44:22.000Z</published>
    <updated>2024-05-18T08:56:43.822Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在上一篇<a href="https://bianchengnan.gitee.io/articles/find-the-right-exception-context-in-x64-dump/" target="_blank" rel="noopener">文章</a>中介绍了如何在 <code>64</code> 位进程的转储文件中查找异常上下文的方法 —— <code>KiUserExceptionDispatcher()</code> 函数对应栈帧的 <code>Child-SP</code> 的值保存了异常发生时的线程上下文。</p><p>本文将介绍如何在 <code>32</code> 位进程及 <code>wow64</code> 进程的转储文件中查找异常上下文的方法，并且会先介绍几个跟异常分发相关的函数和结构体。如果忘记了结论，可以根据函数参数手动逆向查找验证。</p><a id="more"></a><h2 id="查找思路"><a href="#查找思路" class="headerlink" title="查找思路"></a>查找思路</h2><p>因为 <code>32</code> 位进程中的函数参数可以通过 <code>ebp</code> 进行定位 —— <code>ebp+8</code> 指向第一个参数，<code>ebp+c</code> 指向第二个参数 …（对调用约定不是 <code>fastcall</code> 的函数有效，一般系统 <code>API</code> 都是 <code>stdcall</code>），每个函数的 <code>ebp</code> 值可以通过 <code>k</code> 命令列出来。如果知道了关键函数的参数，就可以快速定位到异常上下文了。</p><p>在查找前先介绍几个关键结构体及异常分发函数。</p><h2 id="关键的异常分发函数"><a href="#关键的异常分发函数" class="headerlink" title="关键的异常分发函数"></a>关键的异常分发函数</h2><ul><li><p>ntdll!KiUserExceptionDispatcher</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">KiUserExceptionDispatcher</span><span class="params">(EXCEPTION_RECORD* exceptionRecord, CONTEXT* contextRecord)</span></span>;</span><br></pre></td></tr></table></figure></li><li><p>ntdll!RtlDispatchException </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">RtlDispatchException</span><span class="params">(EXCEPTION_RECORD* exceptionRecord, CONTEXT* contextRecord)</span></span>;</span><br></pre></td></tr></table></figure></li><li><p><a href="https://learn.microsoft.com/en-us/windows/win32/api/errhandlingapi/nf-errhandlingapi-unhandledexceptionfilter" target="_blank" rel="noopener">kernel32!UnhandledExceptionFilter</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">LONG <span class="title">UnhandledExceptionFilter</span><span class="params">(_EXCEPTION_POINTERS* ExceptionInfo)</span></span>;</span><br></pre></td></tr></table></figure></li></ul><h2 id="关键的结构体"><a href="#关键的结构体" class="headerlink" title="关键的结构体"></a>关键的结构体</h2><ul><li><a href="https://learn.microsoft.com/en-us/windows/win32/api/winnt/ns-winnt-exception_pointers" target="_blank" rel="noopener">EXCEPTION_POINTERS</a></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">EXCEPTION_POINTERS</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  PEXCEPTION_RECORD ExceptionRecord;</span><br><span class="line">  PCONTEXT          ContextRecord;</span><br><span class="line">&#125; EXCEPTION_POINTERS, *PEXCEPTION_POINTERS;</span><br></pre></td></tr></table></figure><ul><li><a href="https://learn.microsoft.com/en-us/windows/win32/api/winnt/ns-winnt-exception_record" target="_blank" rel="noopener">EXCEPTION_RECORD</a></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span>:<span class="number">000</span>&gt; dt _EXCEPTION_RECORD</span><br><span class="line">ntdll!_EXCEPTION_RECORD</span><br><span class="line">   +<span class="number">0x000</span> ExceptionCode    : Int4B</span><br><span class="line">   +<span class="number">0x004</span> ExceptionFlags   : Uint4B</span><br><span class="line">   +<span class="number">0x008</span> ExceptionRecord  : Ptr32 _EXCEPTION_RECORD</span><br><span class="line">   +<span class="number">0x00c</span> ExceptionAddress : Ptr32 Void</span><br><span class="line">   +<span class="number">0x010</span> NumberParameters : Uint4B</span><br><span class="line">   +<span class="number">0x014</span> ExceptionInformation : [<span class="number">15</span>] Uint4B</span><br></pre></td></tr></table></figure><ul><li><p><a href="https://learn.microsoft.com/en-us/windows/win32/api/winnt/ns-winnt-context" target="_blank" rel="noopener">CONTEXT</a></p><blockquote><p>注意：文档中给出的 <code>_CONTEXT</code> 是 <code>64</code> 位的定义，通过 <code>dt</code> 命令列出来的是 <code>32</code> 位的。</p></blockquote></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">0:000&gt; dt _CONTEXT</span><br><span class="line">ntdll!_CONTEXT</span><br><span class="line">   +0x000 ContextFlags     : Uint4B</span><br><span class="line">   +0x004 Dr0              : Uint4B</span><br><span class="line">   +0x008 Dr1              : Uint4B</span><br><span class="line">   +0x00c Dr2              : Uint4B</span><br><span class="line">   +0x010 Dr3              : Uint4B</span><br><span class="line">   +0x014 Dr6              : Uint4B</span><br><span class="line">   +0x018 Dr7              : Uint4B</span><br><span class="line">   +0x01c FloatSave        : _FLOATING_SAVE_AREA</span><br><span class="line">   +0x08c SegGs            : Uint4B</span><br><span class="line">   +0x090 SegFs            : Uint4B</span><br><span class="line">   +0x094 SegEs            : Uint4B</span><br><span class="line">   +0x098 SegDs            : Uint4B</span><br><span class="line">   +0x09c Edi              : Uint4B</span><br><span class="line">   +0x0a0 Esi              : Uint4B</span><br><span class="line">   +0x0a4 Ebx              : Uint4B</span><br><span class="line">   +0x0a8 Edx              : Uint4B</span><br><span class="line">   +0x0ac Ecx              : Uint4B</span><br><span class="line">   +0x0b0 Eax              : Uint4B</span><br><span class="line">   +0x0b4 Ebp              : Uint4B</span><br><span class="line">   +0x0b8 Eip              : Uint4B</span><br><span class="line">   +0x0bc SegCs            : Uint4B</span><br><span class="line">   +0x0c0 EFlags           : Uint4B</span><br><span class="line">   +0x0c4 Esp              : Uint4B</span><br><span class="line">   +0x0c8 SegSs            : Uint4B</span><br><span class="line">   +0x0cc ExtendedRegisters : [512] UChar</span><br></pre></td></tr></table></figure><p>下面通过几个实例介绍如何在 <code>32</code> 位进程及 <code>wow64</code> 进程的转储文件中查找异常上下文。</p><h2 id="实战"><a href="#实战" class="headerlink" title="实战"></a>实战</h2><p>基本上 <code>32</code> 位进程和 <code>wow64</code> 进程查找方法一样，不再单独分析，这里介绍几种典型情况。</p><h3 id="案例1"><a href="#案例1" class="headerlink" title="案例1"></a>案例1</h3><p>下图是某个 <code>32</code> 位进程转储文件发生异常时的调用栈。</p><p><img src="http://resources.bianchengnan.tech/find-the-right-exception-context-in-x64-dump-continue/view-exception-callstack-32.png" alt="view-exception-callstack-32"></p><p>从上图中可知，<code>RtlDispatchException()</code> 对应的 <code>ebp</code> 是 <code>0x0014f8e8</code>，<code>UnhandledExceptionFilter()</code> 对应的 <code>ebp</code> 是 <code>0x0014f7d0</code>。从<code>RtlDispatchException()</code>  入手。</p><p>通过 <code>dd 0014f8e8</code> 命令可以得知  <code>EXCEPTION_RECORD</code> 的地址是 <code>0x0014f900</code>（<code>ebp+8</code> 处的值），<code>CONTEXT</code> 的地址是 <code>0x0014f91c</code> （<code>ebp+c</code> 处的值）。</p><p>再通过 <code>dt _EXCEPTION_RECORD 0014f900</code> 和 <code>dt _CONTEXT 0014f91c</code> 查看对应结构体的具体内容，可以发现是匹配的，如下图。</p><p> <img src="http://resources.bianchengnan.tech/find-the-right-exception-context-in-x64-dump-continue/verify-exception-info-32.png" alt="verify-exception-info-32"></p><h3 id="案例2"><a href="#案例2" class="headerlink" title="案例2"></a>案例2</h3><p>下图是某个 <code>wow64</code> 位进程转储文件发生异常时的调用栈。</p><p><img src="http://resources.bianchengnan.tech/find-the-right-exception-context-in-x64-dump-continue/view-exception-callstack-wow64.png" alt="view-exception-callstack-wow64"></p><p>调用栈中只能看到 <code>UnhandledExceptionFilter()</code> ，对应的 <code>ebp</code> 是 <code>0x0097f474</code>。<code>ebp+8</code> 位置的值（<code>0x0097f4a4</code>）存储了 </p><p><code>_EXCEPTION_POINTERS*</code> 的值（<code>0x0097f4a4</code>）。使用 <code>dd 0097f4a4 L4</code> 查看 <code>_EXCEPTION_RECORD</code> 的地址（<code>0x0097f5e0</code>）和 <code>_CONTEXT</code> 的地址（<code>0x0097f630</code>）。然后再验证，发现是匹配的。郑国过程如下图：</p><p><img src="http://resources.bianchengnan.tech/find-the-right-exception-context-in-x64-dump-continue/verify-exception-info-wow64.png" alt="verify-exception-info-wow64"></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li><p><code>32</code> 位进程中的函数参数可以通过 <code>ebp</code> 进行定位。我觉得这是 <code>32</code> 位进程调试时相对于 <code>64</code> 位进程最友好的地方了，不用费劲到栈上找参数了。</p></li><li><p>可以通过 <code>ntdll!RtlDispatchException()</code> 和 <code>kernel32!UnhandledExceptionFilter()</code> 的参数快速找到异常上下文。</p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;在上一篇&lt;a href=&quot;https://bianchengnan.gitee.io/articles/find-the-right-exception-context-in-x64-dump/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;文章&lt;/a&gt;中介绍了如何在 &lt;code&gt;64&lt;/code&gt; 位进程的转储文件中查找异常上下文的方法 —— &lt;code&gt;KiUserExceptionDispatcher()&lt;/code&gt; 函数对应栈帧的 &lt;code&gt;Child-SP&lt;/code&gt; 的值保存了异常发生时的线程上下文。&lt;/p&gt;
&lt;p&gt;本文将介绍如何在 &lt;code&gt;32&lt;/code&gt; 位进程及 &lt;code&gt;wow64&lt;/code&gt; 进程的转储文件中查找异常上下文的方法，并且会先介绍几个跟异常分发相关的函数和结构体。如果忘记了结论，可以根据函数参数手动逆向查找验证。&lt;/p&gt;
    
    </summary>
    
      <category term="调试" scheme="https://bianchengnan.github.io/categories/%E8%B0%83%E8%AF%95/"/>
    
    
      <category term="调试" scheme="https://bianchengnan.github.io/tags/%E8%B0%83%E8%AF%95/"/>
    
      <category term="异常" scheme="https://bianchengnan.github.io/tags/%E5%BC%82%E5%B8%B8/"/>
    
      <category term="debug" scheme="https://bianchengnan.github.io/tags/debug/"/>
    
      <category term="dump" scheme="https://bianchengnan.github.io/tags/dump/"/>
    
      <category term="windbg" scheme="https://bianchengnan.github.io/tags/windbg/"/>
    
      <category term="wow64" scheme="https://bianchengnan.github.io/tags/wow64/"/>
    
      <category term="32" scheme="https://bianchengnan.github.io/tags/32/"/>
    
      <category term="EXCEPTION_RECORD" scheme="https://bianchengnan.github.io/tags/EXCEPTION-RECORD/"/>
    
  </entry>
  
  <entry>
    <title>如何快速从 64 位转储文件中找到异常发生时的线程上下文</title>
    <link href="https://bianchengnan.github.io//articles/find-the-right-exception-context-in-x64-dump/"/>
    <id>https://bianchengnan.github.io//articles/find-the-right-exception-context-in-x64-dump/</id>
    <published>2023-09-29T07:44:22.000Z</published>
    <updated>2024-05-18T08:56:43.829Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>经常做调试的朋友可能会遇到在 <code>windbg</code> 里通过 <code>k</code> 系列命令得到的调用栈没有太大参考意义。一般是由于线程上下文不对导致的。这时候可以通过 <code>!analyze -v</code> 让 <code>windbg</code> 自动帮我们分析出正确的调用栈及异常发生时的线程上下文。有了上下文信息，就可以执行 <code>.cxr address_to_context</code> 命令切换上下文，这时候再通过 <code>k</code> 命令查看调用栈，一般可以得到一个有意义的调用栈。</p><p>但有时候 <code>!analyze -v</code> 分析出来的上下文信息也是不对的。这时候就需要我们自己手动查找异常上下文了。</p><p>这不，最近我就遇到了一个需要手动查找异常上下文的情况。经过调查发现了一个非常重要的规律 —— <code>64</code> 位程序中，<code>KiUserExceptionDispatcher</code> 函数对应栈帧的 <code>Child-SP</code> 的值保存了异常发生时的线程上下文。</p><p>本文完整记录了整个查找验证的过程。</p><blockquote><p><strong>吐槽：</strong> <code>64</code> 位程序的参数传递方式与 <code>32</code> 位程序大不相同，不能根据 <code>ebp</code> 定位参数了。而是需要结合反汇编代码来推断某个函数的参数是否保存到栈上。如果没保存到栈上，基本上很难找到相关参数了。</p></blockquote><a id="more"></a><h2 id="analyze-v"><a href="#analyze-v" class="headerlink" title="!analyze -v"></a>!analyze -v</h2><p>一般拿到一个转储文件后，我做的第一件事是执行 <code>!analyze -v</code>。因为很有可能直接就破案了。但是这次没那么幸运，从 <code>!analyze -v</code> 给出的调用栈，看不出是什么导致的异常。</p><p><img src="http://resources.bianchengnan.tech/find-the-right-exception-context-in-x64-dump/callstack-of-analyze-v.png" alt="result-of-analyze-v"></p><p> <code>!analyze -v</code> 在给出调用栈的同时，也会给出 <code>Exception Record</code> （下图中 <code>.exr</code> 部分）和 <code>Context Record</code> （下图中 <code>.cxr</code> 部分）的地址。</p><p><img src="http://resources.bianchengnan.tech/find-the-right-exception-context-in-x64-dump/result-of-exr-and-cxr.png" alt="result-of-exr-and-cxr"></p><p>点击上图中两条命令对应的超链接即可执行对应的命令。但是经过确认，<code>.exr</code> 和 <code>.cxr</code> 对应的内容并没有什么实际意义。看来只能手动查找异常发生时的线程上下文了。该从哪里入手呢？</p><h2 id="查看反汇编"><a href="#查看反汇编" class="headerlink" title="查看反汇编"></a>查看反汇编</h2><p><code>KiUserExceptionDispatcher()</code> 是分发异常的关键函数，可以从次函数入手进行分析。<code>KiUserExceptionDispatcher()</code> 函数的原型如下：</p><p><code>void KiUserExceptionDispatcher(__in PEXCEPTION_RECORD ExceptionRecord, __in PCONTEXT ContextRecord)</code></p><p>我的第一反应是查看传递给该函数的 <code>rdx</code>（ <code>64</code> 位程序中 <code>rdx</code> 指向第二个参数） 是否保存到栈上，但是没有找到有用线索。</p><blockquote><p><strong>说明：</strong> 折腾完才反应过来，此函数是从 <code>0</code> 环返回到 <code>3</code> 环的入口函数，不能用普通的函数调用机制来理解。</p></blockquote><p>尝试查看一下 <code>KiUserExceptionDispatcher()</code> 的反汇编代码？在 <code>windbg</code> 中输入 <code>uf ntdll!KiUserExceptionDispatch</code> 查看该函数的反汇编代码，结果如下：</p><p><img src="http://resources.bianchengnan.tech/find-the-right-exception-context-in-x64-dump/uf-KiUserExceptionDispatch.png" alt="uf-KiUserExceptionDispatch"></p><p>好在该函数的反汇编代码比较短，让我这个弱鸡能有信心继续调查。</p><p>看到了该函数内部会调用几个函数，一个是 <code>ntdll!Wow64PrepareForException()</code>，一个是 <code>ntdll!RtlDispatchException()</code>，还有一个是 <code>ntdll!NtRaiseException()</code>。我在网上搜了一下 <code>ntdll!RtlDispatchException()</code> 的原型，如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOLEAN <span class="title">RtlDispatchException</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  IN  PEXCEPTION_RECORD ExceptionRecord,</span></span></span><br><span class="line"><span class="function"><span class="params">  IN  PCONTEXT ContextRecord</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br></pre></td></tr></table></figure><p>第一个参数是 <code>ExceptionRecord</code> 的地址，第二个参数是 <code>ContextRecord</code> 的地址。结合上图中的反汇编代码及 <code>x64</code> 调用约定（前两个参数会通过 <code>rcx</code> 和 <code>rdx</code> 传递）可以猜测，<code>rsp</code> 指向了 <code>ContextRecord</code>，<code>rsp+0x4f0</code> 指向了 <code>ExceptionRecord</code>。但是为什么是 <code>0x4f0</code> 呢？难道 <code>_CONTEXT</code> 结构体的大小是 <code>0x4f0</code> ？</p><h2 id="小心求证"><a href="#小心求证" class="headerlink" title="小心求证"></a>小心求证</h2><p>在 <code>windbg</code> 中查看这两个结构体的大小，如下图：</p><p><img src="http://resources.bianchengnan.tech/find-the-right-exception-context-in-x64-dump/view-size-of-context-and-exception-record.png" alt="view-size-of-context-and-exception-record"></p><p>发现 <code>0X4f0</code> 比 <code>_CONTEXT</code> 的大了 <code>32</code> 字节 （<code>0x4f0 - 0x4d0 = 0x20 = 32</code>）。如果 <code>esp</code> 指向了 <code>_CONTEXT</code> ，那么在 <code>_CONTEXT</code> 结构体后面偏移 <code>32</code> 字节的位置存放了 <code>_EXCEPTION_RECORD</code>。到底是不是这样呢？</p><p>验证一下 <code>_EXCEPTION_RECORD</code> 的内容（为什么验证这个结构体？因为 <code>_EXCEPTION_RECORD</code> 的中的 <code>ExceptionCode</code> 比较容易辨认），如下图所示：</p><p><img src="http://resources.bianchengnan.tech/find-the-right-exception-context-in-x64-dump/verify-exception-record.png" alt="verify-exception-record"></p><blockquote><p><strong>注意：</strong> <code>0000004e 78dfa980</code> 是调用栈帧 <code>0e</code> 的 <code>Child-SP</code> 的值。加上偏移 <code>0x4f0</code> 就得到了 <code>_EXCEPTION_RECORD</code> 对象的首地址。 </p></blockquote><p>从上图可知，<code>ExceptionCode</code> 的值是 <code>0xc0000005</code> （常见的访问违例），导致异常的指令地址是  <code>0x00007ffd bbde9863</code>。从 <code>ExceptionInformation[0]</code> 可知导致异常的访问类型是<strong>读取</strong>（<code>0</code> 表示读取，<code>1</code> 表示写入），从 <code>ExceptionInformation[1]</code> 可知，导致异常的访问地址是  <code>0x000001bc 12e12052</code> 。</p><blockquote><p><strong>说明：</strong> 对以上字段的解读可以参考《软件调试》第一版 第 <code>12</code> 章 <code>320</code> 页。</p></blockquote><p>执行 <code>.cxr 0000004e 78dfa980</code> 切换线程上下文，然后执行 <code>k</code> 命令查看调用栈。</p><p><img src="http://resources.bianchengnan.tech/find-the-right-exception-context-in-x64-dump/change-context-and-view-callstack.png" alt="change-context-and-view-callstack"></p><p>从上图红框高亮部分可以看出，在读取地址 <code>0x000001bc 12e12052</code> 时出错了，导致异常的指令地址是 <code>0x00007ffd bbde9863</code>。与 <code>_EXCEPTION_RECORD</code> 中的信息完全吻合。 </p><p>上面的猜测应该是正确的。此时，突然想起早些时候也查过一个类似的问题。当时在看雪群里问了一下，有一位大佬说 <code>esp</code> 指向了异常上下文，当时没往心里去。</p><p>我想我肯定忘不了这个至关重要的规律了！</p><h2 id="尝试破案"><a href="#尝试破案" class="headerlink" title="尝试破案"></a>尝试破案</h2><p>执行 <code>!address 0x1bc12e12052</code> 查看地址属性，可以发现，该地址对应的页面确实不可访问。</p><p><img src="http://resources.bianchengnan.tech/find-the-right-exception-context-in-x64-dump/view-address-page-information.png" alt="view-address-page-information"></p><p>本想继续调查一下具体原因，奈何没有对应的调试符号，只简单查看了一下反汇编代码，没有特别的发现。由于手头 <code>bug</code> 比较多，而且没有调试符号，查起来会比较耗时间，剩下的工作就留给平台同事继续调查吧。</p><h2 id="KiUserExceptionDispatcher-伪代码"><a href="#KiUserExceptionDispatcher-伪代码" class="headerlink" title="KiUserExceptionDispatcher 伪代码"></a>KiUserExceptionDispatcher 伪代码</h2><p>通过前面的反汇编代码，结合在 <code>IDA</code> 中对 <code>KiUserExceptionDispatcher()</code> 进行 <code>F5</code> 结果，伪代码整理如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">KiUserExceptionDispatcher</span><span class="params">(EXCEPTION_RECORD* exceptionRecord, CONTEXT* contextRecord)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (Wow64PrepareForException)</span><br><span class="line">  &#123;</span><br><span class="line">    Wow64PrepareForException(exceptionRecord, contextRecord);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  DWORD result;</span><br><span class="line">  <span class="keyword">if</span> (RtlDispatchException(exceptionRecord, contextRecord) )</span><br><span class="line">  &#123;</span><br><span class="line">    result = RtlGuardRestoreContext(contextRecord, <span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    result = ZwRaiseException(exceptionRecord, contextRecord, FALSE);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  RtlRaiseStatus(result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><strong>疑问：</strong> <code>windbg</code> 调用栈中给出的名字是 <code>ntdll!KiUserExceptionDispatch</code>，少了 <code>er</code>（好像也可以用 <code>ntdll!KiUserExceptionDispatcher</code>），在 <code>IDA</code> 中对应的函数名字是 <code>ntdll!KiUserExceptionDispatcher</code>。</p></blockquote><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li><p><code>64</code> 位程序中 <code>KiUserExceptionDispatch()</code> 对应栈帧的 <code>Child-SP</code> 保存了 <code>_CONTEXT</code> 参数，<code>rsp+4f0</code> 处保存了 <code>_EXCEPTION_RECORD</code> 参数，可以根据这个规律直接找到异常发生时的线程上下文信息及异常信息。</p></li><li><p>当直接通过 <code>k</code> 命令得到的调用栈不符合预期时，可以通过 <code>.cxr context</code> 切换到 <code>context</code> 指定的线程上下文后再次尝试。</p></li><li><p>可以通过 <code>?? sizeof(struct_name)</code> 查看某个结构体的大小。</p></li><li><p>可以通过 <code>!address addr</code> 查看某个地址对应的页面属性。</p></li></ul><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><p>《软件调试》第一版 第 <code>12</code> 章 未处理异常和 <code>JIT</code> 调试</p></li><li><p><code>RtlDispatchException()</code> <a href="http://www.codewarrior.cn/ntdoc/winnt/rtl/mips/RtlDispatchException.htm" target="_blank" rel="noopener">http://www.codewarrior.cn/ntdoc/winnt/rtl/mips/RtlDispatchException.htm</a></p></li><li><p>调试笔记之VTUNE崩溃 <a href="http://advdbg.org/blogs/advdbg_system/articles/7063.aspx" target="_blank" rel="noopener">http://advdbg.org/blogs/advdbg_system/articles/7063.aspx</a></p></li></ul><h2 id="More"><a href="#More" class="headerlink" title="More"></a>More</h2><p><code>64</code> 位程序发生异常时，可以使用这个规律查找到异常发生时的线程上下文信息，运行在 <code>32</code> 位系统下的程序是否也满足这个规律？运行在 <code>64</code> 位系统下的 <code>32</code> 位程序呢？敬请期待~</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;经常做调试的朋友可能会遇到在 &lt;code&gt;windbg&lt;/code&gt; 里通过 &lt;code&gt;k&lt;/code&gt; 系列命令得到的调用栈没有太大参考意义。一般是由于线程上下文不对导致的。这时候可以通过 &lt;code&gt;!analyze -v&lt;/code&gt; 让 &lt;code&gt;windbg&lt;/code&gt; 自动帮我们分析出正确的调用栈及异常发生时的线程上下文。有了上下文信息，就可以执行 &lt;code&gt;.cxr address_to_context&lt;/code&gt; 命令切换上下文，这时候再通过 &lt;code&gt;k&lt;/code&gt; 命令查看调用栈，一般可以得到一个有意义的调用栈。&lt;/p&gt;
&lt;p&gt;但有时候 &lt;code&gt;!analyze -v&lt;/code&gt; 分析出来的上下文信息也是不对的。这时候就需要我们自己手动查找异常上下文了。&lt;/p&gt;
&lt;p&gt;这不，最近我就遇到了一个需要手动查找异常上下文的情况。经过调查发现了一个非常重要的规律 —— &lt;code&gt;64&lt;/code&gt; 位程序中，&lt;code&gt;KiUserExceptionDispatcher&lt;/code&gt; 函数对应栈帧的 &lt;code&gt;Child-SP&lt;/code&gt; 的值保存了异常发生时的线程上下文。&lt;/p&gt;
&lt;p&gt;本文完整记录了整个查找验证的过程。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;吐槽：&lt;/strong&gt; &lt;code&gt;64&lt;/code&gt; 位程序的参数传递方式与 &lt;code&gt;32&lt;/code&gt; 位程序大不相同，不能根据 &lt;code&gt;ebp&lt;/code&gt; 定位参数了。而是需要结合反汇编代码来推断某个函数的参数是否保存到栈上。如果没保存到栈上，基本上很难找到相关参数了。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="调试" scheme="https://bianchengnan.github.io/categories/%E8%B0%83%E8%AF%95/"/>
    
    
      <category term="调试" scheme="https://bianchengnan.github.io/tags/%E8%B0%83%E8%AF%95/"/>
    
      <category term="debug" scheme="https://bianchengnan.github.io/tags/debug/"/>
    
      <category term="dump" scheme="https://bianchengnan.github.io/tags/dump/"/>
    
      <category term="windbg" scheme="https://bianchengnan.github.io/tags/windbg/"/>
    
      <category term="x64" scheme="https://bianchengnan.github.io/tags/x64/"/>
    
  </entry>
  
  <entry>
    <title>感受 AI 的力量——利用 Cursor 自动生成 powershell 脚本下载 TheOldNewThing 博文</title>
    <link href="https://bianchengnan.github.io//articles/download-the-old-new-thing-archive-blog-using-powershell-with-the-help-of-Cursor/"/>
    <id>https://bianchengnan.github.io//articles/download-the-old-new-thing-archive-blog-using-powershell-with-the-help-of-Cursor/</id>
    <published>2023-08-06T12:24:04.000Z</published>
    <updated>2024-05-18T08:56:43.774Z</updated>
    
    <content type="html"><![CDATA[<h2 id="缘起"><a href="#缘起" class="headerlink" title="缘起"></a>缘起</h2><p>今天查资料的时候，偶然发现了一位国外网友镜像了 <code>TheOleNewThing</code> 从 <code>2003</code> 年到 <code>2019</code> 年的<a href="https://bytepointer.com/resources/old_new_thing/index.htm" target="_blank" rel="noopener">博文</a>，竟然有 <code>5000</code> 多篇（真是高产）。值得注意的是，微软官方博客中许多链接都已经失效了。为了防止这位网友的镜像链接也失效，我决定赶紧将这些内容下载保存下来。手动保存显然不现实，毕竟有 <code>5000</code> 多篇文章呢！所以，我决定写脚本来自动下载，这才是明智之举！如果是几年前，我肯定要亲自动手写脚本，不过如今，<code>AI</code> 这么强大，我无需再费力。幸运的是，我利用 <a href="https://www.cursor.so/" target="_blank" rel="noopener">Cursor</a> 自动生成下载脚本的全过程，并对其进行了简单的修改，成功地将全部 <code>5000</code> 多篇文章下载并压缩存档，并按年月分类打包好了！不得不赞叹一句，<code>AI</code> 真是太强大了。</p><a id="more"></a><h2 id="下载地址"><a href="#下载地址" class="headerlink" title="下载地址"></a>下载地址</h2><p>所有文章已经按年压缩，感兴趣的朋友可以自行下载。</p><p>百度云盘：<a href="https://pan.baidu.com/s/1gGx7mvLsumbtzoQbatPsfw?pwd=dbqt" target="_blank" rel="noopener">https://pan.baidu.com/s/1gGx7mvLsumbtzoQbatPsfw?pwd=dbqt</a> 提取码: dbqt</p><p><code>gitee</code>:</p><p><a href="https://gitee.com/bianchengnan/my-blog/tree/master/download-the-old-new-thing-archive-blog-using-powershell-with-the-help-of-Cursor" target="_blank" rel="noopener">https://gitee.com/bianchengnan/my-blog/tree/master/download-the-old-new-thing-archive-blog-using-powershell-with-the-help-of-Cursor</a></p><blockquote><p><strong>注：</strong> 所有文章版权归原作者所有，我只是为了防止失联，转存一份。侵删！</p></blockquote><h2 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h2><p>Q:</p><p>download url and save to disk and then parse inner urls and then save these urls to disk</p><p>A:</p><p>To download a URL, save it to disk, parse inner URLs, and then save these URLs to disk in PowerShell, you can use the Invoke-WebRequest cmdlet to download the webpage, Out-File cmdlet to save it to disk, and then use a regular expression to parse the inner URLs. Here is a simple example:</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Define the URL</span></span><br><span class="line"><span class="variable">$url</span> = <span class="string">"http://example.com"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Define the output file for the webpage</span></span><br><span class="line"><span class="variable">$outfile</span> = <span class="string">"output.html"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Define the output file for the inner URLs</span></span><br><span class="line"><span class="variable">$urlfile</span> = <span class="string">"urls.txt"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Download the webpage and save to disk</span></span><br><span class="line"><span class="built_in">Invoke-WebRequest</span> -Uri <span class="variable">$url</span> -OutFile <span class="variable">$outfile</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Read the saved file</span></span><br><span class="line"><span class="variable">$content</span> = <span class="built_in">Get-Content</span> -Path <span class="variable">$outfile</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Parse the inner URLs</span></span><br><span class="line"><span class="variable">$innerUrls</span> = <span class="variable">$content</span> | <span class="built_in">Where-Object</span> &#123; <span class="variable">$_</span> <span class="nomarkup">-match</span> <span class="string">"(http|https)://[a-zA-Z0-9\-\.]+\.[a-zA-Z]&#123;2,3&#125;(/\S*)?"</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># Save the inner URLs to disk</span></span><br><span class="line"><span class="variable">$innerUrls</span> | <span class="built_in">Out-File</span> -FilePath <span class="variable">$urlfile</span></span><br></pre></td></tr></table></figure><p>This script will download the webpage, save it to output.html, read the saved file, parse the inner URLs, and then save these URLs to urls.txt. You can adjust the regular expression in the Where-Object cmdlet to match the URLs you are interested in.</p><blockquote><p><strong>画外音：</strong> 我发现解析出来的内部 <code>urls</code> 不太对，于是查看了原始网页中的链接形式，又对 <code>Cursor</code> 提出了进一步的要求，这次是用中文提的。</p></blockquote><p>Q:</p><p>解析匹配 <code>href=&quot;xxx&quot;</code> 模式的字符串。</p><p>A:</p><p>要在 <code>PowerShell</code> 中下载 <code>URL</code>，将其保存到磁盘，然后解析内部 <code>URL</code>，并将这些 <code>URL</code> 保存到磁盘，您可以使用 <code>Invoke-WebRequest cmdlet</code> 下载网页，使用 <code>Out-File cmdlet</code> 将其保存到磁盘，然后使用正则表达式解析内部 <code>URL</code>。以下是一个简单的示例：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 省略 N 行</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 解析内部 URL</span></span><br><span class="line"><span class="variable">$innerUrls</span> = <span class="variable">$content</span> | <span class="built_in">Where-Object</span> &#123; <span class="variable">$_</span> <span class="nomarkup">-match</span> <span class="string">'href="([^"]*)"'</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 保存内部 URL 到磁盘</span></span><br><span class="line"><span class="variable">$innerUrls</span> | <span class="built_in">Out-File</span> -FilePath <span class="variable">$urlfile</span></span><br></pre></td></tr></table></figure><p>此脚本将下载网页，将其保存到 <code>output.html</code>，读取保存的文件，解析内部 <code>URL</code>，然后将这些 <code>URL</code> 保存到 <code>urls.txt</code>。您可以调整 <code>Where-Object cmdlet</code> 中的正则表达式以匹配您感兴趣的 <code>URL</code>。</p><blockquote><p><strong>画外音：</strong> 非常不错，可以记住上下文。</p></blockquote><p>Q:</p><p>解析内部 <code>url</code> 的语句有问题，没有只保存 <code>href=&quot;&quot;</code> 内部的内容</p><p>A:</p><p>对不起，我之前的回答中的正则表达式确实有误。我们应该使用一个捕获组来只获取 <code>href=&quot;&quot;</code> 内部的内容。以下是修正后的代码：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 省略 N 行</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 解析内部 URL</span></span><br><span class="line"><span class="variable">$innerUrls</span> = <span class="variable">$content</span> | <span class="built_in">Select-String</span> -Pattern <span class="string">'href="([^"]*)"'</span> -AllMatches | % &#123; <span class="variable">$_</span>.Matches &#125; | % &#123; <span class="variable">$_</span>.Groups[<span class="number">1</span>].Value &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 保存内部 URL 到磁盘</span></span><br><span class="line"><span class="variable">$innerUrls</span> | <span class="built_in">Out-File</span> -FilePath <span class="variable">$urlfile</span></span><br></pre></td></tr></table></figure><p>这段脚本将下载网页，将其保存到 <code>output.html</code>，读取保存的文件，解析内部 <code>URL</code>，然后将这些 <code>URL</code> 保存到 <code>urls.txt</code>。<code>Select-String cmdlet</code> 中的正则表达式已经被修改，现在它只会匹配 <code>href=&quot;&quot;</code> 内部的内容。</p><blockquote><p><strong>画外音：</strong> 看了生成的内容，已经无限接近最终想要的结果了，但是没想到居然写了 <code>5000</code> 多篇文章，手动拼接网址还是需要操作一会的。于是继续优化脚本。</p></blockquote><p>Q:</p><p>需要在解析出来的 url 前加上前缀 <a href="https://bytepointer.com/resources/old_new_thing/" target="_blank" rel="noopener">https://bytepointer.com/resources/old_new_thing/</a> 再保存</p><p>A:</p><p>在解析出来的 <code>URL</code> 前加上前缀并保存的 <code>PowerShell</code> 代码如下：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 省略 N 行</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加前缀</span></span><br><span class="line"><span class="variable">$prefix</span> = <span class="string">"https://bytepointer.com/resources/old_new_thing/"</span></span><br><span class="line"><span class="variable">$innerUrls</span> = <span class="variable">$innerUrls</span> | <span class="built_in">ForEach-Object</span> &#123; <span class="variable">$prefix</span> + <span class="variable">$_</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 保存内部 URL 到磁盘</span></span><br><span class="line"><span class="variable">$innerUrls</span> | <span class="built_in">Out-File</span> -FilePath <span class="variable">$urlfile</span></span><br></pre></td></tr></table></figure><p>这段脚本将下载网页，将其保存到 <code>output.html</code>，读取保存的文件，解析内部 <code>URL</code>，然后在每个 <code>URL</code> 前添加前缀，最后将这些 <code>URL</code> 保存到 <code>urls.txt</code>。</p><p>至此，已经把需要下载的 <code>url</code> 保存到了 <code>urls.txt</code>。接下来就要写脚本下载这些 <code>url</code> 了。最终载脚本如下：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 定义 URL</span></span><br><span class="line"><span class="variable">$url</span> = <span class="string">"https://bytepointer.com/resources/old_new_thing/index.htm"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义网页的输出文件</span></span><br><span class="line"><span class="variable">$outfile</span> = <span class="string">"output.html"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义内部 URL 的输出文件</span></span><br><span class="line"><span class="variable">$urlfile</span> = <span class="string">"urls.txt"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 下载网页并保存到磁盘</span></span><br><span class="line"><span class="built_in">Invoke-WebRequest</span> -Uri <span class="variable">$url</span> -OutFile <span class="variable">$outfile</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 读取保存的文件</span></span><br><span class="line"><span class="variable">$content</span> = <span class="built_in">Get-Content</span> -Path <span class="variable">$outfile</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 解析内部 URL</span></span><br><span class="line"><span class="variable">$innerUrls</span> = <span class="variable">$content</span> | <span class="built_in">Select-String</span> -Pattern <span class="string">'href="([^"]*)"'</span> -AllMatches | % &#123; <span class="variable">$_</span>.Matches &#125; | % &#123; <span class="variable">$_</span>.Groups[<span class="number">1</span>].Value &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加前缀</span></span><br><span class="line"><span class="variable">$prefix</span> = <span class="string">"https://bytepointer.com/resources/old_new_thing/"</span></span><br><span class="line"><span class="variable">$innerUrls</span> = <span class="variable">$innerUrls</span> | <span class="built_in">ForEach-Object</span> &#123; <span class="variable">$prefix</span> + <span class="variable">$_</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 保存内部 URL 到磁盘</span></span><br><span class="line"><span class="variable">$innerUrls</span> | <span class="built_in">Out-File</span> -FilePath <span class="variable">$urlfile</span></span><br></pre></td></tr></table></figure><h2 id="解析-url-并下载"><a href="#解析-url-并下载" class="headerlink" title="解析 url 并下载"></a>解析 url 并下载</h2><p>Q:</p><p>遍历 <code>urls.txt</code> 并下载里面的每个 <code>url</code>，如果下载失败需要有提示，并且记录下载的位置。</p><p>A:</p><p>在 <code>PowerShell</code> 中，你可以使用 <code>Invoke-WebRequest cmdlet</code> 来下载 <code>URL</code>，并使用 <code>try/catch</code> 语句来处理可能的错误。以下是一个简单的示例：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 定义 URL 文件</span></span><br><span class="line"><span class="variable">$urlfile</span> = <span class="string">"urls.txt"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 读取 URL 文件</span></span><br><span class="line"><span class="variable">$urls</span> = <span class="built_in">Get-Content</span> -Path <span class="variable">$urlfile</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 遍历每个 URL</span></span><br><span class="line"><span class="keyword">foreach</span> (<span class="variable">$url</span> <span class="keyword">in</span> <span class="variable">$urls</span>) &#123;</span><br><span class="line">  <span class="comment"># 定义输出文件</span></span><br><span class="line">  <span class="variable">$outfile</span> = <span class="string">"downloaded_"</span> + [System.IO.Path]::GetFileName(<span class="variable">$url</span>)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment"># 下载 URL 并保存到磁盘</span></span><br><span class="line">    <span class="built_in">Invoke-WebRequest</span> -Uri <span class="variable">$url</span> -OutFile <span class="variable">$outfile</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 打印下载的位置</span></span><br><span class="line">    <span class="built_in">Write-Output</span> <span class="string">"Downloaded <span class="variable">$url</span> to <span class="variable">$outfile</span>"</span></span><br><span class="line">  &#125; catch &#123;</span><br><span class="line">    <span class="comment"># 如果下载失败，打印错误信息</span></span><br><span class="line">    <span class="built_in">Write-Output</span> <span class="string">"Failed to download <span class="variable">$url:</span> <span class="variable">$_</span>"</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段脚本将读取 <code>urls.txt</code> 文件中的每个 <code>URL</code>，然后尝试下载每个 <code>URL</code> 并保存到磁盘。如果下载失败，它将打印一个错误信息。下载成功的文件将被保存为 <code>&quot;downloaded_&quot;</code> 加上原始文件名。</p><blockquote><p><strong>画外音：</strong></p><ol><li>最后面的 <code>Write-Output &quot;Failed to download $url: $_&quot;</code> 会报错，需要在 <code>$url</code> 与 <code>:</code> 之间加空格。</li><li>保存的文件名我去掉了 <code>downloaded_</code> 前缀，而是保存到了 <code>d:/downloaded/</code> 目录下。</li></ol></blockquote><p>因为文件数量太多，全部放到一个目录下会比较乱，于是想着按年月进行分组整理。</p><h2 id="按年月分组"><a href="#按年月分组" class="headerlink" title="按年月分组"></a>按年月分组</h2><p>Q: </p><p>遍历文件夹中的文件，文件名前 <code>8</code> 个字符是年月日，比如 <code>20030722_001_why_do_you_have_to_click_the_start_button_to_shut_down.html</code>。从中提取出年份，月份，并且根据年份创建文件夹，然后根据月份创建子文件夹，并把对应的文件放到新建的文件夹中。</p><p>A:</p><p>这是一个 <code>PowerShell</code> 脚本的示例，它可以遍历文件夹中的文件，提取文件名前 <code>8</code> 个字符作为年份和月份，然后根据年份创建文件夹，根据月份创建子文件夹，并将对应的文件移动到新建的文件夹中。</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$sourceDir</span> = <span class="string">"C:\path\to\your\source\directory"</span> <span class="comment"># 源文件夹路径</span></span><br><span class="line"></span><br><span class="line"><span class="variable">$destDir</span> = <span class="string">"C:\path\to\your\destination\directory"</span> <span class="comment"># 目标文件夹路径</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Get-ChildItem</span> <span class="variable">$sourceDir</span> -File | <span class="built_in">ForEach-Object</span> &#123;</span><br><span class="line">  <span class="variable">$year</span> = <span class="variable">$_</span>.Name.Substring(<span class="number">0</span>, <span class="number">4</span>) <span class="comment"># 提取年份</span></span><br><span class="line">  <span class="variable">$month</span> = <span class="variable">$_</span>.Name.Substring(<span class="number">4</span>, <span class="number">2</span>) <span class="comment"># 提取月份</span></span><br><span class="line">  <span class="variable">$newDir</span> = <span class="built_in">Join-Path</span> -Path <span class="variable">$destDir</span> -ChildPath <span class="variable">$year</span> -AdditionalChildPath <span class="variable">$month</span> <span class="comment"># 新文件夹路径</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!(<span class="built_in">Test-Path</span> <span class="variable">$newDir</span>)) &#123; <span class="comment"># 如果文件夹不存在，则创建</span></span><br><span class="line">  <span class="built_in">New-Item</span> -ItemType Directory -Path <span class="variable">$newDir</span> | <span class="built_in">Out-Null</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">Move-Item</span> -Path <span class="variable">$_</span>.FullName -Destination <span class="variable">$newDir</span> <span class="comment"># 移动文件到新文件夹</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>请将 <code>$sourceDir</code> 和 <code>$destDir</code> 替换为你的实际路径。这个脚本会遍历 <code>$sourceDir</code> 中的所有文件，提取文件名前 <code>4</code> 个字符作为年份，接着的 <code>2</code> 个字符作为月份，然后在 <code>$destDir</code> 中创建一个以年份命名的新文件夹，再在该文件夹下创建以月份命名的子文件夹，并将文件移动到新文件夹中。如果新文件夹已经存在，它将不会再次创建。</p><blockquote><p><strong>画外音：</strong> <code>-AdditionalChildPath</code> 好像不是一个合法的选项，是 <code>AI</code> 自己臆想出来的。于是手动修改代码如下：</p><p><code>$newDir = Join-Path -Path $destDir -ChildPath $year</code></p><p><code>$newDir = Join-Path -Path $newDir -ChildPath $month</code></p></blockquote><h2 id="压缩"><a href="#压缩" class="headerlink" title="压缩"></a>压缩</h2><p>Q:</p><p>遍历文件夹，并压缩</p><p>A:</p><p>你可以使用 <code>PowerShell</code> 的 <code>Compress-Archive</code> 命令来遍历文件夹并压缩文件。以下是一个示例：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$sourceDir</span> = <span class="string">"C:\path\to\your\source\directory"</span> <span class="comment"># 源文件夹路径</span></span><br><span class="line"><span class="variable">$destDir</span> = <span class="string">"C:\path\to\your\destination\directory"</span> <span class="comment"># 目标文件夹路径</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Get-ChildItem</span> <span class="variable">$sourceDir</span> -Recurse | <span class="built_in">ForEach-Object</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="variable">$_</span>.PSIsContainer) &#123;</span><br><span class="line">    <span class="variable">$zipFilePath</span> = <span class="built_in">Join-Path</span> -Path <span class="variable">$destDir</span> -ChildPath (<span class="variable">$_</span>.Name + <span class="string">".zip"</span>) <span class="comment"># 压缩文件路径</span></span><br><span class="line">    <span class="built_in">Compress-Archive</span> -Path <span class="variable">$_</span>.FullName -DestinationPath <span class="variable">$zipFilePath</span> <span class="comment"># 压缩文件夹</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>请将 <code>$sourceDir</code> 和 <code>$destDir</code> 替换为你的实际路径。这个脚本会遍历 <code>$sourceDir</code> 中的所有文件和文件夹，如果是文件夹，就将其压缩为 <code>.zip</code> 文件，并保存到 <code>$destDir</code> 中。</p><blockquote><p><strong>画外音：</strong> 实际上我并不需要递归处理，去掉 <code>-Recurse</code> 选项即可。</p></blockquote><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>整个过程很舒服，基本上没写一行代码，只是做了一些改动及细节微调。就把整个功能实现了。整个过程不到 <code>20</code> 分钟。</p><p>关于 <code>Cursor</code> 的用法，也很简单，网上随便一搜就能搜到。<code>ctrl+L</code> 即可开启魔法！</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;缘起&quot;&gt;&lt;a href=&quot;#缘起&quot; class=&quot;headerlink&quot; title=&quot;缘起&quot;&gt;&lt;/a&gt;缘起&lt;/h2&gt;&lt;p&gt;今天查资料的时候，偶然发现了一位国外网友镜像了 &lt;code&gt;TheOleNewThing&lt;/code&gt; 从 &lt;code&gt;2003&lt;/code&gt; 年到 &lt;code&gt;2019&lt;/code&gt; 年的&lt;a href=&quot;https://bytepointer.com/resources/old_new_thing/index.htm&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;博文&lt;/a&gt;，竟然有 &lt;code&gt;5000&lt;/code&gt; 多篇（真是高产）。值得注意的是，微软官方博客中许多链接都已经失效了。为了防止这位网友的镜像链接也失效，我决定赶紧将这些内容下载保存下来。手动保存显然不现实，毕竟有 &lt;code&gt;5000&lt;/code&gt; 多篇文章呢！所以，我决定写脚本来自动下载，这才是明智之举！如果是几年前，我肯定要亲自动手写脚本，不过如今，&lt;code&gt;AI&lt;/code&gt; 这么强大，我无需再费力。幸运的是，我利用 &lt;a href=&quot;https://www.cursor.so/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Cursor&lt;/a&gt; 自动生成下载脚本的全过程，并对其进行了简单的修改，成功地将全部 &lt;code&gt;5000&lt;/code&gt; 多篇文章下载并压缩存档，并按年月分类打包好了！不得不赞叹一句，&lt;code&gt;AI&lt;/code&gt; 真是太强大了。&lt;/p&gt;
    
    </summary>
    
      <category term="AI" scheme="https://bianchengnan.github.io/categories/AI/"/>
    
    
      <category term="原" scheme="https://bianchengnan.github.io/tags/%E5%8E%9F/"/>
    
      <category term="工具" scheme="https://bianchengnan.github.io/tags/%E5%B7%A5%E5%85%B7/"/>
    
      <category term="cursor" scheme="https://bianchengnan.github.io/tags/cursor/"/>
    
      <category term="AI" scheme="https://bianchengnan.github.io/tags/AI/"/>
    
      <category term="TheOldNewThing" scheme="https://bianchengnan.github.io/tags/TheOldNewThing/"/>
    
      <category term="脚本" scheme="https://bianchengnan.github.io/tags/%E8%84%9A%E6%9C%AC/"/>
    
  </entry>
  
</feed>
