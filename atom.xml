<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>BianChengNan&#39;s Blog</title>
  
  <subtitle>Coding is hard, you can make it easy!</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://bianchengnan.github.io/"/>
  <updated>2024-12-21T04:02:50.676Z</updated>
  <id>https://bianchengnan.github.io/</id>
  
  <author>
    <name>BianChengNan</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>置顶声明</title>
    <link href="https://bianchengnan.github.io//articles/top-most-announcement/"/>
    <id>https://bianchengnan.github.io//articles/top-most-announcement/</id>
    <published>2029-03-01T01:29:14.000Z</published>
    <updated>2024-12-21T04:02:50.676Z</updated>
    
    <content type="html"><![CDATA[<p>实在抱歉，因为图片使用的是 <code>http</code> 链接，在 <code>chrome</code> 或者 <code>edge</code> 浏览器中打开本博客的时候，看不到文章中的图片。</p><p>可以在 <code>chrome</code> 中通过 <code>chrome://flags</code> （在 <code>edge</code> 中通过 <code>edge://flags</code>）启用 <code>Insecure origins treated as secure</code>，</p><p>并且把图床地址 <a href="http://resources.bianchengnan.tech" target="_blank" rel="noopener">http://resources.bianchengnan.tech</a> 加入到信任列表的方式查看图片。（非常感谢群友 张帆 的提示）</p><p>整个操作如下图：</p><p><img src="/articles/top-most-announcement/D:%5Chexo-blog%5Csource_posts%5Ctop-most-announcement%5Cenable-show-image-in-chrome.png" alt="enable-show-image-in-chrome"></p><p>如果还不能查看相关图片，请联系我，或者到我的公众号里查看。</p><p>我的个人微信号是 <code>BianChengNan</code>，公众号是 <code>编程难</code>。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;实在抱歉，因为图片使用的是 &lt;code&gt;http&lt;/code&gt; 链接，在 &lt;code&gt;chrome&lt;/code&gt; 或者 &lt;code&gt;edge&lt;/code&gt; 浏览器中打开本博客的时候，看不到文章中的图片。&lt;/p&gt;
&lt;p&gt;可以在 &lt;code&gt;chrome&lt;/code&gt; 中通过 
      
    
    </summary>
    
      <category term="原" scheme="https://bianchengnan.github.io/categories/%E5%8E%9F/"/>
    
    
      <category term="原" scheme="https://bianchengnan.github.io/tags/%E5%8E%9F/"/>
    
  </entry>
  
  <entry>
    <title>基础知识 | 函数基础 5 —— 实战修复虚函数导致的编译错误</title>
    <link href="https://bianchengnan.github.io//articles/function-basics-part5-real-sovle-a-real-virtual-function-compile-error/"/>
    <id>https://bianchengnan.github.io//articles/function-basics-part5-real-sovle-a-real-virtual-function-compile-error/</id>
    <published>2024-12-01T06:37:07.000Z</published>
    <updated>2024-12-21T04:02:50.192Z</updated>
    
    <content type="html"><![CDATA[<h2 id="缘起"><a href="#缘起" class="headerlink" title="缘起"></a>缘起</h2><p>前一阵子，同事遇到了一个奇怪的编译问题，大概情况如下：</p><p><code>classA</code> 是模块 <code>A</code> 中的一个类， <code>classA</code> 没有定义构造函数，其它函数都是导出的。<code>B</code> 模块依赖了 <code>A</code> 模块，并且会调用 <code>classA</code> 的接口。当在 <code>B</code> 模块中添加了实例化 <code>classA</code> 对象的代码的时候，报链接错误，提示找不到 <code>classA</code> 类的某个虚函数。</p><p>我帮忙看过之后发现又是虚函数相关的编译问题（正好最近在总结虚函数相关的问题），这是送上门的素材啊！</p><a id="more"></a><blockquote><p><strong>说明：</strong> 项目代码不方便对外发布，本文所有的代码是我基于实际项目模拟的</p></blockquote><h2 id="示例程序简介"><a href="#示例程序简介" class="headerlink" title="示例程序简介"></a>示例程序简介</h2><p>示例程序由两个工程组成：<strong>主模块</strong>和<strong>接口模块</strong>。</p><ul><li><p>接口模块</p><p>接口模块只提供了头文件 <code>interface.h</code> 和对应的 <code>interface.lib</code> 文件及接口实现文件 <code>interface.dll</code>。头文件内容如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// interface.h</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> DLL_EXPORT_INTERFACE</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DLL_EXPORT_INTERFACE __declspec(dllexport)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DLL_EXPORT_INTERFACE __declspec(dllimport)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">InterfaceBase</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ~InterfaceBase() &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Interface1</span> :</span> <span class="keyword">public</span> InterfaceBase</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">DLL_EXPORT_INTERFACE <span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Test1</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line">    <span class="function">DLL_EXPORT_INTERFACE <span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Test2</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line">    <span class="function">DLL_EXPORT_INTERFACE <span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Test3</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line">    <span class="function">DLL_EXPORT_INTERFACE <span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Test4</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">DLL_EXPORT_INTERFACE InterfaceBase* <span class="title">GetInterface</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>主模块</p><p>主模块会隐式依赖 <code>interface.lib</code>，并通过 <code>GetInterface()</code> 接口获取 <code>Interface1</code> 指针，然后调用其接口。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// InterfaceExe.cpp</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"../Interface/Interface.h"</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Interface1* if1 = <span class="keyword">dynamic_cast</span>&lt;Interface1*&gt;(GetInterface());</span><br><span class="line">    if1-&gt;Test1(<span class="number">0</span>);</span><br><span class="line">    if1-&gt;Test4(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> if2 = Interface1();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>当在 <code>main()</code> 函数中通过 <code>auto if2 = Interface1();</code> 创建 <code>Interface1</code> 类型的对象时，编译器会报链接错误，提示无法解析的外部符号，如下图：</p><p><img src="http://resources.bianchengnan.tech/function-basics-part5-real-sovle-a-real-virtual-function-compile-error/LNK2001.png" alt="LNK2001"></p><h2 id="初步排查"><a href="#初步排查" class="headerlink" title="初步排查"></a>初步排查</h2><p>通过之前总结的几篇文章</p><p><a href="https://bianchengnan.github.io/articles/interesting-cpp-dynamic_cast/">《基础知识 | 有趣的动态转换》</a></p><p><a href="https://bianchengnan.github.io/articles/brief-introduction-to-cpp-virtual-function-and-vtbl/">《基础知识 | C++ 虚函数简介》</a></p><p><a href="https://bianchengnan.github.io/articles/interesting-cpp-dynamic-cast-delete-part/">《基础知识 | c++ 有趣的动态转换之 delete 崩溃探究兼谈基类虚析构的重要性》</a></p><p><a href="https://bianchengnan.github.io/articles/function-basics-part1-difference-between-functions-and-how-to-call-function-across-module/">《基础知识 | 函数基础 1 —— 基本概念 &amp; 如何调用外部模块的函数》</a></p><p><a href="https://bianchengnan.github.io/articles/function-basics-part2-call-function-of-another-module-but-does-not-depend-on-that-module/">《基础知识 | 函数基础 2 —— 如何不依赖外部模块却能调用它的函数？》</a></p><p><a href="https://bianchengnan.github.io/articles/function-basics-part3-call-unexported-virtual-function-of-another-module/">《基础知识 | 函数基础 3 —— 跨模块调用未导出虚函数的各种姿势 》</a></p><p><a href="https://bianchengnan.github.io/articles/function-basics-part4-what-will-happen-if-virtual-function-reordered/">《基础知识 | 函数基础 4 —— 又崩溃了，原来是虚函数声明顺序不一致捣的鬼 》</a></p><p>我对虚函数编译相关的问题有了比较全面的认识。</p><p>头文件中没声明 <code>Interface1</code> 的构造函数，并且 <code>Interface1</code> 包含虚函数，那么编译器会自动生成构造函数代码，与我们手动在头文件中<strong>定义</strong>一个空造函数是一样的。</p><p>在这种情况下，如果想在外部模块实例化 <code>Interface1</code> 的对象，那么 <code>Interface1</code> 所有的虚函数都需要是导出的或者需要在头文件中定义。</p><p>快速扫了一遍头文件，所有虚函数确实都是导出的。这就奇怪了，难道 <code>interface.lib</code> 文件又出问题了？</p><h2 id="查看-lib-文件"><a href="#查看-lib-文件" class="headerlink" title="查看 lib 文件"></a>查看 lib 文件</h2><p>使用 <code>vs</code> 自带的 <code>dumpbin</code> 查看 <code>interface.lib</code> 的导出符号，在命令行中分别输入以下两行命令，即可把 <code>Interface.lib</code> 中的导出符号信息导出到 <code>interface.txt</code> 中。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">set</span> PATH=%PATH%;<span class="string">"C:\Program Files (x86)\Microsoft Visual Studio 10.0\VC\bin\amd64\"</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">dumpbin /EXPORTS Interface.lib &gt; interface.txt</span></span><br></pre></td></tr></table></figure><p>在 <code>interface.txt</code> 中搜索 <code>Test4</code>，结果什么也没所搜到，如下图：</p><p><img src="http://resources.bianchengnan.tech/function-basics-part5-real-sovle-a-real-virtual-function-compile-error/cannot-search-Test4-from-interface-lib.png" alt="cannot-search-Test4-from-interface-lib"></p><p>原来又是头文件与 <code>lib</code> 文件不匹配导致的问题，头文件中包含 <code>Test4</code>，但是对应的 <code>lib</code> 文件中却没有。</p><h2 id="亲自动手"><a href="#亲自动手" class="headerlink" title="亲自动手"></a>亲自动手</h2><p>示例工程已经上传到<a href="https://github.com/BianChengNan/MyBlogStuff/tree/master/function-basics-part5-real-sovle-a-real-virtual-function-compile-error" target="_blank" rel="noopener">这里</a>，感兴趣的小伙伴儿可以自行下载验证。</p><blockquote><p><strong>说明：</strong> 我已经上传了对应的 <code>Interface.lib</code> 及 <code>Interface.dll</code>，如果想重新编译 <code>Interface.vcxproj</code>，需要先注释掉 <code>Interface.h</code> 中包含 <code>Test4</code> 的那一行。编译成功后，如果想像我一样重现链接错误，那么需要在 <code>Interface.h</code> 中把删掉的 <code>Test4</code> 哪一行添加回来并且<strong>只重新编译</strong> <code>InterfaceExe.vcxproj</code>。</p></blockquote><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>如果类构造函数不是导出的，如果想在外部模块实例化类对象，那么类中所有虚函数都需要是导出的</li><li><code>dumpbin</code> 是查看 <code>.lib</code> 或 <code>.dll</code> 文件中导出符号的神兵利器</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;缘起&quot;&gt;&lt;a href=&quot;#缘起&quot; class=&quot;headerlink&quot; title=&quot;缘起&quot;&gt;&lt;/a&gt;缘起&lt;/h2&gt;&lt;p&gt;前一阵子，同事遇到了一个奇怪的编译问题，大概情况如下：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;classA&lt;/code&gt; 是模块 &lt;code&gt;A&lt;/code&gt; 中的一个类， &lt;code&gt;classA&lt;/code&gt; 没有定义构造函数，其它函数都是导出的。&lt;code&gt;B&lt;/code&gt; 模块依赖了 &lt;code&gt;A&lt;/code&gt; 模块，并且会调用 &lt;code&gt;classA&lt;/code&gt; 的接口。当在 &lt;code&gt;B&lt;/code&gt; 模块中添加了实例化 &lt;code&gt;classA&lt;/code&gt; 对象的代码的时候，报链接错误，提示找不到 &lt;code&gt;classA&lt;/code&gt; 类的某个虚函数。&lt;/p&gt;
&lt;p&gt;我帮忙看过之后发现又是虚函数相关的编译问题（正好最近在总结虚函数相关的问题），这是送上门的素材啊！&lt;/p&gt;
    
    </summary>
    
      <category term="基础知识" scheme="https://bianchengnan.github.io/categories/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
    
      <category term="virtual function" scheme="https://bianchengnan.github.io/tags/virtual-function/"/>
    
      <category term="基础知识" scheme="https://bianchengnan.github.io/tags/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
      <category term="函数基础" scheme="https://bianchengnan.github.io/tags/%E5%87%BD%E6%95%B0%E5%9F%BA%E7%A1%80/"/>
    
      <category term="函数" scheme="https://bianchengnan.github.io/tags/%E5%87%BD%E6%95%B0/"/>
    
      <category term="虚函数" scheme="https://bianchengnan.github.io/tags/%E8%99%9A%E5%87%BD%E6%95%B0/"/>
    
      <category term="function" scheme="https://bianchengnan.github.io/tags/function/"/>
    
      <category term="part5" scheme="https://bianchengnan.github.io/tags/part5/"/>
    
      <category term="编译错误" scheme="https://bianchengnan.github.io/tags/%E7%BC%96%E8%AF%91%E9%94%99%E8%AF%AF/"/>
    
  </entry>
  
  <entry>
    <title>基础知识 | 函数基础 4 —— 又崩溃了，原来是虚函数声明顺序不一致捣的鬼</title>
    <link href="https://bianchengnan.github.io//articles/function-basics-part4-what-will-happen-if-virtual-function-reordered/"/>
    <id>https://bianchengnan.github.io//articles/function-basics-part4-what-will-happen-if-virtual-function-reordered/</id>
    <published>2024-11-09T06:37:07.000Z</published>
    <updated>2024-12-21T04:02:50.191Z</updated>
    
    <content type="html"><![CDATA[<h2 id="缘起"><a href="#缘起" class="headerlink" title="缘起"></a>缘起</h2><p>前一阵子，同事遇到了一个崩溃问题，解决后发现这个崩溃是由于在公共类中加了一个虚函数接口，但是并没有编译相关模块导致的。这种崩溃问题是老朋友了。在此之前，我已经写了几篇关于虚函数的总结，感兴趣的小伙伴儿可以查看这几篇文章：</p><p><a href="https://bianchengnan.github.io/articles/interesting-cpp-dynamic_cast/">《基础知识 | 有趣的动态转换》</a></p><p><a href="https://bianchengnan.github.io/articles/brief-introduction-to-cpp-virtual-function-and-vtbl/">《基础知识 | C++ 虚函数简介》</a></p><p><a href="https://bianchengnan.github.io/articles/interesting-cpp-dynamic-cast-delete-part/">《基础知识 | c++ 有趣的动态转换之 delete 崩溃探究兼谈基类虚析构的重要性》</a></p><p><a href="https://bianchengnan.github.io/articles/function-basics-part1-difference-between-functions-and-how-to-call-function-across-module/">《基础知识 | 函数基础 1 —— 基本概念 &amp; 如何调用外部模块的函数》</a></p><p><a href="https://bianchengnan.github.io/articles/function-basics-part2-call-function-of-another-module-but-does-not-depend-on-that-module/">《基础知识 | 函数基础 2 —— 如何不依赖外部模块却能调用它的函数？》</a></p><p><a href="https://bianchengnan.github.io/articles/function-basics-part3-call-unexported-virtual-function-of-another-module/">《基础知识 | 函数基础 3 —— 跨模块调用未导出虚函数的各种姿势 》</a></p><p>本文主要关注以下两个问题，如果你已经有了很明确的答案，可以跳过本文：</p><ul><li>如果在编译 <code>A</code> 模块的时候，<code>Test</code> 类的虚函数声明的顺序是 <code>Test1, Test2, Test3</code>，但是在 <code>B</code> 模块编译的时候，<code>Test</code> 类头文件中虚函数顺序变成了 <code>Test2, Test1, Test3</code>。在 <code>B</code> 模块中调用 <code>test-&gt;Test1()</code>，调用的是哪个函数呢？</li></ul><ul><li>假设 <code>A</code> 模块代码不变，但是在编译 <code>B</code> 模块的时候，<code>Test</code> 类的头文件中又多了一个虚函数 <code>Test4()</code>，在 <code>B</code> 模块中调用 <code>test-&gt;Test4()</code>，代码可以正常编译吗？会有链接问题吗？如果可以正常编译链接，运行的时候会有问题吗？</li></ul><a id="more"></a><p>在开始验证前先回顾一下之前的结论</p><h2 id="一些结论"><a href="#一些结论" class="headerlink" title="一些结论"></a>一些结论</h2><ul><li><p><strong>虚表及虚表中的函数地址会与构造函数存储在同一个模块中</strong>。如果构造函数存在于多个模块中，虚表及虚表中的函数地址也会保存在多个模块中</p></li><li><p>每个包含虚函数的类对象都有一个虚表指针，该指针指向了虚表，会<strong>在类对象的构造函数中初始化</strong></p></li><li><p>虚表中<strong>按顺序</strong>存放了虚函数地址</p></li><li><p>调用虚函数的时候会先获取虚表指针，然后根据虚函数的索引从虚表中得到最终的函数地址进行调用</p></li></ul><p>更多结论请参考 <a href="https://bianchengnan.github.io/articles/function-basics-part3-call-unexported-virtual-function-of-another-module/">上一篇文章</a>。</p><p>回顾完结论后，让我们用测试程序探寻以上两个问题的答案，先来看看示例程序的代码</p><h2 id="示例程序"><a href="#示例程序" class="headerlink" title="示例程序"></a>示例程序</h2><p>示例程序由两个工程组成：<strong>主模块</strong>和<strong>接口模块</strong>。</p><ul><li><p>接口模块</p><p>对应的工程是 <code>Interface.vcxproj</code>。代码很简单，实现了接口，并暴露了一个导出接口供主模块使用</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// interface.h</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> DLL_EXPORT_INTERFACE</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DLL_EXPORT_INTERFACE __declspec(dllexport)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DLL_EXPORT_INTERFACE __declspec(dllimport)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">InterfaceBase</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ~InterfaceBase() &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Interface1</span> :</span> <span class="keyword">public</span> InterfaceBase</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">DLL_EXPORT_INTERFACE <span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Test1</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line">    <span class="function">DLL_EXPORT_INTERFACE <span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Test2</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line">    <span class="function">DLL_EXPORT_INTERFACE <span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Test3</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">DLL_EXPORT_INTERFACE InterfaceBase* <span class="title">GetInterface</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure></li></ul>  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Interface.cpp</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DLL_EXPORT__INTERFACE</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"Interface.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> Interface1::Test1(<span class="keyword">int</span> a)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; __FUNCTION__ &lt;&lt; <span class="string">" : "</span> &lt;&lt; a &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">void</span> Interface1::Test2(<span class="keyword">int</span> a)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; __FUNCTION__ &lt;&lt; <span class="string">" : "</span> &lt;&lt; a &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">void</span> Interface1::Test3(<span class="keyword">int</span> a)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; __FUNCTION__ &lt;&lt; <span class="string">" : "</span> &lt;&lt; a &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">InterfaceBase* <span class="title">GetInterface</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Interface1();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>主模块</p><p>对应的工程是 <code>InterfaceExe.vcxproj</code>。主模块通过<strong>导出接口</strong>和<strong>直接实例化</strong>的方式获取 <code>Interface1</code> 的对象指针，然后调用 <code>Test2()</code>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// InterfaceExe.cpp</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"../Interface/Interface.h"</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Interface1* if1 = <span class="keyword">dynamic_cast</span>&lt;Interface1*&gt;(GetInterface());</span><br><span class="line">    Interface1* if2 = <span class="keyword">new</span> Interface1();</span><br><span class="line">    if1-&gt;Test2(<span class="number">0</span>);</span><br><span class="line">    if2-&gt;Test2(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>以上示例程序编译运行一切正常。接下来<strong>保持接口模块不变</strong>，修改代码后<strong>只重新编译主模块</strong>。</p><h2 id="验证1"><a href="#验证1" class="headerlink" title="验证1"></a>验证1</h2><p>交换 <code>Interface.h</code> 中的 <code>Test2()</code> 和 <code>Test3()</code> 的顺序，修改后的代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Interface1</span> :</span> <span class="keyword">public</span> InterfaceBase</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Test1</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Test3</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Test2</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>只重新编译主模块</strong>，查看运行结果。结果如下：</p><p><img src="http://resources.bianchengnan.tech/function-basics-part4-what-will-happen-if-virtual-function-reordered/swap-test2-test3.png" alt="swap-test2-test3"></p><p>虽然代码里调用的都是 <code>Test2()</code>，但是从输出结果可知：<code>if1</code> 调用的是 <code>Test3()</code>，<code>if2</code> 调用的是 <code>Test2()</code>。</p><p>在 <code>windbg</code> 中分别查看这两个调用对应的反汇编，如下图：</p><p><img src="http://resources.bianchengnan.tech/function-basics-part4-what-will-happen-if-virtual-function-reordered/view-disassembly-of-virtual-function-call.png" alt="view-disassembly-of-virtual-function-call"></p><p>可以发现，调用的都是虚表中索引为 <code>3</code> （<code>0x18 / 0x8 = 3</code>）的函数。分别查看一下虚表</p><p><img src="http://resources.bianchengnan.tech/function-basics-part4-what-will-happen-if-virtual-function-reordered/view-vtable-in-windbg.png" alt="view-vtable-in-windbg"></p><p>可以发现，</p><p><code>if1</code> 对应的虚表存储在 <code>Interface</code> 模块，第 <code>3</code> 项是 <code>Interface!Interface1::Test3</code>；</p><p><code>if2</code> 对应的虚表存储在 <code>InterfaceExe</code> 模块，第 <code>3</code> 项是 <code>InterfaceExe!Interface1::Test2</code>。</p><p>在编译 <code>Interface</code> 模块时，由于 <code>GetInterface()</code> 内部会调用 <code>new Interface1</code>，因此会在 <code>Interface</code> 模块中生成虚表，此时 <code>Test3()</code> 是最后一项。</p><p>在编译 <code>InterfaceExe</code> 模块时，由于会直接调用 <code>new Interface1()</code>，因此会在 <code>InterfaceExe</code> 模块中生成虚表，此时 <code>Test2()</code> 是最后一项。</p><p>在 <code>windbg</code> 中查看  <code>InterfaceExe!Interface1::Test2</code> 对应的反汇编，可以发现其最终会调用 <code>Interface!Interface1::Test2()</code>。</p><p><img src="http://resources.bianchengnan.tech/function-basics-part4-what-will-happen-if-virtual-function-reordered/view-disassembly-of-interfaceexe-interface1-test2.png" alt="view-disassembly-of-interfaceexe-interface1-test2"></p><blockquote><p><strong>思考：</strong> 如果 <code>Test2</code> 和 <code>Test3</code> 的参数个数或者参数类型不一致，是不是会有更严重的问题？</p><p>根据上面的分析可知，从 <code>if1</code> 调用的话会有问题，从 <code>if2</code> 调用的话没问题。</p></blockquote><h2 id="验证-2"><a href="#验证-2" class="headerlink" title="验证 2"></a>验证 2</h2><p>在  <code>Interface.h</code>  中增加一个名为 <code>Test4</code> 的接口，并在 <code>main()</code> 函数中调用之。修改后的代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Interface1</span> :</span> <span class="keyword">public</span> InterfaceBase</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">DLL_EXPORT_INTERFACE <span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Test1</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line">    <span class="function">DLL_EXPORT_INTERFACE <span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Test3</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line">    <span class="function">DLL_EXPORT_INTERFACE <span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Test2</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line">    <span class="function">DLL_EXPORT_INTERFACE <span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Test4</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// InterfaceExe.cpp</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"../Interface/Interface.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Interface1* if1 = <span class="keyword">dynamic_cast</span>&lt;Interface1*&gt;(GetInterface());</span><br><span class="line">    if1-&gt;Test4(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同样，<strong>只重新编译主模块</strong>。可以<strong>正常编译链接</strong>，但是执行的时候遇到了一个异常。</p><p><img src="http://resources.bianchengnan.tech/function-basics-part4-what-will-happen-if-virtual-function-reordered/view-4th-function-in-vtable.png" alt="view-4th-function-in-vtable"></p><p>从上图可知，在 <code>main()</code> 函数调用 <code>Test4()</code> 时，<code>rip</code> 指向了地址 <code>00000003 19930522</code>。因为在重新编译主模块时，<code>Test4()</code> 是虚表中的第 <code>4</code> 项（从 <code>0</code> 开始），而虚表中第 <code>4</code> 项的值是 <code>00000003 19930522</code>。</p><p>因为在编译 <code>Interface.dll</code> 的时候，一共只有 <code>4</code> 项，最大索引是 <code>3</code>。而主模块中的调用代码却尝试访问虚表中的第 <code>4</code> 项，而第 4 项的内容是随机的，所以在执行的时候发生了异常。</p><p>根据以上验证结果可知，<strong>编译器会根据头文件中的顺序生成虚函数调用代码</strong>，如果与虚函数所属模块生成时的顺序不一致，很可能调用的是不同的函数，行为是未定义的。</p><h2 id="亲自动手"><a href="#亲自动手" class="headerlink" title="亲自动手"></a>亲自动手</h2><p>示例工程已经上传到<a href="https://github.com/BianChengNan/MyBlogStuff/tree/master/function-basics-part4-what-will-happen-if-virtual-function-reordered" target="_blank" rel="noopener">这里</a>了，感兴趣的小伙伴儿可以自行下载，根据 <code>验证 1</code> 和 <code>验证 2</code> 中的修改方式手动修改代码，进行验证。</p><blockquote><p><strong>务必注意：</strong> 修改完代码后不要重新编译 <code>Interface</code> 工程，只重新编译 <code>InterfaceExe</code> 工程！</p></blockquote><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li><strong>编译器会根据头文件中的顺序生成虚函数调用代码</strong>，如果与虚函数所属模块生成时的顺序不一致，很可能调用的是不同的函数，行为是未定义的。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;缘起&quot;&gt;&lt;a href=&quot;#缘起&quot; class=&quot;headerlink&quot; title=&quot;缘起&quot;&gt;&lt;/a&gt;缘起&lt;/h2&gt;&lt;p&gt;前一阵子，同事遇到了一个崩溃问题，解决后发现这个崩溃是由于在公共类中加了一个虚函数接口，但是并没有编译相关模块导致的。这种崩溃问题是老朋友了。在此之前，我已经写了几篇关于虚函数的总结，感兴趣的小伙伴儿可以查看这几篇文章：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://bianchengnan.github.io/articles/interesting-cpp-dynamic_cast/&quot;&gt;《基础知识 | 有趣的动态转换》&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://bianchengnan.github.io/articles/brief-introduction-to-cpp-virtual-function-and-vtbl/&quot;&gt;《基础知识 | C++ 虚函数简介》&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://bianchengnan.github.io/articles/interesting-cpp-dynamic-cast-delete-part/&quot;&gt;《基础知识 | c++ 有趣的动态转换之 delete 崩溃探究兼谈基类虚析构的重要性》&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://bianchengnan.github.io/articles/function-basics-part1-difference-between-functions-and-how-to-call-function-across-module/&quot;&gt;《基础知识 | 函数基础 1 —— 基本概念 &amp;amp; 如何调用外部模块的函数》&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://bianchengnan.github.io/articles/function-basics-part2-call-function-of-another-module-but-does-not-depend-on-that-module/&quot;&gt;《基础知识 | 函数基础 2 —— 如何不依赖外部模块却能调用它的函数？》&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://bianchengnan.github.io/articles/function-basics-part3-call-unexported-virtual-function-of-another-module/&quot;&gt;《基础知识 | 函数基础 3 —— 跨模块调用未导出虚函数的各种姿势 》&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;本文主要关注以下两个问题，如果你已经有了很明确的答案，可以跳过本文：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如果在编译 &lt;code&gt;A&lt;/code&gt; 模块的时候，&lt;code&gt;Test&lt;/code&gt; 类的虚函数声明的顺序是 &lt;code&gt;Test1, Test2, Test3&lt;/code&gt;，但是在 &lt;code&gt;B&lt;/code&gt; 模块编译的时候，&lt;code&gt;Test&lt;/code&gt; 类头文件中虚函数顺序变成了 &lt;code&gt;Test2, Test1, Test3&lt;/code&gt;。在 &lt;code&gt;B&lt;/code&gt; 模块中调用 &lt;code&gt;test-&amp;gt;Test1()&lt;/code&gt;，调用的是哪个函数呢？&lt;/li&gt;
&lt;/ul&gt;
&lt;ul&gt;
&lt;li&gt;假设 &lt;code&gt;A&lt;/code&gt; 模块代码不变，但是在编译 &lt;code&gt;B&lt;/code&gt; 模块的时候，&lt;code&gt;Test&lt;/code&gt; 类的头文件中又多了一个虚函数 &lt;code&gt;Test4()&lt;/code&gt;，在 &lt;code&gt;B&lt;/code&gt; 模块中调用 &lt;code&gt;test-&amp;gt;Test4()&lt;/code&gt;，代码可以正常编译吗？会有链接问题吗？如果可以正常编译链接，运行的时候会有问题吗？&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="基础知识" scheme="https://bianchengnan.github.io/categories/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
    
      <category term="virtual function" scheme="https://bianchengnan.github.io/tags/virtual-function/"/>
    
      <category term="基础知识" scheme="https://bianchengnan.github.io/tags/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
      <category term="函数基础" scheme="https://bianchengnan.github.io/tags/%E5%87%BD%E6%95%B0%E5%9F%BA%E7%A1%80/"/>
    
      <category term="函数" scheme="https://bianchengnan.github.io/tags/%E5%87%BD%E6%95%B0/"/>
    
      <category term="虚函数" scheme="https://bianchengnan.github.io/tags/%E8%99%9A%E5%87%BD%E6%95%B0/"/>
    
      <category term="function" scheme="https://bianchengnan.github.io/tags/function/"/>
    
      <category term="part4" scheme="https://bianchengnan.github.io/tags/part4/"/>
    
      <category term="调用约定" scheme="https://bianchengnan.github.io/tags/%E8%B0%83%E7%94%A8%E7%BA%A6%E5%AE%9A/"/>
    
  </entry>
  
  <entry>
    <title>基础知识 | 函数基础 3 —— 跨模块调用未导出虚函数的各种姿势</title>
    <link href="https://bianchengnan.github.io//articles/function-basics-part3-call-unexported-virtual-function-of-another-module/"/>
    <id>https://bianchengnan.github.io//articles/function-basics-part3-call-unexported-virtual-function-of-another-module/</id>
    <published>2024-09-14T06:37:07.000Z</published>
    <updated>2024-12-21T04:02:50.189Z</updated>
    
    <content type="html"><![CDATA[<h2 id="缘起"><a href="#缘起" class="headerlink" title="缘起"></a>缘起</h2><p>在上篇文章 <a href="https://bianchengnan.github.io/articles/function-basics-part2-call-function-of-another-module-but-does-not-depend-on-that-module/">《基础知识 | 函数基础 2 —— 如何不依赖外部模块却能调用它的函数？》</a>中，我们明白了一个事实 —— 可以在不依赖外部模块的情况下通过类对象指针调用其<strong>虚函数</strong>。</p><p>但是遗留了几个问题，如下：</p><ul><li><p>问题 1：<code>Interface1</code> 类中没有声明构造函数，编译器生成的构造函数保存在哪里？<code>GetInterface</code> 模块还是 <code>Interface</code> 模块？</p></li><li><p>问题 2：<code>Interface1</code> 的虚表保存在哪里？<code>GetInterface</code> 模块还是 <code>Interface</code> 模块？</p></li></ul><ul><li><p>问题 3：如果去掉 <code>Interface1</code> 中虚函数的导出符号，上述代码能编译通过吗？</p></li><li><p>问题 4：如果在 <code>Interface1</code>  中声明了未导出的构造函数，上述代码能编译通过吗？</p></li><li><p>问题 5：如果 <code>InterfaceBase::Test1()</code> 不是纯虚函数，上述代码能编译通过吗？</p></li><li><p>问题 6：如果 <code>InterfaceBase</code> 的析构函数不是虚函数，上述代码能编译通过吗？</p></li></ul><p>本文力求把这几个问题弄清楚。如果您对以上问题已经有了答案，可以跳过本文。</p><a id="more"></a><p>我们先简单回顾一下<a href="https://bianchengnan.github.io/articles/function-basics-part2-call-function-of-another-module-but-does-not-depend-on-that-module/">上篇文章</a>中的代码（可以到<a href="https://github.com/BianChengNan/MyBlogStuff/tree/master/function-basics-part2-call-function-of-another-module-but-does-not-depend-on-that-module" target="_blank" rel="noopener">这里</a>下载或查看）：</p><ul><li><p><code>Interface</code> 模块定义了 <code>Interface1</code> 类，并且其接口函数都是导出的。</p></li><li><p><code>GetInterface</code> 模块导出了一个接口，该接口内部会 <code>new Interface1()</code> 并返回。</p></li><li><p><code>InterfaceExe</code> 模块通过 <code>GetInterface</code> 模块的导出接口获得 <code>Interface1</code> 的指针，然后调用其虚函数。</p></li></ul><p>在解答以上几个问题前，我们先查看以下几种情况编译器生成的汇编代码。</p><blockquote><p><strong>说明：</strong> </p><ol><li>本文查看的是 <code>release</code> 版本关闭优化后的汇编代码，比 <code>debug</code> 版本更简洁明了</li><li>下文中提到的 <strong>定义</strong> 指的是函数的声明和实现在一起</li></ol></blockquote><h2 id="情况-1"><a href="#情况-1" class="headerlink" title="情况 1"></a>情况 1</h2><p>注释掉上篇文章代码中对 <code>if1-&gt;Test4(0);</code> 的调用。编译并查看反汇编代码，重点关注构造函数及虚表的存储位置。</p><p><img src="http://resources.bianchengnan.tech/function-basics-part3-call-unexported-virtual-function-of-another-module/case1-getinterface-constructor-vftable.png" alt="case1-getinterface-constructor-vftable"></p><p>可以发现 <code>Interface1</code> 和 <code>InterfaceBase</code> 的构造函数及虚表都存储在 <code>GetInterface</code> 模块中。虚表中的函数也都属于 <code>GetInterface</code> 模块。</p><h2 id="情况-2"><a href="#情况-2" class="headerlink" title="情况 2"></a>情况 2</h2><p>在 <code>情况 1</code> 代码的基础上进行如下修改：</p><ul><li><p>在头文件<strong>定义</strong>构造函数（注意：头文件中既包含声明又包含实现）</p></li><li><p>在头文件<strong>定义</strong>一个名为 <code>Test5()</code> 的虚函数</p></li></ul><p>代码修改如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Interface1</span> :</span> <span class="keyword">public</span> InterfaceBase</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Interface1() &#123;&#125;</span><br><span class="line">    <span class="function">DLL_EXPORT <span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Test1</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line">    <span class="function">DLL_EXPORT <span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Test2</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line">    <span class="function">DLL_EXPORT <span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Test3</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp;)</span></span>;</span><br><span class="line">    <span class="function">DLL_EXPORT <span class="keyword">void</span> <span class="title">Test4</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Test5</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="查看构造函数及虚表"><a href="#查看构造函数及虚表" class="headerlink" title="查看构造函数及虚表"></a>查看构造函数及虚表</h3><p>编译运行，跟踪反汇编代码。可以发现，<code>Interface1</code> 和 <code>InterfaceBase</code> 的构造函数及虚表都存储在 <code>GetInterface</code> 模块中。虚表中的函数也都属于 <code>GetInterface</code> 模块。</p><p><img src="http://resources.bianchengnan.tech/function-basics-part3-call-unexported-virtual-function-of-another-module/case2-getinterface-constructor-vftable.png" alt="case2-getinterface-constructor-vftable"></p><h3 id="查看虚函数汇编代码"><a href="#查看虚函数汇编代码" class="headerlink" title="查看虚函数汇编代码"></a>查看虚函数汇编代码</h3><p>挑几个典型的虚函数，查看其反汇编代码。</p><ul><li>先来看看 <code>InterfaceBase::scalar deleting destructor</code> 的汇编代码。如下图：<br><img src="http://resources.bianchengnan.tech/function-basics-part3-call-unexported-virtual-function-of-another-module/case2-interfacebase-destructor.png" alt="case2-interfacebase-destructor"></li></ul><ul><li>再来看看 <code>Interface1::scalar deleting destructor</code> 的汇编代码。如下图：<br><img src="http://resources.bianchengnan.tech/function-basics-part3-call-unexported-virtual-function-of-another-module/case2-interface1-destructor.png" alt="case2-interface1-destructor"></li></ul><ul><li><p>再来看看 <code>Interface1::Test1()</code> 的汇编代码。如下图：<br><img src="http://resources.bianchengnan.tech/function-basics-part3-call-unexported-virtual-function-of-another-module/case2-interface1-test1.png" alt="case2-interface1-test1"></p><p>可以发现，<code>GetInterface</code> 模块中的 <code>Interface1::Test1()</code> 会调用 <code>Interface</code> 模块导出的  <code>Interface1::Test1()</code>。</p></li></ul><ul><li>再来看看 <code>Interface1::Test5()</code>的汇编代码。如下图：<br><img src="http://resources.bianchengnan.tech/function-basics-part3-call-unexported-virtual-function-of-another-module/case2-interface1-test5.png" alt="case2-interface1-test5"></li></ul><p>以上几个函数有一个共同特点：所有函数的实现代码都在 <code>GetInterface</code> 模块中。我是怎么知道的？根据输出结果判断的，输出结果中，<code>!</code> 前面的部分是模块名。比如，<code>GetInterface!Interface1::Test5</code>，对应的模块是 <code>GetInterface</code>。</p><blockquote><p><strong>小贴士：</strong> 还可以根据 <code>lma address</code> 来查找某个地址所属的模块</p></blockquote><h3 id="两种编译报错的情况"><a href="#两种编译报错的情况" class="headerlink" title="两种编译报错的情况"></a>两种编译报错的情况</h3><ul><li>去掉 <code>Test2()</code> 的导出标识，再编译，会报链接错误，如下图：<br><img src="http://resources.bianchengnan.tech/function-basics-part3-call-unexported-virtual-function-of-another-module/case2-test2-not-export-link-error.png" alt="case2-test2-not-export-link-error"></li></ul><ul><li>如果把 <code>Interface1</code> 的构造函数的定义移动到 <code>Interface.cpp</code> 中，头文件中只保留声明，也会报链接错误，如下图：<br><img src="http://resources.bianchengnan.tech/function-basics-part3-call-unexported-virtual-function-of-another-module/case2-constructor-implement-in-cpp-link-error.png" alt="case2-constructor-implement-in-cpp-link-error"></li></ul><p>  其实，这两个错误有共性：</p><ol><li><p>都没有导出标识</p></li><li><p>实现和声明分离</p><p>实现在 <code>Interface.cpp</code> 中，最终会编译到 <code>Interface</code> 模块，而不是 <code>GetInterface</code> 模块</p></li><li><p>都会被 <code>GetInterface</code> 模块用到</p><ul><li>在 <code>new Interface()</code> 时会调用构造函数</li><li>在构造函数调用时会初始化虚表指针，指向虚表。虚表需要记录 <code>Test2()</code> 的地址，而 <code>Test2()</code> 在 <code>GetInterface</code> 模块中没有实现，没办法确定其地址</li></ul></li></ol><blockquote><p><strong>说明：</strong> <code>情况 1</code> 的构造函数的代码是编译器自动生成的，与 <code>情况 2</code> 的构造函数代码是一样的。</p></blockquote><h2 id="情况-3"><a href="#情况-3" class="headerlink" title="情况 3"></a>情况 3</h2><p>在 <code>情况 2</code> 代码的基础上进行如下修改：</p><ul><li>为构造函数增加导出标识，并且把实现移动到 <code>Interface.cpp</code> 中</li><li>去掉其它函数的导出标识。只保留 <code>Test3()</code> 的导出标识</li></ul><p>代码修改如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Interface.h</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Interface1</span> :</span> <span class="keyword">public</span> InterfaceBase</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">DLL_EXPORT <span class="title">Interface1</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Test1</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Test2</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line">    <span class="function">DLL_EXPORT <span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Test3</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp;)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Test4</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Test5</span><span class="params">()</span> </span>&#123;&#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Interface.cpp</span></span><br><span class="line">Interface1::Interface1()</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="查看构造函数及虚表-1"><a href="#查看构造函数及虚表-1" class="headerlink" title="查看构造函数及虚表"></a>查看构造函数及虚表</h3><p>编译运行，跟踪反汇编代码。可以发现，<code>GetInterface!GetInterface()</code> 调用的构造函数是从 <code>Interface</code> 模块导入的。</p><p><code>Interface1</code> 和 <code>InterfaceBase</code> 的构造函数及虚表都存储在 <code>Interface</code> 模块中，虚表中的函数也都属于 <code>Interface</code> 模块。</p><p><img src="http://resources.bianchengnan.tech/function-basics-part3-call-unexported-virtual-function-of-another-module/case3-getinterface-constructor-vftable.png" alt="case3-getinterface-constructor-vftable"></p><blockquote><p><strong>注意：</strong> </p><ul><li><p>虚表中的所有函数的地址都属于 <code>Interface</code> 模块，与 <code>情况 2</code> 不一样。</p></li><li><p>虽然 <code>Test3()</code> 是导出的，但是虚表中保存的 <code>Test3</code> 的地址是 <code>Interface</code> 模块的。</p></li><li><p>注意 <code>Test5()</code>。在 <code>情况 2</code> 中，虚表中保存的 <code>Test5()</code> 的地址是在 <code>GetInterface</code> 模块中的，而且不会像其它函数一样调用 <code>Interface</code> 模块中的函数。在  <code>情况 3</code> 中，虚表中保存的 <code>Test5()</code> 的地址在 <code>Interface</code> 模块中。</p></li></ul><p>可以猜测，因为构造函数被导出了，没有必要在外部模块创建虚表了。</p></blockquote><h2 id="情况-4"><a href="#情况-4" class="headerlink" title="情况 4"></a>情况 4</h2><p>在 <code>情况 3</code> 代码的基础上进行如下修改：</p><ul><li>去掉所有函数的导出标识</li><li>增加一个名为 <code>ExportInterface</code> 的导出接口，返回 <code>Interface1</code> 对象指针</li><li>修改 <code>GetInterface.cpp</code> 中的 <code>GetInterface</code> 接口，直接调用 <code>ExportInterface()</code></li></ul><p>代码修改如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Interface1.h </span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Interface1</span> :</span> <span class="keyword">public</span> InterfaceBase</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Interface1();</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Test1</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Test2</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Test3</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp;)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Test4</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Test5</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">DLL_EXPORT InterfaceBase* <span class="title">ExportInterface</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Interface1.cpp</span></span><br><span class="line"><span class="function">InterfaceBase* <span class="title">ExportInterface</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Interface1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// GetInterface.cpp</span></span><br><span class="line"><span class="function">InterfaceBase* <span class="title">GetInterface</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ExportInterface();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译运行，跟踪反汇编代码。可以发现，与 <code>情况 3</code> 基本一致。<code>Interface1</code> 和 <code>InterfaceBase</code> 的构造函数及虚表都存储在 <code>Interface</code> 模块中，虚表中的函数也都属于 <code>Interface</code> 模块。</p><p><img src="http://resources.bianchengnan.tech/function-basics-part3-call-unexported-virtual-function-of-another-module/case4-getinterface-constructor-vftable.png" alt="case4-getinterface-constructor-vftable"></p><h2 id="情况-5"><a href="#情况-5" class="headerlink" title="情况 5"></a>情况 5</h2><p>在 <code>情况 2</code> 代码的基础上进行如下修改：</p><ul><li>在 <code>Interface1.h</code> 中声明导出接口 <code>ExportInterface</code></li><li>在 <code>Interface1.cpp</code> 中实现 <code>ExportInterface</code></li><li>在 <code>GetInterface.h</code> 中增加导出接口 <code>GetInterface1</code></li><li>在 <code>GetInterface.cpp</code> 中实现 <code>GetInterface1</code></li><li>在 <code>InterfaceExe.cpp</code> 调用这两个接口得到接口指针</li></ul><p>代码修改如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Interface1.h </span></span><br><span class="line"><span class="function">DLL_EXPORT InterfaceBase* <span class="title">ExportInterface</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Interface1.cpp</span></span><br><span class="line"><span class="function">InterfaceBase* <span class="title">ExportInterface</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Interface1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// GetInterface.h </span></span><br><span class="line"><span class="function">DLL_EXPORT_GET InterfaceBase* <span class="title">GetInterface1</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// GetInterface.cpp</span></span><br><span class="line"><span class="function">InterfaceBase* <span class="title">GetInterface</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Interface1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">InterfaceBase* <span class="title">GetInterface1</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ExportInterface();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    InterfaceBase* base = GetInterface();</span><br><span class="line">    InterfaceBase* base1 = GetInterface1();</span><br><span class="line">    Interface1* if1 = <span class="keyword">dynamic_cast</span>&lt;Interface1*&gt;(base);</span><br><span class="line">    if1-&gt;Test1(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//if1-&gt;Test4(0);</span></span><br><span class="line"></span><br><span class="line">    FreeInterface(if1);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>先来看看，<code>GetInterface()</code> 相关的反汇编代码，如下图：</p><p><img src="http://resources.bianchengnan.tech/function-basics-part3-call-unexported-virtual-function-of-another-module/case5-getinterface-constructor-vftable.png" alt="case5-getinterface-constructor-vftable"></p><p>从上图可以发现，与 <code>情况 2</code> 是一样，<code>Interface1</code> 和 <code>InterfaceBase</code> 的构造函数及虚表都存储在 <code>GetInterface</code> 模块中，虚表中的函数也都属于 <code>GetInterface</code> 模块。</p><p>再来看看 <code>GetInterface1()</code> 相关的反汇编代码，如下图：</p><p><img src="http://resources.bianchengnan.tech/function-basics-part3-call-unexported-virtual-function-of-another-module/case5-getinterface1-constructor-vftable.png" alt="case5-getinterface1-constructor-vftable"></p><p>从上图可以发现，<code>Interface1</code> 和 <code>InterfaceBase</code> 的构造函数及虚表都存储在 <code>Interface</code> 模块中，虚表中的函数也都属于 <code>Interface</code> 模块。</p><p>简单整理如下：</p><ul><li><p><code>GetInterface!GetInterface()</code> 内部会调用 <code>new Interface1</code>，进而导致 <code>Interface1</code> 的构造函数在 <code>GetInterface</code> 模块中被调用。对应的虚表及虚表中的函数地址都存储在 <code>GetInterface</code> 模块中。</p></li><li><p><code>GetInterface!GetInterface1()</code> 内部会调用 <code>Interface!ExportInterface()</code>，而 <code>Interface!ExportInterface()</code> 内部会调用 <code>new Interface1</code>， 最终 <code>Interface1</code> 的构造函数在 <code>Interface</code> 模块中被调用。对应的虚表及虚表中的函数地址都存储在 <code>Interface</code> 模块中。</p></li></ul><p>因此，可以得到这样的结论： <strong>虚表及虚表中的函数地址会跟构造函数存储在同一个模块中</strong>。如果构造函数存在于多个模块中，虚表及虚表中的函数地址也会保存在多个模块中。</p><p>有了以上基础，就可以很顺利的回答之前的问题了，我们依次来看看每个问题。</p><h2 id="答疑"><a href="#答疑" class="headerlink" title="答疑"></a>答疑</h2><ul><li><p>问题 1：<code>Interface1</code> 类中没有声明构造函数，编译器生成的构造函数保存在哪里？<code>GetInterface</code> 模块还是 <code>Interface</code> 模块？</p><p><strong>答：</strong> 参考 <code>情况 1</code>，<code>Interface1</code> 与 <code>InterfaceBase</code> 的构造函数、虚表以及虚表中的函数都保存在  <code>GetInterface</code> 模块中。</p><blockquote><p><strong>小贴士：</strong> 可以推测，如果有另外一个类似 <code>GetInterface</code> 的模块，相应的内容在那个模块中也会生成一份。</p></blockquote></li></ul><ul><li><p>问题 2：<code>Interface1</code> 的虚表保存在哪里？<code>GetInterface</code> 模块还是 <code>Interface</code> 模块？</p><p><strong>答：</strong> 参考 <code>情况 1</code>，虚表与构造函数一样保存在 <code>GetInterface</code> 模块中。</p></li></ul><ul><li><p>问题 3：如果去掉 <code>Interface1</code> 中虚函数的导出符号，上述代码能编译通过吗？</p><p><strong>答：</strong> 不能。参考 <code>情况 2</code> 中提到的两种编译报错的情况。</p><p>在没有声明构造函数的情况下，编译器生成的构造函数代码和虚表都会保存在 <code>GetInterface</code> 模块中。</p><p>在构造函数调用时会初始化虚表指针，指向虚表。虚表需要记录每个虚函数的地址，而这些虚函数在 <code>GetInterface</code> 模块中没有实现，没办法确定其地址，故报链接错误。</p></li></ul><ul><li><p>问题 4：如果在 <code>Interface1</code>  中声明了<strong>未导出</strong>的构造函数，上述代码能编译通过吗？</p><p><strong>答：</strong> 需要根据构造函数定义的位置判断</p><ul><li><p>如果构造函数的定义也在头文件中，则可以正常编译。</p><p>因为编译后构造函数的代码保存在 <code>GetInterface</code> 模块中，不存在跨模块调用问题。</p></li><li><p>如果构造函数的定义在源文件中而且没导出，会报链接错误。</p><p>因为在 <code>GetInterface</code> 模块中调用 <code>new Interface</code> 的时候，会调用 <code>Interface</code> 的构造函数，但是在 <code>GetInterface</code> 模块中找不到其实现代码。</p></li></ul></li></ul><ul><li><p>问题 5：如果 <code>InterfaceBase::Test1()</code> 不是纯虚函数，上述代码能编译通过吗？</p><p><strong>答：</strong> 与 <code>问题 4</code> 一样，需要根据 <code>InterfaceBase::Test1()</code> 定义的位置判断</p><ul><li><p>如果 <code>InterfaceBase::Test1()</code> 的定义也在头文件中，则可以正常编译。</p><p>因为编译后 <code>InterfaceBase::Test1()</code> 的代码保存在 <code>GetInterface</code> 模块中，不存在跨模块调用问题。</p></li><li><p>如果 <code>InterfaceBase::Test1()</code> 的定义在源文件中而且没导出，会报链接错误。</p><p><code>InterfaceBase::Test1()</code> 的实现代码保存在 <code>Interface</code> 模块中。<code>InterfaceBase</code> 的虚表需要记录 <code>InterfaceBase::Test1()</code> 的地址，而 <code>InterfaceBase::Test1()</code> 在 <code>GetInterface</code> 模块中没有实现，没办法确定其地址，会报链接错误。</p></li></ul></li></ul><ul><li><p>问题 6：如果 <code>InterfaceBase</code> 的析构函数不是虚函数，上述代码能编译通过吗？</p><p>答： 与 <code>问题 4</code>、<code>问题 5</code> 一样，需要根据析构函数定义的位置判断</p><ul><li><p>如果析构函数的定义也在头文件中，则可以正常编译。</p><p>因为编译后析构函数的代码保存在 <code>GetInterface</code> 模块中，不存在跨模块调用问题。</p></li><li><p>如果析构函数的定义在源文件中而且没导出，会报链接错误。</p><p>析构函数最终会保存在 <code>Interface</code> 模块中。当调用 <code>GetInterface</code> 模块中的  <code>FreeInterface()</code> 时，该函数内部会调用 <code>delete</code>，而 <code>delete</code> 内部会调用析构函数，但是在 <code>GetInterface</code> 模块中没有实现，会报链接错误。</p></li></ul><blockquote><p><strong>友情提示：</strong> </p><ol><li>如果基类的析构函数是虚函数，子类的析构函数即使不加 <code>virtual</code> 关键字也是虚的！</li><li>如果一个类被设计为基类并且其析构函数是非虚的，这是一个 <code>bad design</code>， 《effective c++》条款 7 中讲过，感兴趣的朋友可以参考</li></ol></blockquote></li></ul><h2 id="亲自动手"><a href="#亲自动手" class="headerlink" title="亲自动手"></a>亲自动手</h2><p>我已经将以上几种情况对应的工程源码上传到个人仓库中了，可以到<a href="https://github.com/BianChengNan/MyBlogStuff/tree/master/function-basics-part3-call-unexported-virtual-function-of-another-module" target="_blank" rel="noopener">这里</a>下载。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol><li><strong>虚表及虚表中的函数地址会与构造函数存储在同一个模块中</strong>。如果构造函数存在于多个模块中，虚表及虚表中的函数地址也会保存在多个模块中</li></ol><ol start="2"><li>如果 <code>classA</code> 所有函数都定义在头文件中，那么 <code>B</code> 模块不需要依赖 <code>A</code> 模块，因为 <code>classA</code> 的所有实现代码都在 <code>B</code> 中了</li></ol><ol start="3"><li><p>在构造函数调用时会初始化虚表指针，指向虚表。必须能解析每个虚函数的地址，否则会报链接错误。</p><p>务必注意报错的时机 —— <strong>在编译构造函数的时候报错，而不是编译虚函数调用代码的时候报错！</strong></p></li></ol><ol start="4"><li><p>如果在 <code>B</code> 模块中已经拿到了 <code>A</code> 模块中 <code>classA</code> 的对象指针，可以在 <code>B</code> 模块调用其虚函数，不需要关心虚函数是否导出。</p><p>既然已经拿到了对象指针，说明构造函数已经成功执行了，虚表已经保存好了虚函数的地址。</p></li></ol><ol start="5"><li><p>如果想在 <code>B</code> 模块中获取 <code>A</code> 模块中 <code>classA</code> 的对象，有两种方法：</p><ol><li><p><code>A</code> 模块导出一个返回 <code>classA</code> 对象的指针的接口，<code>B</code> 模块通过 <code>A</code> 模块的导出接口获取</p></li><li><p>直接在 <code>B</code> 模块中实例化 <code>classA</code> 对象。通过 <code>auto pA = new classA();</code> 或者 <code>classA a;</code></p></li></ol></li></ol><ol start="6"><li><p>如果想在 <code>B</code> 模块中<strong>直接</strong>实例化 <code>A</code> 模块中 <code>classA</code> 的对象，需要能在 <code>B</code> 模块中访问 <code>classA</code> 的构造函数，有两种方法：</p><ol><li><p><code>classA</code> 的构造函数是导出的 <strong>并且</strong> <code>B</code> 模块依赖 <code>A</code> 模块</p></li><li><p><code>classA</code> 的构造函数定义在头文件中（或者不声明构造函数，编译器会自动生成一个）</p></li></ol></li></ol><ol start="7"><li><p>如果 <code>A</code> 模块中 <code>classA</code> 的构造函数是未导出的，并且 <code>classA</code> 中有虚函数，要想在 <code>B</code> 模块中直接实例化 <code>classA</code>，需要满足：</p><ol><li><p>构造函数定义在头文件中</p></li><li><p>虚函数或者<strong>是导出的</strong>或者<strong>定义在头文件中</strong></p></li></ol></li></ol><ol start="8"><li>如果想在 <code>B</code> 模块中调用 <code>A</code> 模块中 <code>classA</code> 的成员函数（例如， <code>delete pA</code> 会调用 <code>classA</code> 的析构函数），那么 <code>classA</code> 的成员函数<ul><li>或者是虚的</li><li>或者是导出的</li><li>或者定义在头文件中</li></ul></li></ol><ol start="9"><li>如果链接错误是由找不到析构函数导致的，删除导致析构函数调用的代码，就不会报错了</li></ol><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p>《effective c++》</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;缘起&quot;&gt;&lt;a href=&quot;#缘起&quot; class=&quot;headerlink&quot; title=&quot;缘起&quot;&gt;&lt;/a&gt;缘起&lt;/h2&gt;&lt;p&gt;在上篇文章 &lt;a href=&quot;https://bianchengnan.github.io/articles/function-basics-part2-call-function-of-another-module-but-does-not-depend-on-that-module/&quot;&gt;《基础知识 | 函数基础 2 —— 如何不依赖外部模块却能调用它的函数？》&lt;/a&gt;中，我们明白了一个事实 —— 可以在不依赖外部模块的情况下通过类对象指针调用其&lt;strong&gt;虚函数&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;但是遗留了几个问题，如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;问题 1：&lt;code&gt;Interface1&lt;/code&gt; 类中没有声明构造函数，编译器生成的构造函数保存在哪里？&lt;code&gt;GetInterface&lt;/code&gt; 模块还是 &lt;code&gt;Interface&lt;/code&gt; 模块？&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;问题 2：&lt;code&gt;Interface1&lt;/code&gt; 的虚表保存在哪里？&lt;code&gt;GetInterface&lt;/code&gt; 模块还是 &lt;code&gt;Interface&lt;/code&gt; 模块？&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;问题 3：如果去掉 &lt;code&gt;Interface1&lt;/code&gt; 中虚函数的导出符号，上述代码能编译通过吗？&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;问题 4：如果在 &lt;code&gt;Interface1&lt;/code&gt;  中声明了未导出的构造函数，上述代码能编译通过吗？&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;问题 5：如果 &lt;code&gt;InterfaceBase::Test1()&lt;/code&gt; 不是纯虚函数，上述代码能编译通过吗？&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;问题 6：如果 &lt;code&gt;InterfaceBase&lt;/code&gt; 的析构函数不是虚函数，上述代码能编译通过吗？&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;本文力求把这几个问题弄清楚。如果您对以上问题已经有了答案，可以跳过本文。&lt;/p&gt;
    
    </summary>
    
      <category term="基础知识" scheme="https://bianchengnan.github.io/categories/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
    
      <category term="virtual function" scheme="https://bianchengnan.github.io/tags/virtual-function/"/>
    
      <category term="基础知识" scheme="https://bianchengnan.github.io/tags/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
      <category term="函数基础" scheme="https://bianchengnan.github.io/tags/%E5%87%BD%E6%95%B0%E5%9F%BA%E7%A1%80/"/>
    
      <category term="函数" scheme="https://bianchengnan.github.io/tags/%E5%87%BD%E6%95%B0/"/>
    
      <category term="虚函数" scheme="https://bianchengnan.github.io/tags/%E8%99%9A%E5%87%BD%E6%95%B0/"/>
    
      <category term="function" scheme="https://bianchengnan.github.io/tags/function/"/>
    
      <category term="跨模块调用" scheme="https://bianchengnan.github.io/tags/%E8%B7%A8%E6%A8%A1%E5%9D%97%E8%B0%83%E7%94%A8/"/>
    
      <category term="调用约定" scheme="https://bianchengnan.github.io/tags/%E8%B0%83%E7%94%A8%E7%BA%A6%E5%AE%9A/"/>
    
      <category term="part3" scheme="https://bianchengnan.github.io/tags/part3/"/>
    
  </entry>
  
  <entry>
    <title>基础知识 | 函数基础 2 —— 如何不依赖外部模块却能调用它的函数？</title>
    <link href="https://bianchengnan.github.io//articles/function-basics-part2-call-function-of-another-module-but-does-not-depend-on-that-module/"/>
    <id>https://bianchengnan.github.io//articles/function-basics-part2-call-function-of-another-module-but-does-not-depend-on-that-module/</id>
    <published>2024-07-27T06:37:07.000Z</published>
    <updated>2024-12-21T04:02:50.188Z</updated>
    
    <content type="html"><![CDATA[<h2 id="缘起"><a href="#缘起" class="headerlink" title="缘起"></a>缘起</h2><p>前一段日子，同事遇到了一个奇怪的现象 —— <code>B</code> 模块调用了 <code>A</code> 模块某个类的成员函数，没有依赖 <code>A</code> 模块，编译时没有报错。而 <code>C</code> 模块也调用了 <code>A</code> 模块中同一个类的成员函数，没有依赖 <code>A</code> 模块，编译时却报了链接错误。</p><p>简单语音沟通后觉得不太可能。用了 <code>A</code> 模块的函数，却不依赖 <code>A</code> 模块，有点儿不讲道理！</p><p>因为当时我没在电脑前，跟同事简单沟通了几个可以设置库依赖的位置，结果都没有发现对应的依赖项。</p><p>心里越发觉得不可思议，难道 <code>B</code> 模块是通过其它方式依赖 <code>A</code> 模块的？正常情况下，如果 <code>B</code> 模块依赖 <code>A</code> 模块，一定可以在 <code>B</code> 模块的导入表中看到 <code>A</code> 模块相关的记录。于是建议同事查看 <code>B</code> 模块的导入表，但是同事不太熟悉。因为项目比较急，遂建议同事在 <code>C</code> 模块中添加对 <code>A</code> 模块的依赖，先解决项目问题，后面有机会再调查具体原因。</p><p>直到最近才有时间调查这个问题，结果发现这个问题非常有意思 —— <code>B</code> 模块确实没有依赖 <code>A</code> 模块（<code>B</code> 模块的导入表中确实没发现 <code>A</code> 模块的相关项），但是 <code>B</code> 模块确实调用了 <code>A</code> 模块中的函数，而且不是通过 <code>LoadLibrary() + GetProcAddress()</code> 的方式调用的。</p><p>本文主要关注以下问题，如果你已经有了答案，可以跳过本文。</p><ul><li><code>B</code> 模块在什么情况下可以调用 <code>A</code> 模块中的函数，但是却不依赖 <code>A</code> 模块？</li></ul><a id="more"></a><blockquote><p><strong>约定：</strong></p><ol><li><p>本文不考虑通过 <code>GetProcAddress()</code> 获取函数指针后再调用的情况</p></li><li><p>虚函数表在本文中简称<strong>虚表</strong>，指向虚表的指针简称<strong>虚表指针</strong></p></li></ol></blockquote><p>为了更好的研究这个问题，我特意写了示例程序</p><h2 id="示例程序"><a href="#示例程序" class="headerlink" title="示例程序"></a>示例程序</h2><p>示例程序由三个工程组成：接口模块、获取接口模块和主模块。</p><ul><li><p>接口模块 </p><p>对应的工程是 <code>Interface.vcxproj</code>，代码很简单，声明并实现了一些接口</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Interface.h</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> DLL_INTERFACE_EXPORT</span></span><br><span class="line">  <span class="meta">#<span class="meta-keyword">define</span> DLL_EXPORT __declspec(dllimport)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">  <span class="meta">#<span class="meta-keyword">define</span> DLL_EXPORT __declspec(dllexport)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">InterfaceBase</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Test1</span><span class="params">(<span class="keyword">int</span>)</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">virtual</span> ~InterfaceBase() &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Interface1</span> :</span> <span class="keyword">public</span> InterfaceBase</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">DLL_EXPORT <span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Test1</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line">    <span class="function">DLL_EXPORT <span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Test2</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line">    <span class="function">DLL_EXPORT <span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Test3</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp;)</span></span>;</span><br><span class="line">    <span class="function">DLL_EXPORT <span class="keyword">void</span> <span class="title">Test4</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">  <span class="comment">// Interface.cpp</span></span><br><span class="line">  <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line">  </span><br><span class="line">  <span class="meta">#<span class="meta-keyword">define</span> DLL_INTERFACE_EXPORT</span></span><br><span class="line">  </span><br><span class="line">  <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"Interface.h"</span></span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">void</span> Interface1::Test1(<span class="keyword">int</span> a)</span><br><span class="line">  &#123;</span><br><span class="line">      <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; __FUNCTION__ &lt;&lt; <span class="string">" : "</span> &lt;&lt; a &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">void</span> Interface1::Test2(<span class="keyword">int</span> a)</span><br><span class="line">  &#123;</span><br><span class="line">      <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; __FUNCTION__ &lt;&lt; <span class="string">" : "</span> &lt;&lt; a &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">void</span> Interface1::Test3(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; a)</span><br><span class="line">  &#123;</span><br><span class="line">      <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; __FUNCTION__ &lt;&lt; <span class="string">" : "</span> &lt;&lt; a &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">void</span> Interface1::Test4(<span class="keyword">int</span> a)</span><br><span class="line">  &#123;</span><br><span class="line">      <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; __FUNCTION__ &lt;&lt; <span class="string">" : "</span> &lt;&lt; a &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">- 获取接口模块</span><br><span class="line"></span><br><span class="line">  对应的工程是 `GetInterface.vcxproj`，依赖**接口模块**。代码非常简单，只暴露了一个接口，用来获取接口对象指针</span><br><span class="line"></span><br><span class="line">  ```c++</span><br><span class="line">  <span class="comment">// GetInterface.h</span></span><br><span class="line">  <span class="meta">#<span class="meta-keyword">pragma</span> once</span></span><br><span class="line">  <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"../Interface/Interface.h"</span></span></span><br><span class="line">  </span><br><span class="line">  <span class="meta">#<span class="meta-keyword">ifndef</span> DLL_GETINTERFACE_EXPORT</span></span><br><span class="line">  <span class="meta">#<span class="meta-keyword">define</span> DLL_EXPORT_GET __declspec(dllimport)</span></span><br><span class="line">  <span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">  <span class="meta">#<span class="meta-keyword">define</span> DLL_EXPORT_GET __declspec(dllexport)</span></span><br><span class="line">  <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">  </span><br><span class="line">  <span class="function">DLL_EXPORT_GET InterfaceBase* <span class="title">GetInterface</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="function">DLL_EXPORT_GET <span class="keyword">void</span> <span class="title">FreeInterface</span><span class="params">(InterfaceBase*)</span></span>;</span><br></pre></td></tr></table></figure></li></ul>  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// GetInterface.cpp</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DLL_GETINTERFACE_EXPORT</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"GetInterface.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">InterfaceBase* <span class="title">GetInterface</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Interface1();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FreeInterface</span><span class="params">(InterfaceBase* if1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">delete</span> if1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>主模块</p><p>对应的工程是 <code>InterfaceExe.vcxproj</code>，只依赖<strong>获取接口模块</strong>，不依赖<strong>接口模块</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// InterfaceExe.cpp</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"../GetInterface/GetInterface.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    InterfaceBase* base = GetInterface();</span><br><span class="line">    Interface1* if1 = <span class="keyword">dynamic_cast</span>&lt;Interface1*&gt;(base);</span><br><span class="line">    if1-&gt;Test1(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    if1-&gt;Test4(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    FreeInterface(if1);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>示例工程已经上传到本篇博客对应的资料仓库里，感兴趣的小伙伴儿可以自行到<a href="https://github.com/BianChengNan/MyBlogStuff/tree/master/function-basics-part2-call-function-of-another-module-but-does-not-depend-on-that-module" target="_blank" rel="noopener">这里</a>下载验证。</p><p>在以上代码中：</p><ol><li><p><code>if1-&gt;Test4()</code> <strong>会</strong>导致链接错误</p><p>报错信息如下：</p><p><code>LNK2019 无法解析的外部符号 &quot;__declspec(dllimport) public: void __cdecl Interface1::Test4(int)&quot; (__imp_?Test4@Interface1@@QEAAXH@Z)，该符号在函数 main 中被引用</code></p></li></ol><ol start="2"><li><p><code>if1-&gt;Test1()</code> <strong>不会</strong>导致链接错误。惊不惊喜？意不意外？</p><p>注释掉 <code>if1-&gt; Test4();</code> 即可顺利编译，所以可以确定 <code>if1-&gt;Test1()</code> 不会导致链接错误</p></li></ol><p>在解释之前，先回顾一下基础。</p><h2 id="基础回顾"><a href="#基础回顾" class="headerlink" title="基础回顾"></a>基础回顾</h2><p>我之前写过一篇关于函数基础知识的总结—— <a href="https://bianchengnan.github.io/articles/how-to-view-startup-function-from-a-deep-recursive-stack-continue/function-basics-part1-difference-between-functions-and-how-to-call-function-across-module/">《基础知识 | 函数基础 1 —— 基本概念 &amp; 如何调用外部模块的函数》</a></p><p>与当前问题相关的内容整理如下：</p><ul><li><p><code>B</code> 模块要想调用 <code>A</code> 模块中的函数，最重要的原则是：<code>B</code> 模块要能找到 <code>A</code> 模块函数的地址，一般情况下需要做两件事：</p><p><strong>首先</strong>，<code>A</code> 模块中的函数需要声明为导出的。导出的函数会记录在 <code>A</code> 模块的<strong>导出表</strong>中</p><p><strong>其次</strong>，通过头文件 + 库文件，让 <code>B</code> 模块依赖 <code>A</code> 模块。编译器会在 <code>B</code> 模块的<strong>导入表</strong>中添加对应项</p></li></ul><ul><li><p>每个包含虚函数的类对象都有一个虚表指针，该指针指向了虚表，会<strong>在类对象的构造函数中初始化</strong></p></li><li><p>虚表中<strong>按顺序</strong>存放了虚函数地址</p></li><li><p>虚函数调用是通过<strong>虚表</strong>实现的。大体调用过程如下：</p><ul><li><p>通过类对象找到虚表指针，进而找到虚表</p></li><li><p>根据头文件中虚函数的顺序得到索引</p></li><li><p>根据索引从虚表中取出函数地址进行调用</p></li></ul></li></ul><h2 id="简单解释"><a href="#简单解释" class="headerlink" title="简单解释"></a>简单解释</h2><p>下面我们尝试从虚函数的调用机制来理解编译器的行为：</p><ol><li><code>if1-&gt;Test4()</code> <strong>会</strong>导致链接错误<br>因为 <code>Test4()</code> 是普通成员函数，调用的时候，需要找到其地址。接口模块虽然导出了 <code>Test4()</code>，但是主模块并没有依赖接口模块。所以报链接错误很正常！</li></ol><ol start="2"><li><p><code>if1-&gt;Test1()</code> <strong>不会</strong>导致链接错误</p><p>已经得到了对象指针（<code>if1</code>），说明对象已经被构造好了，虚表指针已经指向了正确的虚表。因为 <code>Test1()</code> 是虚函数，调用 <code>Test1()</code> 是通过虚表进行的，直接到虚表对应的位置获取函数地址即可。 所以不会产生链接错误。</p></li></ol><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li><p>如果 <code>B</code> 模块已经拿到了 <code>A</code> 模块中的类对象指针，通过该指针调用的类成员函数，</p><ul><li><p>如果调用的成员函数是<strong>普通函数</strong>，则 <code>B</code> 模块<strong>需要</strong>依赖 <code>A</code> 模块</p></li><li><p>如果调用的成员函数是<strong>虚函数</strong>，则 <code>B</code> 模块<strong>不需要</strong>依赖 <code>A</code> 模块</p></li></ul></li></ul><p>实际项目中遇到的正是这种情况：<code>B</code> 模块调用的是 <code>A</code> 模块中的虚函数，所以不需要依赖 <code>A</code> 模块；而 <code>C</code> 模块调用的是 <code>A</code> 模块中的普通成员函数，需要依赖 <code>A</code> 模块。至此，项目中的疑问算是彻底解开了。</p><p>这就完了？ 还有很多问题需要继续深挖……</p><h2 id="More"><a href="#More" class="headerlink" title="More"></a>More</h2><ul><li><p>问题 1：<code>Interface1</code> 类中没有声明构造函数，编译器生成的构造函数保存在哪里？<code>GetInterface</code> 模块还是 <code>Interface</code> 模块？</p></li><li><p>问题 2：<code>Interface1</code> 的虚表保存在哪里？<code>GetInterface</code> 模块还是 <code>Interface</code> 模块？</p></li><li><p>问题 3：如果去掉 <code>Interface1</code> 中虚函数的导出符号，上述代码能编译通过吗？</p></li><li><p>问题 4：如果在 <code>Interface1</code>  中声明了未导出的构造函数，上述代码能编译通过吗？</p></li><li><p>问题 5：如果 <code>InterfaceBase::Test1()</code> 不是纯虚函数，上述代码能编译通过吗？</p></li><li><p>问题 6：如果 <code>InterfaceBase</code> 的析构函数不是虚函数，上述代码能编译通过吗？</p></li></ul><p>争取在下一篇文章中把上面的坑都填上，<code>stay tuned~</code></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;缘起&quot;&gt;&lt;a href=&quot;#缘起&quot; class=&quot;headerlink&quot; title=&quot;缘起&quot;&gt;&lt;/a&gt;缘起&lt;/h2&gt;&lt;p&gt;前一段日子，同事遇到了一个奇怪的现象 —— &lt;code&gt;B&lt;/code&gt; 模块调用了 &lt;code&gt;A&lt;/code&gt; 模块某个类的成员函数，没有依赖 &lt;code&gt;A&lt;/code&gt; 模块，编译时没有报错。而 &lt;code&gt;C&lt;/code&gt; 模块也调用了 &lt;code&gt;A&lt;/code&gt; 模块中同一个类的成员函数，没有依赖 &lt;code&gt;A&lt;/code&gt; 模块，编译时却报了链接错误。&lt;/p&gt;
&lt;p&gt;简单语音沟通后觉得不太可能。用了 &lt;code&gt;A&lt;/code&gt; 模块的函数，却不依赖 &lt;code&gt;A&lt;/code&gt; 模块，有点儿不讲道理！&lt;/p&gt;
&lt;p&gt;因为当时我没在电脑前，跟同事简单沟通了几个可以设置库依赖的位置，结果都没有发现对应的依赖项。&lt;/p&gt;
&lt;p&gt;心里越发觉得不可思议，难道 &lt;code&gt;B&lt;/code&gt; 模块是通过其它方式依赖 &lt;code&gt;A&lt;/code&gt; 模块的？正常情况下，如果 &lt;code&gt;B&lt;/code&gt; 模块依赖 &lt;code&gt;A&lt;/code&gt; 模块，一定可以在 &lt;code&gt;B&lt;/code&gt; 模块的导入表中看到 &lt;code&gt;A&lt;/code&gt; 模块相关的记录。于是建议同事查看 &lt;code&gt;B&lt;/code&gt; 模块的导入表，但是同事不太熟悉。因为项目比较急，遂建议同事在 &lt;code&gt;C&lt;/code&gt; 模块中添加对 &lt;code&gt;A&lt;/code&gt; 模块的依赖，先解决项目问题，后面有机会再调查具体原因。&lt;/p&gt;
&lt;p&gt;直到最近才有时间调查这个问题，结果发现这个问题非常有意思 —— &lt;code&gt;B&lt;/code&gt; 模块确实没有依赖 &lt;code&gt;A&lt;/code&gt; 模块（&lt;code&gt;B&lt;/code&gt; 模块的导入表中确实没发现 &lt;code&gt;A&lt;/code&gt; 模块的相关项），但是 &lt;code&gt;B&lt;/code&gt; 模块确实调用了 &lt;code&gt;A&lt;/code&gt; 模块中的函数，而且不是通过 &lt;code&gt;LoadLibrary() + GetProcAddress()&lt;/code&gt; 的方式调用的。&lt;/p&gt;
&lt;p&gt;本文主要关注以下问题，如果你已经有了答案，可以跳过本文。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;B&lt;/code&gt; 模块在什么情况下可以调用 &lt;code&gt;A&lt;/code&gt; 模块中的函数，但是却不依赖 &lt;code&gt;A&lt;/code&gt; 模块？&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="基础知识" scheme="https://bianchengnan.github.io/categories/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
    
      <category term="virtual function" scheme="https://bianchengnan.github.io/tags/virtual-function/"/>
    
      <category term="part2" scheme="https://bianchengnan.github.io/tags/part2/"/>
    
      <category term="基础知识" scheme="https://bianchengnan.github.io/tags/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
      <category term="函数基础" scheme="https://bianchengnan.github.io/tags/%E5%87%BD%E6%95%B0%E5%9F%BA%E7%A1%80/"/>
    
      <category term="函数" scheme="https://bianchengnan.github.io/tags/%E5%87%BD%E6%95%B0/"/>
    
      <category term="虚函数" scheme="https://bianchengnan.github.io/tags/%E8%99%9A%E5%87%BD%E6%95%B0/"/>
    
      <category term="function" scheme="https://bianchengnan.github.io/tags/function/"/>
    
      <category term="跨模块调用" scheme="https://bianchengnan.github.io/tags/%E8%B7%A8%E6%A8%A1%E5%9D%97%E8%B0%83%E7%94%A8/"/>
    
      <category term="调用约定" scheme="https://bianchengnan.github.io/tags/%E8%B0%83%E7%94%A8%E7%BA%A6%E5%AE%9A/"/>
    
  </entry>
  
  <entry>
    <title>基础知识 | 函数基础 1 —— 基本概念 &amp; 如何调用外部模块的函数</title>
    <link href="https://bianchengnan.github.io//articles/function-basics-part1-difference-between-functions-and-how-to-call-function-across-module/"/>
    <id>https://bianchengnan.github.io//articles/function-basics-part1-difference-between-functions-and-how-to-call-function-across-module/</id>
    <published>2024-07-12T20:37:07.000Z</published>
    <updated>2024-12-21T04:02:50.187Z</updated>
    
    <content type="html"><![CDATA[<h2 id="缘起"><a href="#缘起" class="headerlink" title="缘起"></a>缘起</h2><p>最近遇到了几个跟虚函数有关的问题，既有编译链接问题，又有运行问题，归根到底是基本功不扎实导致的问题。本文将会简单梳理一下函数相关的基本知识：</p><ul><li>函数是什么？</li><li>函数调用约定有哪些？有什么作用？</li><li>普通函数、类静态函数、类成员函数的区别是什么？</li><li>什么时候会调用构造函数，什么时候会调用析构函数？</li><li>调用虚函数与调用其它函数的区别是什么？</li><li><code>B</code> 模块如何调用 <code>A</code> 模块的函数？</li></ul><p>本文适合初学者，如果您已经有一定的开发经验，可以跳过本文。</p><a id="more"></a><h2 id="函数是什么？"><a href="#函数是什么？" class="headerlink" title="函数是什么？"></a>函数是什么？</h2><p>函数其实就是<strong>一段可以被 <code>CPU</code> 执行的二进制代码</strong>。一般情况下，函数编译后的二进制代码会被存储在可执行文件（又叫 <code>Portable Executive</code>，简称  <code>PE</code> ）的代码段中，程序启动时会加载到内存中。</p><p>有几个关键点需要牢记于心：</p><ol><li>每个函数的二进制代码都会存储在对应的模块中，相对模块基址一定的偏移处</li><li>模块加载到内存后会占据一段内存空间，这段内存空间中包含当前模块的函数、全局变量等</li><li>函数的虚拟地址是由 <strong>模块基址+函数相对于模块基址的偏移</strong> 决定的</li><li><strong>模块中函数地址相对于模块基址的偏移不会改变</strong>，模块的基址发生变化后，函数地址也会跟着变</li></ol><p>下图是用 <code>IDA</code> 查看 <code>ntoskrnl.exe</code> 中的函数情况。</p><p><img src="http://resources.bianchengnan.tech/function-basics-part1-difference-between-functions-and-how-to-call-function-across-module/functions-in-module.png" alt="functions-in-module"></p><p><code>ntoskrnl.exe</code> 的基址是 <code>0x00000001 40000000</code>，每个函数相对于模块有一定的偏移。比如，<code>NtSetEvent</code> 相对于模块基址的偏移是 <code>0x00000001 406B2B60 - 0x00000001 40000000 = 0x006B2B60</code>。</p><p>如果下次启动的时候，<code>ntoskrnl.exe</code> 基址变了，<code>NtSetEvent</code> 的地址也会跟着变，但是相对于模块基址的偏移不会变。</p><h2 id="函数调用约定"><a href="#函数调用约定" class="headerlink" title="函数调用约定"></a>函数调用约定</h2><p>函数调用约定有哪些？有什么作用？</p><p>在 <code>c++</code> 中，常用的调用约定有  <code>__cdecl</code>，<code>__stdcall</code>， <code>__fastcall</code>， <code>__thiscall</code>。</p><p><code>__cdecl</code> 是 <code>vs</code> 工程属性中默认的调用约定（可以在 <code>vs</code> 工程属性中设置，如下图），<code>__thiscall</code> 是类成员函数默认的调用约定，<code>Windows API</code> 一般会显式使用 <code>__stdcall</code>。</p><p><img src="http://resources.bianchengnan.tech/function-basics-part1-difference-between-functions-and-how-to-call-function-across-module/set-default-calling-convention.png" alt="set-default-calling-convention"></p><p>调用约定的主要作用：</p><ul><li>影响函数名称，每种调用约定生成的函数名称不一样</li><li>影响参数传递方式</li><li>影响谁来平衡调用栈（调用者还是被调用者）</li></ul><h3 id="x86-程序"><a href="#x86-程序" class="headerlink" title="x86 程序"></a>x86 程序</h3><p>在 <code>x86</code> 程序中有各种调用约定，我简单的整理成了表格，如下：</p><table><thead><tr><th>调用约定</th><th>参数传递方式</th><th>谁来平衡堆栈</th></tr></thead><tbody><tr><td><a href="https://learn.microsoft.com/en-us/cpp/cpp/cdecl?view=msvc-160" target="_blank" rel="noopener">__cdecl</a></td><td>所有参数通过栈传递，从右向左依次入栈，<code>ebp + 8</code> 指向第一个参数</td><td>调用者</td></tr><tr><td><a href="https://learn.microsoft.com/en-us/cpp/cpp/stdcall?view=msvc-160" target="_blank" rel="noopener">__stdcall</a></td><td>与 <code>__cdecl</code> 调用约定一样</td><td>被调用者</td></tr><tr><td><a href="https://learn.microsoft.com/en-us/cpp/cpp/fastcall?view=msvc-160" target="_blank" rel="noopener">__fastcall</a></td><td>前两个 <code>DWORD</code> 类型的参数通过 <code>ecx</code>, <code>edx</code> 传递，其余参数从右向左依次入栈</td><td>被调用者</td></tr><tr><td><a href="https://learn.microsoft.com/en-us/cpp/cpp/thiscall?view=msvc-160" target="_blank" rel="noopener">__thiscall</a></td><td>对象指针通过 <code>ecx</code> 传递，其余参数与 <code>__cdecl</code> 调用约定一样通过栈传递</td><td>被调用者</td></tr></tbody></table><blockquote><p><strong>说明：</strong> <a href="https://learn.microsoft.com/en-us/cpp/cpp/argument-passing-and-naming-conventions?view=msvc-160" target="_blank" rel="noopener">MSDN 官方文档</a> 提到了更多种调用约定，感兴趣的小伙伴儿可以自行查看</p></blockquote><p>​                                                                                                                                                                                                                                                                                                                                         关于名字修饰规则可以参考《软件调试》第 <code>1</code> 版 第 <code>25</code> 章，<code>740</code> 页。</p><blockquote><p><strong>小贴士：</strong> 可以使用 <code>vs</code> 自带的工具 <code>undname.exe</code> 查看修饰前的函数名</p></blockquote><h3 id="x64-程序"><a href="#x64-程序" class="headerlink" title="x64 程序"></a>x64 程序</h3><p>在 <code>x64</code> 程序中只有一种调用约定 —— <code>__fastcall</code>。即使显式指定了调用约定，最后也会按 <code>__fastcall</code> 生成代码。</p><p>参数传递方式如下表（摘录自<a href="https://learn.microsoft.com/en-us/cpp/build/x64-calling-convention?view=msvc-160" target="_blank" rel="noopener">MSDN 官方文档</a>）：</p><table><thead><tr><th align="left">Parameter type</th><th align="left">fifth and higher</th><th align="left">fourth</th><th align="left">third</th><th align="left">second</th><th align="right">leftmost</th></tr></thead><tbody><tr><td align="left">floating-point</td><td align="left">stack</td><td align="left">XMM3</td><td align="left">XMM2</td><td align="left">XMM1</td><td align="right">XMM0</td></tr><tr><td align="left">integer</td><td align="left">stack</td><td align="left">R9</td><td align="left">R8</td><td align="left">RDX</td><td align="right">RCX</td></tr><tr><td align="left">Aggregates (8, 16, 32, or 64 bits) and <strong><code>__m64</code></strong></td><td align="left">stack</td><td align="left">R9</td><td align="left">R8</td><td align="left">RDX</td><td align="right">RCX</td></tr><tr><td align="left">Other aggregates, as pointers</td><td align="left">stack</td><td align="left">R9</td><td align="left">R8</td><td align="left">RDX</td><td align="right">RCX</td></tr><tr><td align="left"><strong><code>__m128</code></strong>, as a pointer</td><td align="left">stack</td><td align="left">R9</td><td align="left">R8</td><td align="left">RDX</td><td align="right">RCX</td></tr></tbody></table><p>各种典型情况下参数传递方式列举如下（摘录自同一个 <a href="https://learn.microsoft.com/en-us/cpp/build/x64-calling-convention?view=msvc-160" target="_blank" rel="noopener">MSDN 官方文档</a>，注释按习惯调整到上方了）：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// a in RCX, b in RDX, c in R8, d in R9, f then e pushed on stack</span></span><br><span class="line">func1(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> c, <span class="keyword">int</span> d, <span class="keyword">int</span> e, <span class="keyword">int</span> f);</span><br><span class="line"></span><br><span class="line"><span class="comment">// a in XMM0, b in XMM1, c in XMM2, d in XMM3, f then e pushed on stack</span></span><br><span class="line">func2(<span class="keyword">float</span> a, <span class="keyword">double</span> b, <span class="keyword">float</span> c, <span class="keyword">double</span> d, <span class="keyword">float</span> e, <span class="keyword">float</span> f);</span><br><span class="line"></span><br><span class="line"><span class="comment">// a in RCX, b in XMM1, c in R8, d in XMM3, f then e pushed on stack</span></span><br><span class="line">func3(<span class="keyword">int</span> a, <span class="keyword">double</span> b, <span class="keyword">int</span> c, <span class="keyword">float</span> d, <span class="keyword">int</span> e, <span class="keyword">float</span> f);</span><br><span class="line"></span><br><span class="line"><span class="comment">// a in RCX, ptr to b in RDX, ptr to c in R8, d in XMM3,</span></span><br><span class="line"><span class="comment">// ptr to f pushed on stack, then ptr to e pushed on stack</span></span><br><span class="line">func4(__m64 a, __m128 b, struct c, <span class="keyword">float</span> d, __m128 e, __m128 f);</span><br></pre></td></tr></table></figure><h2 id="各种类型的函数比较"><a href="#各种类型的函数比较" class="headerlink" title="各种类型的函数比较"></a>各种类型的函数比较</h2><p>普通函数、类静态函数、类成员函数的区别是什么？</p><p>平时开发过程中，经常遇到的函数有普通函数、类静态成员函数、类成员函数（构造函数、析构函数等）。</p><p>它们的共同特点是：它们都是函数，编译后都是<strong>一段可以被 <code>CPU</code> 执行的二进制代码</strong>，都会保存在某个模块中。</p><p>它们最主要的区别在调用的写法上：</p><ul><li><p>调用普通函数，直接通过函数名即可</p></li><li><p>构造函数、析构函数会被自动调用</p><blockquote><p><strong>说明：</strong> 虽然是自动调用，其实是编译器生成了调用代码，不用我们手动写而已</p></blockquote></li><li><p>调用类成员函数的时候，需要通过类对象或类对象指针进行调用</p></li><li><p>调用类静态成员函数的时候需要加上类名限定</p><blockquote><p><strong>说明：</strong> 也可以通过类对象或类对象指针进行调用，编译器会自动推断类型</p></blockquote></li></ul><p>以下示例代码展示了这三种函数的调用方式：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CDemo</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">T1</span><span class="params">(<span class="keyword">int</span>)</span> </span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">T2</span><span class="params">(<span class="keyword">int</span>)</span> </span>&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">T1</span><span class="params">(<span class="keyword">int</span>)</span> </span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">T2</span><span class="params">(CDemo*, <span class="keyword">int</span>)</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    T1(<span class="number">0</span>);</span><br><span class="line">    CDemo::T1(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    CDemo demo;</span><br><span class="line">    demo.T2(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    T2(&amp;demo, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 <code>x64</code> 程序中，<code>T1()</code> 与 <code>CDemo::T1()</code> ，<code>T2()</code> 与 <code>CDemo::T2()</code> 是等价的，会生成同样的汇编代码。如下图：</p><p><img src="http://resources.bianchengnan.tech/function-basics-part1-difference-between-functions-and-how-to-call-function-across-module/function-call-disassembly-x64.png" alt="function-call-disassembly-x64"></p><p>在 <code>x86</code> 程序中，由于调用约定不同，<code>T2()</code> 与 <code>CDemo::T2()</code> 的参数传递方式不同，如下图：</p><p><img src="http://resources.bianchengnan.tech/function-basics-part1-difference-between-functions-and-how-to-call-function-across-module/function-call-disassembly-x86.png" alt="function-call-disassembly-x86"></p><h2 id="构造函数与析构函数"><a href="#构造函数与析构函数" class="headerlink" title="构造函数与析构函数"></a>构造函数与析构函数</h2><p>什么时候会调用构造函数，什么时候会调用析构函数？</p><ul><li><p>当一个类对象被构造出来的时候，会调用构造函数</p><p>比如有一个名为 <code>CTest</code> 的类。下面两句代码都会导致类构造函数被调用。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  CTest t1;</span><br><span class="line">  CTest* p = <span class="keyword">new</span> CTest();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>当一个类对象的生命周期结束的时候，会调用析构函数</p><p>一个对象的生命周期什么时候结束呢？有两种情况：</p><ol><li>变量超出作用域</li><li>显式调用 <code>delete</code> </li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  CTest t1;</span><br><span class="line">  CTest* p = <span class="keyword">new</span> CTest();</span><br><span class="line">  <span class="keyword">delete</span> p; <span class="comment">// delete 内部会调用析构函数</span></span><br><span class="line">&#125; <span class="comment">// t1 会在这里被析构</span></span><br></pre></td></tr></table></figure></li></ul><blockquote><p><strong>敲黑板：</strong> 如果不在 <code>B</code> 模块中实例化 <code>A</code> 模块中的类对象，那么对 <code>B</code> 模块而言 <code>A</code> 模块的构造函数不必是导出的。析构函数也是一样的道理。</p></blockquote><h2 id="虚函数-vs-其它函数"><a href="#虚函数-vs-其它函数" class="headerlink" title="虚函数 vs 其它函数"></a>虚函数 vs 其它函数</h2><p>调用虚函数与调用其它函数的区别是什么？</p><p>我之前写过一篇关于虚函数的总结 —— <a href="https://bianchengnan.github.io/articles/brief-introduction-to-cpp-virtual-function-and-vtbl/">《基础知识 | C++ 虚函数简介》</a>（如果图挂了可以看<a href="https://zhuanlan.zhihu.com/p/240765167" target="_blank" rel="noopener">这里</a>）。</p><p>介绍了虚函数的相关内容：虚表都包含哪些内容、虚表指针的初始化时机、虚函数是如何支持多态的。这里再简单总结一下：</p><ul><li><p>每个包含虚函数的类对象都有一个虚表指针，该指针指向了虚表，会<strong>在类对象的构造函数中初始化</strong></p></li><li><p>虚表中<strong>按顺序</strong>存放了虚函数地址</p></li><li><p>虚函数调用是通过虚表实现的。大体调用过程如下：</p><ul><li>通过类对象找到虚表指针，进而找到虚表</li><li>根据头文件中虚函数的顺序得到索引</li><li>根据索引从虚表中取出函数地址进行调用</li></ul></li></ul><p>调用虚函数与调用其它函数最主要的区别是：</p><p>调用普通函数的时候，会直接跳转到函数首地址；调用虚函数的时候，会通过虚表跳转到函数首地址。</p><h2 id="跨模块调用"><a href="#跨模块调用" class="headerlink" title="跨模块调用"></a>跨模块调用</h2><p><code>B</code> 模块如何调用 <code>A</code> 模块中的函数？</p><p><code>B</code> 模块要想调用 <code>A</code> 模块中的函数，最重要的原则是：<code>B</code> 模块要能找到 <code>A</code> 模块中的函数地址，一般情况下需要做两件事：</p><p><strong>首先</strong>，<code>A</code> 模块中的函数需要声明为导出的。导出的函数会记录在 <code>A</code> 模块的<strong>导出表</strong>中</p><p><strong>其次</strong>，通过头文件 + 库文件，让 <code>B</code> 模块依赖 <code>A</code> 模块。编译器会在 <code>B</code> 模块的<strong>导入表</strong>中添加对应项</p><blockquote><p><strong>说明：</strong> 还可以通过 <code>GetAddressProc()</code> 找到函数地址进行调用</p></blockquote><p><code>B</code> 模块依赖 <code>A</code> 模块，在 <code>vs</code> 中有三种设置方法：</p><h2 id="解决库依赖的三种方法"><a href="#解决库依赖的三种方法" class="headerlink" title="解决库依赖的三种方法"></a>解决库依赖的三种方法</h2><ol><li><p>在代码中使用 <code>#pragma comment(lib, libA)</code> 进行依赖</p><p>可以不修改工程配置，直接在代码中设置依赖</p></li></ol><ol start="2"><li><p>在 <code>B</code> 模块对应项目的链接器设置中，添加对项目 <code>A</code> 的依赖</p><p>这是比较常规的做法，设置方法如下图：<img src="http://resources.bianchengnan.tech/function-basics-part1-difference-between-functions-and-how-to-call-function-across-module/add-lib-in-project-link-option.png" alt="add-lib-in-project-link-option"></p></li></ol><ol start="3"><li><p>在 <code>B</code> 模块对应项目的引用配置中添加对项目 <code>A</code> 的引用</p><p>此方法最简单，最省心，甚至都不用考虑被依赖的库文件的生成路径！<img src="http://resources.bianchengnan.tech/function-basics-part1-difference-between-functions-and-how-to-call-function-across-module/add-project-reference.png" alt="add-project-reference"></p></li></ol><blockquote><p><strong>注意：</strong> 前两种方法，可能需要在附加库目录中配置 <code>libA</code> 的路径，第三种方法不用。</p></blockquote><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>函数是<strong>一段可以被 <code>CPU</code> 执行的二进制代码</strong>，会被存储在模块中的某个位置，<strong>相对于模块基址的偏移不会改变</strong>，模块的基址发生变化后，函数地址也会跟着变</li><li>调用约定会影响编译后的函数名、参数传递方式、谁来平衡调用栈</li><li><code>x86</code> 程序有各种调用约定，<code>x64</code> 程序只有 <code>__fastcall</code> 一种调用约定</li><li>调用函数的两个关键点是：<ul><li>找到函数地址</li><li>明确参数传递方式（由调用约定决定）</li></ul></li><li>调用外部模块的函数，需要依赖对应的库。在 <code>vs</code> 中解决库依赖有三种方法：<ul><li>在代码中使用 <code>#pragma comment(lib, libA)</code> 进行依赖</li><li>在 <code>B</code> 模块对应项目的链接器设置中，添加对项目 <code>A</code> 的依赖</li><li>在 <code>B</code> 模块对应项目的引用配置中添加对项目 <code>A</code> 的引用</li></ul></li></ul><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><p>《软件调试》第一版 </p></li><li><p>调用约定相关参考链接</p><ul><li><a href="https://learn.microsoft.com/en-us/cpp/cpp/calling-conventions?view=msvc-160" target="_blank" rel="noopener">https://learn.microsoft.com/en-us/cpp/cpp/calling-conventions?view=msvc-160</a></li><li><a href="https://learn.microsoft.com/en-us/cpp/build/x64-calling-convention?view=msvc-160" target="_blank" rel="noopener">https://learn.microsoft.com/en-us/cpp/build/x64-calling-convention?view=msvc-160</a></li><li><a href="https://learn.microsoft.com/en-us/cpp/cpp/argument-passing-and-naming-conventions?view=msvc-160" target="_blank" rel="noopener">https://learn.microsoft.com/en-us/cpp/cpp/argument-passing-and-naming-conventions?view=msvc-160</a></li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;缘起&quot;&gt;&lt;a href=&quot;#缘起&quot; class=&quot;headerlink&quot; title=&quot;缘起&quot;&gt;&lt;/a&gt;缘起&lt;/h2&gt;&lt;p&gt;最近遇到了几个跟虚函数有关的问题，既有编译链接问题，又有运行问题，归根到底是基本功不扎实导致的问题。本文将会简单梳理一下函数相关的基本知识：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;函数是什么？&lt;/li&gt;
&lt;li&gt;函数调用约定有哪些？有什么作用？&lt;/li&gt;
&lt;li&gt;普通函数、类静态函数、类成员函数的区别是什么？&lt;/li&gt;
&lt;li&gt;什么时候会调用构造函数，什么时候会调用析构函数？&lt;/li&gt;
&lt;li&gt;调用虚函数与调用其它函数的区别是什么？&lt;/li&gt;
&lt;li&gt;&lt;code&gt;B&lt;/code&gt; 模块如何调用 &lt;code&gt;A&lt;/code&gt; 模块的函数？&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;本文适合初学者，如果您已经有一定的开发经验，可以跳过本文。&lt;/p&gt;
    
    </summary>
    
      <category term="基础知识" scheme="https://bianchengnan.github.io/categories/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
    
      <category term="virtual function" scheme="https://bianchengnan.github.io/tags/virtual-function/"/>
    
      <category term="基础知识" scheme="https://bianchengnan.github.io/tags/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
      <category term="函数基础" scheme="https://bianchengnan.github.io/tags/%E5%87%BD%E6%95%B0%E5%9F%BA%E7%A1%80/"/>
    
      <category term="函数" scheme="https://bianchengnan.github.io/tags/%E5%87%BD%E6%95%B0/"/>
    
      <category term="虚函数" scheme="https://bianchengnan.github.io/tags/%E8%99%9A%E5%87%BD%E6%95%B0/"/>
    
      <category term="function" scheme="https://bianchengnan.github.io/tags/function/"/>
    
      <category term="跨模块调用" scheme="https://bianchengnan.github.io/tags/%E8%B7%A8%E6%A8%A1%E5%9D%97%E8%B0%83%E7%94%A8/"/>
    
      <category term="调用约定" scheme="https://bianchengnan.github.io/tags/%E8%B0%83%E7%94%A8%E7%BA%A6%E5%AE%9A/"/>
    
      <category term="part1" scheme="https://bianchengnan.github.io/tags/part1/"/>
    
  </entry>
  
  <entry>
    <title>调试实战 | 调试另外一个由于全局变量初始化顺序导致的 dll 加载失败问题（下）</title>
    <link href="https://bianchengnan.github.io//articles/debug-another-dll-load-failure-caused-by-global-variable-initialize-dependency-part3/"/>
    <id>https://bianchengnan.github.io//articles/debug-another-dll-load-failure-caused-by-global-variable-initialize-dependency-part3/</id>
    <published>2024-06-08T09:39:23.000Z</published>
    <updated>2024-12-21T04:02:49.948Z</updated>
    
    <content type="html"><![CDATA[<h2 id="缘起"><a href="#缘起" class="headerlink" title="缘起"></a>缘起</h2><p>在前面两篇文章中，应该算是彻底理清了项目中存在的两个问题。感兴趣的小伙伴儿可以参考<a href="https://bianchengnan.github.io/articles/debug-another-dll-load-failure-caused-by-global-variable-initialize-dependency-part1">《调试实战 | 调试另外一个由于全局变量初始化顺序导致的 dll 加载失败问题（上）》</a>和 <a href="https://bianchengnan.github.io/articles/debug-another-dll-load-failure-caused-by-global-variable-initialize-dependency-part2">《调试实战 | 调试另外一个由于全局变量初始化顺序导致的 dll 加载失败问题（中）》</a>。</p><p>在上篇文章的末尾提到一种情况</p><blockquote><p>如果在 <code>LoadDlls.exe</code> 中也显式加载了 <code>dll3.dll</code>，还会不会崩溃呢？答案是<strong>可能崩溃，也可能不崩溃</strong>。</p><p>因为 <code>RegisterInitCallback()</code>内部更新数据时使用的是 <code>map.insert()</code>，这会导致一个问题 —— 如果 <code>map</code> 中已经存在相同的 <code>key</code>，那么 <code>insert()</code> 会失败，不会更新数据。</p><p>试想，如果显式加载 <code>dll3.dll</code> 成功，但是 <code>dll3.dll</code> 的基址变了。<code>map</code> 中保存的还是旧的无效地址，而不是新函数地址。</p><p>如果 <code>dll3.dll</code> 的基址没有发生变化，新函数地址与旧函数地址一样，程序可以非常<strong>“幸运”</strong>的正常运行。 </p></blockquote><p>本文通过实战来验证上文中的结论，什么情况下会崩溃，什么情况下不崩溃。</p><a id="more"></a><h2 id="显式加载-dll3-dll"><a href="#显式加载-dll3-dll" class="headerlink" title="显式加载 dll3.dll"></a>显式加载 dll3.dll</h2><p>修改 <code>LoadDlls</code> 工程中的 <code>main()</code> 函数代码，使其加载 <code>dll1.dll</code>、<code>dll2.dll</code> 和 <code>dll3.dll</code>。修改后的关键代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"[+] load plugin start."</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>* plugins[] = &#123; <span class="string">"dll1.dll"</span>, <span class="string">"dll2.dll"</span>, <span class="string">"dll3.dll"</span>, <span class="literal">nullptr</span> &#125;; <span class="comment">//&lt;---- 只修改了这里</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>本以为这样修改后，应该偶尔会崩溃（因为默认开启了 <code>ASLR</code>，模块的加载基址应该会随机才对）。结果发现，每次运行都不崩溃，而且功能一切正常，着实有些出乎意料。</p><p><img src="http://resources.bianchengnan.tech/debug-another-dll-load-failure-caused-by-global-variable-initialize-dependency-part3/function-normal.png" alt="function-normal"></p><p>看来 <code>dll3.dll</code> 每次都能加载到上一次被加载的基址。那怎么才能让 <code>dll3.dll</code> 加载到其它基址呢？</p><h2 id="改变加载基址"><a href="#改变加载基址" class="headerlink" title="改变加载基址"></a>改变加载基址</h2><p>最朴素的想法是，如果在显式加载 <code>dll3.dll</code> 之前，又加载了很多其它 <code>dll</code>，把原本 <code>dll3.dll</code> 加载的基址占用掉，那么再次加载 <code>dll3.dll</code> 的基址肯定会发生变化，大概率会崩溃。</p><p>按照这个思路，修改后的关键代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"[+] load plugin start."</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>* plugins[] = &#123; <span class="string">"dll1.dll"</span>, <span class="string">"dll2.dll"</span>, <span class="string">"dll4.dll"</span>, <span class="string">"dll3.dll"</span>, <span class="literal">nullptr</span> &#125;; <span class="comment">//&lt;---- 只修改了这里</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译完成后，把 <code>dll1.dll</code> 复制一份，修改名字为 <code>dll4.dll</code>，然后运行 <code>LoadDlls.exe</code>，果然崩溃了。</p><p><img src="http://resources.bianchengnan.tech/debug-another-dll-load-failure-caused-by-global-variable-initialize-dependency-part3/app-crashed.png" alt="app-crashed"></p><blockquote><p><strong>小提示：</strong> 如果删除 <code>dll4.dll</code>，再次运行程序，又不崩溃了</p></blockquote><p>调查一下崩溃原因，看看是不是跟我们预期的一样。</p><h2 id="简单分析"><a href="#简单分析" class="headerlink" title="简单分析"></a>简单分析</h2><p>用 <code>windbg</code> 打开转储文件后，点击 <code>!analyze -v</code>，分析结果如下：</p><p><img src="http://resources.bianchengnan.tech/debug-another-dll-load-failure-caused-by-global-variable-initialize-dependency-part3/windbg-analyze-v.png" alt="windbg-analyze-v"></p><p>可以发现在执行 <code>movsxd rax,dword ptr [rax+4]</code> 的时候崩溃了，而且这段反汇编代码属于 <code>MSVCP140D!std::basic_ostream&lt;char,std::char_traits&lt;char&gt; &gt;::flush()</code>。在 <code>windbg</code> 中查看相关反汇编代码，如下图：</p><p><img src="http://resources.bianchengnan.tech/debug-another-dll-load-failure-caused-by-global-variable-initialize-dependency-part3/view-disassembly-of-flush.png" alt="view-disassembly-of-flush"></p><p>从上图可知，<code>rax</code> 的值最开始来源于 <code>rsp+0x50</code>（<code>mov rax, qword ptr [rsp+50h]</code>），而 <code>rsp+0x50</code> 的值又来源于 <code>rcx</code>（<code>mov qword ptr [rsp+8], rcx</code>，<code>sub rsp, 48h</code>）。</p><p>在遍历调用 <code>s_init_callbacks</code> 保存的回调函数的时候并不会使用 <code>rcx</code>，因此 <code>rcx</code> 的值是是随机的，那么使用了 <code>rcx</code> 而崩溃是可以理解的。</p><p>还有一个小问题：为什么 <code>dll2!Init()</code> 会调用 <code>MSVCP140D!std::basic_ostream&lt;char,std::char_traits&lt;char&gt; &gt;::flush()</code> 呢？</p><h2 id="进一步调查"><a href="#进一步调查" class="headerlink" title="进一步调查"></a>进一步调查</h2><p>使用命令 <code>dx dll2!s_init_callbacks</code> 查看  <code>dll2!s_init_callbacks</code> 的内容，如下图：</p><p><img src="http://resources.bianchengnan.tech/debug-another-dll-load-failure-caused-by-global-variable-initialize-dependency-part3/view-s_init_callbacks.png" alt="view-s_init_callbacks"></p><p>可以发现 <code>dll2!s_init_callbacks</code> 中保存的函数地址是 <code>0x7ffd 929e12e4</code>，对应的函数是 <code>dll4!@ILT+735(?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV12@XZ)</code>，该函数最终会调用<code>MSVCP140D!std::basic_ostream&lt;char,std::char_traits&lt;char&gt; &gt;::flush</code>。</p><p>使用 <code>lmm dll*</code> 查看相关模块加载情况，如下图：</p><p><img src="http://resources.bianchengnan.tech/debug-another-dll-load-failure-caused-by-global-variable-initialize-dependency-part3/view-modules.png" alt="view-modules"></p><p>从上图可知，<code>dll4.dll</code> 的基址与已经卸载的 <code>dll3.dll</code> 的基址是一样的，都是 <code>00007ffd 929d0000</code>，新加载的 <code>dll3.dll</code> 的基址已经变成了 <code>00007ffd 8c540000</code>。</p><p><code>s_init_callbacks</code> 中保存的函数地址相对于模块基址的偏移是 <code>0x7ffd 929e12e4 - 00007ffd 929d0000 = 0x112e4</code>，换算成在 <code>dll3.dll</code> 中的地址是 <code>0x00007ffd 8c540000 + 0x112e4 = 0x00007ffd 8c5512e4</code>。在 <code>windbg</code> 中使用 <code>ln 0x00007ffd8c5512e4</code> 查看于该地址对应的符号，输出结果如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span>:<span class="number">000</span>&gt; ln <span class="number">0x00007ffd8c5512e4</span></span><br><span class="line">Browse <span class="keyword">module</span></span><br><span class="line">Set bu breakpoint</span><br><span class="line"></span><br><span class="line">(<span class="number">00007f</span>fd`<span class="number">8</span>c5512e4)   dll3!ILT+<span class="number">735</span>(?Dll3InitCallbackYAXXZ)   |  (<span class="number">00007f</span>fd`<span class="number">8</span>c5512e9)   dll3!ILT+<span class="number">740</span>(?flush?$basic_ostreamDU?$char_traitsDstdstdQEAAAEAV12XZ)</span><br><span class="line">Exact matches:</span><br></pre></td></tr></table></figure><p>可以发现与 <code>dll3!ILT+735(?Dll3InitCallbackYAXXZ)</code> 完全匹配。</p><p>至此，所有疑问都已经解开了。<code>dll3.dll</code> 加载的时候会注册回调函数，由于异常 <code>dll3.dll</code> 会被自动卸载，但是注册回调函数并没有取消注册，<code>dll4.dll</code> 紧接着被加载到了 <code>dll3.dll</code> 旧基址，再次加载 <code>dll3.dll</code>，新的 <code>dll3.dll</code> 被加载到了其他位置。<code>dll3.dll</code> 最开始注册的回调函数变成了 <code>dll4.dll</code> 中的函数。</p><p>因为这是实际项目中遇到的问题，非常有代表性，而且崩溃的代码与业务代码毫不相干，很难查！</p><p>总结下来，主要有两大问题：</p><ol><li>在全局变量的构造函数中调用 <code>LoadLibrary()</code> 加载新的 <code>dll</code>，这是很危险的操作，应该尽量避免。</li><li>当使用 <code>insert()</code> 而不是 <code>operator[]</code> 向 <code>map</code> 中插入数据时，如果对应的 <code>key</code> 已经存在，不会更新数据。</li></ol><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li><code>lm</code> 可以显示模块信息（包括已经卸载的模块信息），<code>lmm dll*</code> 可以显示以 <code>dll</code> 开头的模块</li><li><code>map.insert()</code> 在插入新数据时，如果发现对应的 <code>key</code> 已经存在，会直接返回 <code>false</code>，而不会更新数据。<code>operator []</code> 会强制更新数据</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;缘起&quot;&gt;&lt;a href=&quot;#缘起&quot; class=&quot;headerlink&quot; title=&quot;缘起&quot;&gt;&lt;/a&gt;缘起&lt;/h2&gt;&lt;p&gt;在前面两篇文章中，应该算是彻底理清了项目中存在的两个问题。感兴趣的小伙伴儿可以参考&lt;a href=&quot;https://bianchengnan.github.io/articles/debug-another-dll-load-failure-caused-by-global-variable-initialize-dependency-part1&quot;&gt;《调试实战 | 调试另外一个由于全局变量初始化顺序导致的 dll 加载失败问题（上）》&lt;/a&gt;和 &lt;a href=&quot;https://bianchengnan.github.io/articles/debug-another-dll-load-failure-caused-by-global-variable-initialize-dependency-part2&quot;&gt;《调试实战 | 调试另外一个由于全局变量初始化顺序导致的 dll 加载失败问题（中）》&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;在上篇文章的末尾提到一种情况&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;如果在 &lt;code&gt;LoadDlls.exe&lt;/code&gt; 中也显式加载了 &lt;code&gt;dll3.dll&lt;/code&gt;，还会不会崩溃呢？答案是&lt;strong&gt;可能崩溃，也可能不崩溃&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;因为 &lt;code&gt;RegisterInitCallback()&lt;/code&gt;内部更新数据时使用的是 &lt;code&gt;map.insert()&lt;/code&gt;，这会导致一个问题 —— 如果 &lt;code&gt;map&lt;/code&gt; 中已经存在相同的 &lt;code&gt;key&lt;/code&gt;，那么 &lt;code&gt;insert()&lt;/code&gt; 会失败，不会更新数据。&lt;/p&gt;
&lt;p&gt;试想，如果显式加载 &lt;code&gt;dll3.dll&lt;/code&gt; 成功，但是 &lt;code&gt;dll3.dll&lt;/code&gt; 的基址变了。&lt;code&gt;map&lt;/code&gt; 中保存的还是旧的无效地址，而不是新函数地址。&lt;/p&gt;
&lt;p&gt;如果 &lt;code&gt;dll3.dll&lt;/code&gt; 的基址没有发生变化，新函数地址与旧函数地址一样，程序可以非常&lt;strong&gt;“幸运”&lt;/strong&gt;的正常运行。 &lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;本文通过实战来验证上文中的结论，什么情况下会崩溃，什么情况下不崩溃。&lt;/p&gt;
    
    </summary>
    
      <category term="调试" scheme="https://bianchengnan.github.io/categories/%E8%B0%83%E8%AF%95/"/>
    
    
      <category term="调试" scheme="https://bianchengnan.github.io/tags/%E8%B0%83%E8%AF%95/"/>
    
      <category term="debug" scheme="https://bianchengnan.github.io/tags/debug/"/>
    
      <category term="windbg" scheme="https://bianchengnan.github.io/tags/windbg/"/>
    
      <category term="dll" scheme="https://bianchengnan.github.io/tags/dll/"/>
    
      <category term="全局变量" scheme="https://bianchengnan.github.io/tags/%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F/"/>
    
  </entry>
  
  <entry>
    <title>调试实战 | 调试另外一个由于全局变量初始化顺序导致的 dll 加载失败问题（中）</title>
    <link href="https://bianchengnan.github.io//articles/debug-another-dll-load-failure-caused-by-global-variable-initialize-dependency-part2/"/>
    <id>https://bianchengnan.github.io//articles/debug-another-dll-load-failure-caused-by-global-variable-initialize-dependency-part2/</id>
    <published>2024-05-12T08:39:23.000Z</published>
    <updated>2024-12-21T04:02:49.946Z</updated>
    
    <content type="html"><![CDATA[<h2 id="缘起"><a href="#缘起" class="headerlink" title="缘起"></a>缘起</h2><p>在<a href="https://bianchengnan.github.io/articles/debug-another-dll-load-failure-caused-by-global-variable-initialize-dependency-part1">上篇文章《调试实战 | 调试另外一个由于全局变量初始化顺序导致的 dll 加载失败问题（上）》</a>中，解决了由于全局变量初始化顺序不对导致的崩溃问题。但是代码里还有一处非常隐蔽的 <code>bug</code>，今天继续介绍一下这个问题及对应的解决方法。</p><a id="more"></a><h2 id="示例程序"><a href="#示例程序" class="headerlink" title="示例程序"></a>示例程序</h2><p>在上篇文章代码的基础上，修改 <code>LoadDlls</code> 工程中的 <code>main()</code> 函数代码，使其加载 <code>dll1.dll</code> 和 <code>dll2.dll</code>（上篇文章中只加载了 <code>dll1.dll</code>）。修改后的关键代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"[+] load plugin start."</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>* plugins[] = &#123; <span class="string">"dll1.dll"</span>, <span class="string">"dll2.dll"</span>, <span class="comment">/*"dll3.dll",*/</span> <span class="literal">nullptr</span> &#125;; <span class="comment">//&lt;---- 只修改了这里</span></span><br><span class="line">    <span class="keyword">auto</span> loaded_module_map = LoadPlugins(plugins);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"[+] load plugin done, press any key to init plugins."</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    system(<span class="string">"pause"</span>);</span><br><span class="line"></span><br><span class="line">    InitPlugins(loaded_module_map);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="直接运行崩溃了"><a href="#直接运行崩溃了" class="headerlink" title="直接运行崩溃了"></a>直接运行崩溃了</h2><p>运行完 <code>LoadPlugins()</code> 后，点击任意按键继续运行，会继续执行 <code>InitPlugins()</code>，程序会在此函数中崩溃。因为我设置 <code>procdump</code> 为 <code>JIT</code> 调试器（具体设置方法可以参考<a href="https://bianchengnan.github.io/articles/process-dump-tools-you-should-know/">这篇文章</a>），程序崩溃后会自动调用 <code>procdump</code> 保存崩溃转储文件。</p><p>用 <code>windbg</code> 打开转储文件，无脑点击 <code>!analyze -v</code>，让 <code>windbg</code> 帮我们自动分析，分析结果如下图：</p><p><img src="http://resources.bianchengnan.tech/debug-another-dll-load-failure-caused-by-global-variable-initialize-dependency-part2/exception-when-excute-from-unloaded-dll3.png" alt="exception-when-excute-from-unloaded-dll3"></p><p>从上图中的<strong>调用栈</strong>基本可以确定在执行 <code>dll3.dll</code> 中的代码时发生了异常。</p><p>而且这次的异常不是因为<strong>读/写</strong>非法地址导致的，而是执行到非法地址导致的（注意红色高亮部分的提示 <code>Attempt to execute non-executable address 00007ffbdd9812e4</code>）。</p><p>可以猜测 <code>00007ffbdd9812e4</code> 是属于 <code>dll3.dll</code> 的（可以通过 <code>!address 00007ffbdd9812e4</code> 验证），而且当执行到 <code>00007ffbdd9812e4</code> 的时候，<code>dll3.dll</code> 已经被卸载了（注意底部红色高亮部分的 <code>Unloaded</code> 关键字）。</p><p>使用 <code>!address 00007ffbdd9812e4</code> 查看该地址的信息，如下图：</p><p><img src="http://resources.bianchengnan.tech/debug-another-dll-load-failure-caused-by-global-variable-initialize-dependency-part2/address-00007ffbdd9812e4.png" alt="address-00007ffbdd9812e4"></p><p>从上图可知，<code>00007ffbdd9812e4</code> 确实是属于 <code>dll3.dll</code> 的，但是 <code>dll3.dll</code> 已经被卸载了。<code>00007ffbdd9812e4</code> 所在的页面是 <code>MEM_FREE</code> 的，而且是 <code>PAGE_NOACCESS</code> 的。</p><p>但是，程序为什么会执行到一个已经被卸载的模块中的地址呢？</p><h2 id="追本溯源"><a href="#追本溯源" class="headerlink" title="追本溯源"></a>追本溯源</h2><p>从调用栈可以得知，<code>dll3.dll</code> 中的函数是由 <code>dll2!Init()</code> 调用的， 通过查看  <code>dll2!Init()</code> 源码，可以发现 <code>dll2!Init()</code> 函数中会遍历 <code>s_init_callbacks</code>。在 <code>windbg</code> 中输入<code>dx dll2!s_init_callbacks</code> 查看其内容，如下图：</p><p><img src="http://resources.bianchengnan.tech/debug-another-dll-load-failure-caused-by-global-variable-initialize-dependency-part2/view-s_init_callbacks.png" alt="view-s_init_callbacks"></p><p>可以发现，<code>s_init_callbacks</code> 中只有一项，是 <code>dll3.dll</code> 中的函数。</p><p>根据源码可知，<code>dll3.dll</code> 在加载的时候会自动调用 <code>dll2!RegisterInitCallback()</code> 注册回调函数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">BEGIN_AUTO_RUN</span><br><span class="line">RegisterInitCallback(<span class="string">"dll3"</span>, Dll3InitCallback);</span><br><span class="line">END_AUTO_RUN</span><br></pre></td></tr></table></figure><p>可以推理，<code>s_init_callbacks</code> 中的函数是 <code>dll3!Dll3InitCallback</code>。</p><p>加载 <code>dll3.dll</code> 的调试符号后，查看调用栈，可以证实我们的猜想。如下图：</p><p><img src="http://resources.bianchengnan.tech/debug-another-dll-load-failure-caused-by-global-variable-initialize-dependency-part2/compare-callstacks-after-reload-dll3-symbol.png" alt="compare-callstacks-after-reload-dll3-symbol"></p><p>根据源码可知，<code>dll3.dll</code> 在加载的时候还会自动调用 <code>RegisterCallback()</code>，相关代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">BEGIN_AUTO_RUN</span><br><span class="line">RegisterCallback(<span class="string">"dll3"</span>, Dll3Callback);</span><br><span class="line">END_AUTO_RUN</span><br></pre></td></tr></table></figure><p>因为调用 <code>RegisterCallback()</code> 的时候发生了异常（在<a href="https://bianchengnan.github.io/articles/debug-another-dll-load-failure-caused-by-global-variable-initialize-dependency-part1">上篇文章</a>中已经分析过了），导致 <code>dll3.dll</code> 加载失败，<code>dll3.dll</code> 会被自动<strong>卸载</strong> 。但是通过 <code>RegisterInitCallback()</code> 注册的回调函数已经保存在了 <code>dll2!s_init_callbacks</code> 中，没有被清除。</p><p>当后面调用 <code>dll2!Init()</code> 时，会调用 <code>dll3.dll</code> 注册到  <code>dll2!s_init_callbacks</code> 中的函数（<code>Dll3InitCallback</code>），因为 <code>dll3.dll</code> 已经被卸载了，对应的函数地址也无效了，也就会发生上文中的异常。</p><h2 id="深入思考"><a href="#深入思考" class="headerlink" title="深入思考"></a>深入思考</h2><p>如果在 <code>LoadDlls.exe</code> 中也显式加载了 <code>dll3.dll</code>，还会不会崩溃呢？答案是<strong>可能崩溃，也可能不崩溃</strong>。</p><p>因为 <code>RegisterInitCallback()</code>内部更新数据时使用的是 <code>map.insert()</code>，这会导致一个问题 —— 如果 <code>map</code> 中已经存在相同的 <code>key</code>，那么 <code>insert()</code> 会失败，不会更新数据。</p><p>试想，如果显式加载 <code>dll3.dll</code> 成功，但是 <code>dll3.dll</code> 的基址变了。<code>map</code> 中保存的还是旧的无效地址，而不是新函数地址。</p><p>如果 <code>dll3.dll</code> 的基址没有发生变化，新函数地址与旧函数地址一样，程序可以非常<strong>“幸运”</strong>的正常运行。 </p><p>要想规避这种问题，可以换一种写法，修改后的代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">RegisterInitCallback</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* key, <span class="keyword">void</span>(*callback)())</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//s_init_callbacks.insert(std::make_pair(key, callback));</span></span><br><span class="line">    s_init_callbacks[key] = callback;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li><p>调试由于模块被卸载导致的异常，其实很简单 —— 直接在 <code>windbg</code> 中使用 <code>!analyze -v</code> 基本上就可以定位到问题了</p></li><li><p>这次的崩溃，直接原因在于模块被意外的卸载了，归根结底还是代码不规范导致的</p></li><li><p>如果 <code>map</code> 中想保存最新数据，那么不要使用 <code>map.insert</code>，而要使用 <code>operater []</code></p></li><li><p><code>map.insert()</code> 在插入新数据时，如果发现对应的 <code>key</code> 已经存在，会直接返回 <code>false</code>，而不会更新数据。<code>operator []</code> 会强制更新数据</p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;缘起&quot;&gt;&lt;a href=&quot;#缘起&quot; class=&quot;headerlink&quot; title=&quot;缘起&quot;&gt;&lt;/a&gt;缘起&lt;/h2&gt;&lt;p&gt;在&lt;a href=&quot;https://bianchengnan.github.io/articles/debug-another-dll-load-failure-caused-by-global-variable-initialize-dependency-part1&quot;&gt;上篇文章《调试实战 | 调试另外一个由于全局变量初始化顺序导致的 dll 加载失败问题（上）》&lt;/a&gt;中，解决了由于全局变量初始化顺序不对导致的崩溃问题。但是代码里还有一处非常隐蔽的 &lt;code&gt;bug&lt;/code&gt;，今天继续介绍一下这个问题及对应的解决方法。&lt;/p&gt;
    
    </summary>
    
      <category term="调试" scheme="https://bianchengnan.github.io/categories/%E8%B0%83%E8%AF%95/"/>
    
    
      <category term="调试" scheme="https://bianchengnan.github.io/tags/%E8%B0%83%E8%AF%95/"/>
    
      <category term="debug" scheme="https://bianchengnan.github.io/tags/debug/"/>
    
      <category term="windbg" scheme="https://bianchengnan.github.io/tags/windbg/"/>
    
      <category term="dll" scheme="https://bianchengnan.github.io/tags/dll/"/>
    
      <category term="全局变量" scheme="https://bianchengnan.github.io/tags/%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F/"/>
    
  </entry>
  
  <entry>
    <title>调试实战 | 调试另外一个由于全局变量初始化顺序导致的 dll 加载失败问题（上）</title>
    <link href="https://bianchengnan.github.io//articles/debug-another-dll-load-failure-caused-by-global-variable-initialize-dependency-part1/"/>
    <id>https://bianchengnan.github.io//articles/debug-another-dll-load-failure-caused-by-global-variable-initialize-dependency-part1/</id>
    <published>2024-03-23T07:39:23.000Z</published>
    <updated>2024-12-21T04:02:49.945Z</updated>
    
    <content type="html"><![CDATA[<h2 id="缘起"><a href="#缘起" class="headerlink" title="缘起"></a>缘起</h2><p>最近又遇到了一个程序功能不正常的问题，深入调查后发现与全局变量初始化顺序有非常大的关系，只不过这次更加隐蔽。</p><p>之前总结了两篇与全局变量初始化顺序有关的文章，感兴趣的小伙伴儿可以参考<a href="https://bianchengnan.github.io/articles/debugging-dll-load-failure-caused-by-global-variable-initialize-dependency/">《调试实战 | dll 加载失败之全局变量初始化篇》</a> 和 <a href="https://bianchengnan.github.io/articles/global-variable-initialization-order-investigation/">《调试实战 | 全局变量初始化顺序探究》</a>。</p><a id="more"></a><p>在排查错误之前先简单介绍一下相关代码。</p><h2 id="示例程序"><a href="#示例程序" class="headerlink" title="示例程序"></a>示例程序</h2><p>示例程序一共包含 <code>4</code> 个工程：<code>LoadDlls, dll1, dll2, dll3</code>。</p><ul><li><p>主程序 <code>LoadDlls.exe</code> 会加载 <code>dll1.dll</code></p></li><li><p><code>dll1.dll</code> 隐式依赖了 <code>dll2.dll</code>，所以 <code>dll1.dll</code> 加载的时候会自动加载 <code>dll2.dll</code></p></li><li><p><code>dll2.dll</code> 中的全局变量 <code>s_culprit</code> 的构造函数会加载 <code>dll3.dll</code></p></li><li><p><code>dll3.dll</code> 加载的时候会自动调用 <code>dll2.dll</code> 的导出函数 <code>RegisterInitCallback()</code> 和 <code>RegisterCallback()</code></p></li></ul><p>下面是每个工程的关键代码</p><ul><li><p><code>src/common/autorunner.h</code> </p><p>该文件是公共头文件，实现了自动注册逻辑</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// autorunner.h</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AutoRunner</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    AutoRunner(<span class="keyword">void</span> (*func)())</span><br><span class="line">    &#123;</span><br><span class="line">        func();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> STR_CAT(s1, s2) s1 ## s2</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NAME_WITH_LINE(name, <span class="meta-keyword">line</span>) STR_CAT(name, <span class="meta-keyword">line</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BEGIN_AUTO_RUN static AutoRunner NAME_WITH_LINE(s_auto_runner_, __LINE__) ([]()&#123;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> END_AUTO_RUN  &#125;);</span></span><br></pre></td></tr></table></figure></li></ul><ul><li><p><code>LoadDlls</code> </p><p>该工程只有一个源文件，用来模拟加载各种插件。对应的源码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// LoadDlls.cpp</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"windows.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(*PFN_Init)</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">map</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>, HMODULE&gt; LoadPlugins(<span class="keyword">const</span> <span class="keyword">char</span>* plugins[])</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">map</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>, HMODULE&gt; result;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> idx = <span class="number">0</span>; ; ++idx)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">char</span>* plugin = plugins[idx];</span><br><span class="line">        <span class="keyword">if</span> (plugin == <span class="literal">nullptr</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        HMODULE <span class="keyword">module</span> = LoadLibraryA(plugin);</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">module</span> == <span class="literal">nullptr</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            DWORD lastError = GetLastError();</span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"[+] load ［"</span> &lt;&lt; plugin &lt;&lt; <span class="string">"] failed with error "</span> &lt;&lt; lastError &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            result[plugin] = <span class="keyword">module</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InitPlugins</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">map</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>, HMODULE&gt;&amp; loaded_plugins)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; it : loaded_plugins)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">auto</span> init_entry = (PFN_Init)GetProcAddress(it.second, <span class="string">"Init"</span>);</span><br><span class="line">        <span class="keyword">if</span> (init_entry != <span class="literal">nullptr</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            init_entry();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"[+] load plugin start."</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>* plugins[] = &#123; <span class="string">"dll1.dll"</span>, <span class="comment">/*"dll2.dll", "dll3.dll",*/</span> <span class="literal">nullptr</span> &#125;;</span><br><span class="line">    <span class="keyword">auto</span> loaded_module_map = LoadPlugins(plugins);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"[+] load plugin done, press any key to init plugins."</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    system(<span class="string">"pause"</span>);</span><br><span class="line"></span><br><span class="line">    InitPlugins(loaded_module_map);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><code>dll1</code> </p><p>该工程非常简单，什么有用的事情都没做，但是会依赖 <code>dll2</code>，加载 <code>dll1.dll</code> 的时候会自动加载 <code>dll2.dll</code>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// dllmain1.cpp</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"../common/autorunner.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"../dll2/exports.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PrintMajorVersion</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Major Version of dll2.dll is "</span> &lt;&lt; MajorVersion() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">BEGIN_AUTO_RUN</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"I'm running in dll1.dll, which implicitly depends on dll2.dll."</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">END_AUTO_RUN</span><br></pre></td></tr></table></figure></li></ul><ul><li><p><code>dll2</code></p><p>该模块提供了注册回调函数的导出接口，并实现了回调逻辑</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// exports.h</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> DLL_EXPORT_DLL2</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DLL_EXPORT extern <span class="meta-string">"C"</span> __declspec(dllexport)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DLL_EXPORT extern <span class="meta-string">"C"</span> __declspec(dllimport)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">DLL_EXPORT <span class="keyword">int</span> <span class="title">MajorVersion</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">DLL_EXPORT <span class="keyword">void</span> <span class="title">RegisterInitCallback</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* key, <span class="keyword">void</span>(*callback)())</span></span>;</span><br><span class="line"><span class="function">DLL_EXPORT <span class="keyword">void</span> <span class="title">RegisterCallback</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* key, <span class="keyword">void</span>(*callback)())</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">DLL_EXPORT <span class="keyword">void</span> <span class="title">Init</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure></li></ul>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// dllmain2.cpp</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DLL_EXPORT_DLL2</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"exports.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">///////////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">MajorVersion</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="number">1</span>; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">///////////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="keyword">static</span> <span class="built_in">std</span>::<span class="built_in">map</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>, <span class="keyword">void</span>(*)()&gt; s_init_callbacks;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">RegisterInitCallback</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* key, <span class="keyword">void</span>(*callback)())</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    s_init_callbacks.insert(<span class="built_in">std</span>::make_pair(key, callback));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">///////////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyGlobalVariable</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    MyGlobalVariable() &#123; <span class="keyword">auto</span> <span class="keyword">module</span> = LoadLibrary(<span class="string">L"dll3.dll"</span>); &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">MyGlobalVariable s_culprit;</span><br><span class="line"></span><br><span class="line"><span class="comment">///////////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="keyword">static</span> <span class="built_in">std</span>::<span class="built_in">map</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>, <span class="keyword">void</span>(*)()&gt; s_callbacks;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">RegisterCallback</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* key, <span class="keyword">void</span>(*callback)())</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    s_callbacks.insert(<span class="built_in">std</span>::make_pair(key, callback));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">///////////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> it : s_init_callbacks)</span><br><span class="line">    &#123;</span><br><span class="line">        it.second();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p><code>dll3</code></p><p>该模块会<strong>自动</strong>调用 <code>dll2.dll</code> 导出的接口进行注册</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// dllmain3.cpp</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"../common/autorunner.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"../dll2/exports.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">///////////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Dll3InitCallback</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"I'm callback from dll3.dll"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">BEGIN_AUTO_RUN</span><br><span class="line">RegisterInitCallback(<span class="string">"dll3"</span>, Dll3InitCallback);</span><br><span class="line">END_AUTO_RUN</span><br><span class="line"></span><br><span class="line"><span class="comment">///////////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Dll3Callback</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"I'm callback from dll3.dll"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">BEGIN_AUTO_RUN</span><br><span class="line">RegisterCallback(<span class="string">"dll3"</span>, Dll3Callback);</span><br><span class="line">END_AUTO_RUN</span><br></pre></td></tr></table></figure></li></ul><p>直接运行程序，从表面上看一切正常，但是在调试器下运行程序的时候会遇到一个意想不到的异常。</p><h2 id="调试运行"><a href="#调试运行" class="headerlink" title="调试运行"></a>调试运行</h2><p>打开 <code>windbg</code>，选择需要执行的程序，确定后输入 <code>g</code> 命令，目标程序会发生异常，自动中断到 <code>windbg</code> 中。</p><p><img src="http://resources.bianchengnan.tech/debug-another-dll-load-failure-caused-by-global-variable-initialize-dependency-part1/exception-break-to-windbg.png" alt="exception-break-to-windbg"></p><p>在 <code>windbg</code> 中输入 <code>kc</code> 查看调用栈，输出结果摘录如下（为了方便查看，输出结果有所调整，注意 <code>&lt;----</code> 的部分）：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span>:<span class="number">000</span>&gt; kc</span><br><span class="line"> # Call Site</span><br><span class="line"><span class="number">00</span> dll2!<span class="built_in">std</span>::_Tree&lt;<span class="built_in">std</span>::<span class="built_in">string</span>,<span class="keyword">void</span> (__cdecl*)(<span class="keyword">void</span>)&gt;::_Insert_nohint&lt;...&gt;()</span><br><span class="line"><span class="number">01</span> dll2!<span class="built_in">std</span>::_Tree&lt;<span class="built_in">std</span>::<span class="built_in">string</span>,<span class="keyword">void</span> (__cdecl*)(<span class="keyword">void</span>)&gt;::emplace&lt;...&gt;()</span><br><span class="line"><span class="number">02</span> dll2!<span class="built_in">std</span>::<span class="built_in">map</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>,<span class="keyword">void</span> (__cdecl*)(<span class="keyword">void</span>)&gt;::insert&lt;...&gt;()</span><br><span class="line"><span class="number">03</span> dll2!RegisterCallback  <span class="comment">//&lt;----</span></span><br><span class="line"><span class="number">04</span> dll3!&lt;lambda_7ce22ad9d321cf7c9be3c0faf7e37347&gt;::<span class="keyword">operator</span>()</span><br><span class="line"><span class="number">05</span> dll3!&lt;lambda_7ce22ad9d321cf7c9be3c0faf7e37347&gt;::&lt;lambda_invoker_cdecl&gt;</span><br><span class="line"><span class="number">06</span> dll3!AutoRunner::AutoRunner  <span class="comment">//&lt;----</span></span><br><span class="line">07 dll3!`dynamic initializer for 's_auto_runner_23''</span><br><span class="line"><span class="number">08</span> ucrtbased!_initterm</span><br><span class="line"><span class="number">09</span> dll3!dllmain_crt_process_attach</span><br><span class="line"><span class="number">0</span>a dll3!dllmain_crt_dispatch</span><br><span class="line"><span class="number">0b</span> dll3!dllmain_dispatch</span><br><span class="line"><span class="number">0</span>c dll3!_DllMainCRTStartup</span><br><span class="line"><span class="number">0</span>d ntdll!LdrpCallInitRoutine</span><br><span class="line"><span class="number">0</span>e ntdll!LdrpInitializeNode</span><br><span class="line"><span class="number">0f</span> ntdll!LdrpInitializeGraphRecurse</span><br><span class="line"><span class="number">10</span> ntdll!LdrpPrepareModuleForExecution</span><br><span class="line"><span class="number">11</span> ntdll!LdrpLoadDllInternal</span><br><span class="line"><span class="number">12</span> ntdll!LdrpLoadDll</span><br><span class="line"><span class="number">13</span> ntdll!LdrLoadDll</span><br><span class="line"><span class="number">14</span> KERNELBASE!LoadLibraryExW</span><br><span class="line"><span class="number">15</span> dll2!MyGlobalVariable::MyGlobalVariable   <span class="comment">//&lt;----</span></span><br><span class="line">16 dll2!`dynamic initializer for 's_culprit''</span><br><span class="line"><span class="number">17</span> ucrtbased!_initterm</span><br><span class="line"><span class="number">18</span> dll2!dllmain_crt_process_attach</span><br><span class="line"><span class="number">19</span> dll2!dllmain_crt_dispatch</span><br><span class="line"><span class="number">1</span>a dll2!dllmain_dispatch</span><br><span class="line"><span class="number">1b</span> dll2!_DllMainCRTStartup</span><br><span class="line"><span class="number">1</span>c ntdll!LdrpCallInitRoutine</span><br><span class="line"><span class="number">1</span>d ntdll!LdrpInitializeNode</span><br><span class="line"><span class="number">1</span>e ntdll!LdrpInitializeGraphRecurse</span><br><span class="line"><span class="number">1f</span> ntdll!LdrpInitializeGraphRecurse</span><br><span class="line"><span class="number">20</span> ntdll!LdrpPrepareModuleForExecution</span><br><span class="line"><span class="number">21</span> ntdll!LdrpLoadDllInternal</span><br><span class="line"><span class="number">22</span> ntdll!LdrpLoadDll</span><br><span class="line"><span class="number">23</span> ntdll!LdrLoadDll</span><br><span class="line"><span class="number">24</span> KERNELBASE!LoadLibraryExW</span><br><span class="line"><span class="number">25</span> KERNELBASE!LoadLibraryExA</span><br><span class="line"><span class="number">26</span> KERNELBASE!LoadLibraryA</span><br><span class="line"><span class="number">27</span> LoadDlls!LoadPlugins  <span class="comment">//&lt;----</span></span><br><span class="line"><span class="number">28</span> LoadDlls!main</span><br><span class="line"><span class="number">29</span> LoadDlls!invoke_main</span><br><span class="line"><span class="number">2</span>a LoadDlls!__scrt_common_main_seh</span><br><span class="line"><span class="number">2b</span> LoadDlls!__scrt_common_main</span><br><span class="line"><span class="number">2</span>c LoadDlls!mainCRTStartup</span><br><span class="line"><span class="number">2</span>d KERNEL32!BaseThreadInitThunk</span><br><span class="line"><span class="number">2</span>e ntdll!RtlUserThreadStart</span><br></pre></td></tr></table></figure><p>在 <code>windbg</code> 中输入 <code>.frame 0x27</code> 切换到 <code>0x27</code> 栈帧，然后输入 <code>dv</code> 查看局部变量，可以发现确实是在加载 <code>dll1.dll</code>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span>:<span class="number">000</span>&gt; .frame <span class="number">0x27</span></span><br><span class="line"><span class="number">27</span> <span class="number">000000</span>d5`<span class="number">3</span>a4ff610 <span class="number">00007f</span>f7`da7debb7     LoadDlls!LoadPlugins+<span class="number">0xb3</span> [D:\MyBlogStuff\LoadDlls\src\LoadDlls\LoadDlls.cpp @ <span class="number">19</span>] </span><br><span class="line"><span class="number">0</span>:<span class="number">000</span>&gt; dv</span><br><span class="line">         <span class="keyword">module</span> = <span class="number">0xcccccccc</span>`cccccccc</span><br><span class="line">         plugin = <span class="number">0x00007ff7</span>`da7ea740 <span class="string">"dll1.dll"</span></span><br><span class="line">            idx = <span class="number">0</span>n0</span><br><span class="line">        plugins = <span class="number">0x000000d5</span>`<span class="number">3</span>a4ff868</span><br><span class="line">         result = &#123; size=<span class="number">0x0</span> &#125;</span><br></pre></td></tr></table></figure><p>结合代码可以整理整个执行流程，大概是这样的：</p><ul><li><p>主程序 <code>LoadDlls.exe</code> 会通过 <code>LoadPlugins()</code> 调用 <code>LoadLibrary()</code> 来加载 <code>dll1.dll</code>，由于 <code>dll1.dll</code> 隐式依赖了 <code>dll2.dll</code>，所以 <code>dll1.dll</code> 加载的时候会自动加载 <code>dll2.dll</code>。</p></li><li><p><code>dll2.dll</code> 中的全局变量 <code>s_culprit</code> 的构造函数（栈帧 <code>0x15</code>）内部会调用 <code>LoadLibrary()</code> 加载 <code>dll3.dll</code>（栈帧 <code>0x14</code>）</p></li><li><p><code>dll3.dll</code> 中的全局变量 <code>s_auto_runner_23</code> 的构造函数（栈帧 <code>0x6</code>）内部会调用 <code>dll2.dll</code> 的导出函数 <code>RegisterCallback()</code>（栈帧 <code>0x3</code>）</p></li><li><p><code>RegisterCallback()</code> 内部会调用 <code>s_callbacks.insert()</code> 把注册的回调函数保存起来，但是在保存过程中遇到了异常，中断到了 <code>windbg</code> 中。</p></li></ul><h2 id="查看异常"><a href="#查看异常" class="headerlink" title="查看异常"></a>查看异常</h2><p>根据 <code>windbg</code> 给出的提示，可以发现是在读取地址 <code>0x00000008</code> 的时候发生了异常，此地址明显是不可访问的。</p><p><code>00007ffd 57684ff1 488b4008    mov rax,qword ptr [rax+8] ds:00000000 00000008=????????????????</code></p><p>看上去非常像是空指针异常。这段代码是在调用  <code>s_callbacks.insert()</code> 的时候执行的，大概率是 <code>s_callbacks</code> 出了问题，在 <code>windbg</code> 中使用 <code>dx s_callbacks -r4</code> 查看  <code>s_callbacks</code> 的值，如下图：</p><p><img src="http://resources.bianchengnan.tech/debug-another-dll-load-failure-caused-by-global-variable-initialize-dependency-part1/view-s_callbacks.png" alt="view-s_callbacks"></p><p>可以发现，<code>s_callbacks</code> 中的值很奇怪，都是空值。看上去很像还没有初始化的样子。</p><p>结合上面整理的调用流程，可以发现是在调用 <code>dll2!s_culprit</code> 的构造函数时接触发了对 <code>dll2!RegisterCallback()</code> 的调用，这时 <code>dll2!s_callbacks</code> 这个全局变量还没有初始化。</p><p>因为初始化完 <code>dll2!s_culprit</code>，才会初始化 <code>dll2!s_callbacks</code>。</p><p>至此，可以破案了。只需要调整一下这两个全局变量的顺序，问题就解决了。修改后的代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//MyGlobalVariable s_culprit; // 移动到 s_callbacks 下面</span></span><br><span class="line"></span><br><span class="line"><span class="comment">///////////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="keyword">static</span> <span class="built_in">std</span>::<span class="built_in">map</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>, <span class="keyword">void</span>(*)()&gt; s_callbacks;</span><br><span class="line"></span><br><span class="line">MyGlobalVariable s_culprit;</span><br></pre></td></tr></table></figure><h2 id="亲自动手"><a href="#亲自动手" class="headerlink" title="亲自动手"></a>亲自动手</h2><p>相关工程代码已经上传到 <a href="https://github.com/BianChengNan/MyBlogStuff/tree/master/debug-another-dll-load-failure-caused-by-global-variable-initialize-dependency-part1/LoadDlls" target="_blank" rel="noopener">github</a> 了，感兴趣的小伙伴儿可以下载验证。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本次故障是因为在 <code>dll2.dll</code> 的全局变量 <code>s_culprit</code> 的构造函数中使用 <code>LoadLibrary()</code> 加载了 <code>dll3.dll</code>，而 <code>dll3.dll</code> 中的全局变量构造函数会调用 <code>dll2!RegisterCallback()</code>，这个函数内部会使用未初始化的全局变量 <code>dll2!s_callbacks</code>。因为此时正在初始化 <code>dll2!s_culprit</code> 的过程中，<code>dll2!s_culprit</code> 初始化完成后才会初始化 <code>dll2!s_callbacks</code>。</p><p>相较于之前的案例，这次的案例更复杂，涉及到了多个模块。单看每个模块，问题都不大，但是放到一起就触发了这个异常。</p><p>所以，尽量不要在全局变量的构造函数中做复杂的工作，尤其要避免类似 <code>LoadLibrary</code> 的操作。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://learn.microsoft.com/en-us/windows/win32/dlls/dynamic-link-library-best-practices" target="_blank" rel="noopener">https://learn.microsoft.com/en-us/windows/win32/dlls/dynamic-link-library-best-practices</a></li></ul><h2 id="彩蛋"><a href="#彩蛋" class="headerlink" title="彩蛋"></a>彩蛋</h2><p>其实，这个问题背后还有一个更隐蔽的 <code>bug</code>，不知道你是否看出来了呢？<code>stay tuned!</code></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;缘起&quot;&gt;&lt;a href=&quot;#缘起&quot; class=&quot;headerlink&quot; title=&quot;缘起&quot;&gt;&lt;/a&gt;缘起&lt;/h2&gt;&lt;p&gt;最近又遇到了一个程序功能不正常的问题，深入调查后发现与全局变量初始化顺序有非常大的关系，只不过这次更加隐蔽。&lt;/p&gt;
&lt;p&gt;之前总结了两篇与全局变量初始化顺序有关的文章，感兴趣的小伙伴儿可以参考&lt;a href=&quot;https://bianchengnan.github.io/articles/debugging-dll-load-failure-caused-by-global-variable-initialize-dependency/&quot;&gt;《调试实战 | dll 加载失败之全局变量初始化篇》&lt;/a&gt; 和 &lt;a href=&quot;https://bianchengnan.github.io/articles/global-variable-initialization-order-investigation/&quot;&gt;《调试实战 | 全局变量初始化顺序探究》&lt;/a&gt;。&lt;/p&gt;
    
    </summary>
    
      <category term="调试" scheme="https://bianchengnan.github.io/categories/%E8%B0%83%E8%AF%95/"/>
    
    
      <category term="调试" scheme="https://bianchengnan.github.io/tags/%E8%B0%83%E8%AF%95/"/>
    
      <category term="debug" scheme="https://bianchengnan.github.io/tags/debug/"/>
    
      <category term="windbg" scheme="https://bianchengnan.github.io/tags/windbg/"/>
    
      <category term="dll" scheme="https://bianchengnan.github.io/tags/dll/"/>
    
      <category term="全局变量" scheme="https://bianchengnan.github.io/tags/%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F/"/>
    
  </entry>
  
  <entry>
    <title>2024 开工喽</title>
    <link href="https://bianchengnan.github.io//articles/2024-startup/"/>
    <id>https://bianchengnan.github.io//articles/2024-startup/</id>
    <published>2024-02-20T13:15:25.000Z</published>
    <updated>2024-12-21T04:02:49.835Z</updated>
    
    <content type="html"><![CDATA[<h2 id="回首-2023"><a href="#回首-2023" class="headerlink" title="回首 2023"></a>回首 2023</h2><p>回顾整个 <code>2023</code> ，相比 <code>2022</code>  加班少了，工作没那么拼命了。</p><p>由于各种原因，年初立的 <code>flag</code> 好几个都没实现。</p><ul><li>公众号基本上处于鸽的状态</li><li>也没分享技术视频</li><li>语言倒是接触了一下 <code>rust</code>，但远没有达到能实战的地步</li><li>嘴没管住，腿倒是迈开了</li></ul><h2 id="展望-2024"><a href="#展望-2024" class="headerlink" title="展望 2024"></a>展望 2024</h2><p>我对 <code>2024</code> 这个数字感到非常亲切，<code>2024 = 1000 + 1024</code>，两个<strong>一千</strong></p><ul><li><p><strong>今年的首要任务依旧是锻炼身体</strong></p><p>本来计划 <code>2024</code> 年跑步作为日常锻炼的方式，结果 <code>2023</code> 年最后一次从公司跑回家后膝盖疼，<code>2024</code> 只能偶尔跑跑了</p></li></ul><ul><li><strong>继续遛狗</strong><br><code>2023</code> 花费了很大一部分时间在遛狗上，<code>2024</code> 继续努力。如果不是狗子的陪伴，估计我早抑郁了，感谢，感恩。</li></ul><ul><li><p><strong>坚持练习英语口语</strong></p><p>希望这次不要因为任何原因中断</p></li></ul><ul><li><p><strong>继续坚持分享技术文章</strong></p><p>遇到值得总结的问题，及时总结分享</p></li></ul><ul><li><p><strong>读一些非技术书籍</strong></p><p>之前看的书以技术书籍为主，<code>2024</code> 年争取多看些非技术的书籍</p></li></ul><ul><li><p><strong>做一些改变</strong></p><p>尽量熟悉 <code>AI</code> 相关的人和事</p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;回首-2023&quot;&gt;&lt;a href=&quot;#回首-2023&quot; class=&quot;headerlink&quot; title=&quot;回首 2023&quot;&gt;&lt;/a&gt;回首 2023&lt;/h2&gt;&lt;p&gt;回顾整个 &lt;code&gt;2023&lt;/code&gt; ，相比 &lt;code&gt;2022&lt;/code&gt;  加班少了
      
    
    </summary>
    
      <category term="年度总结" scheme="https://bianchengnan.github.io/categories/%E5%B9%B4%E5%BA%A6%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="原" scheme="https://bianchengnan.github.io/tags/%E5%8E%9F/"/>
    
  </entry>
  
  <entry>
    <title>调试实战 | 记一次有教益的递归栈查看（续）</title>
    <link href="https://bianchengnan.github.io//articles/how-to-view-startup-function-from-a-deep-recursive-stack-continue/"/>
    <id>https://bianchengnan.github.io//articles/how-to-view-startup-function-from-a-deep-recursive-stack-continue/</id>
    <published>2024-01-06T02:30:22.000Z</published>
    <updated>2024-12-21T04:02:50.317Z</updated>
    
    <content type="html"><![CDATA[<h2 id="缘起"><a href="#缘起" class="headerlink" title="缘起"></a>缘起</h2><p>在上篇<a href="https://bianchengnan.github.io/articles/how-to-view-startup-function-from-a-deep-recursive-stack/">文章</a>中介绍了在 <code>windbg</code> 中如何查看非常深的调用栈 —— 使用 <code>kN</code> 命令指定栈帧数。<code>kN</code> 虽好，但最多只能查看 <code>0xffff</code> 个栈帧。如果栈帧数量比 <code>0xffff</code> 还多，该如何查看呢？本文将介绍几种查看方法。</p><a id="more"></a><p>在介绍查看方法前，需要对线程栈的特点有个基本的认识。</p><h2 id="线程栈的关键特性"><a href="#线程栈的关键特性" class="headerlink" title="线程栈的关键特性"></a>线程栈的关键特性</h2><ul><li><p>线程栈是从高向低扩展的，当向栈上 <code>push</code> 一个值的时候，栈底指针 <code>esp</code> 的值会减小。</p></li><li><p>函数返回地址会保存到栈上：</p><p>函数 <code>A</code> 调用函数 <code>B</code> 的时候，会把 <code>B</code> 需要的参数根据调用约定放到对应的位置，有可能是通过寄存器传递，也有可能通过栈传递。处理完参数后会执行 <code>call B</code>，而 <code>call</code> 指令可以简单理解为以下两个操作：</p><ol><li><strong>把返回地址（调用函数 B 的下一条指令地址）入栈</strong></li><li><strong>跳转到函数 <code>B</code> 继续执行</strong></li></ol><p>如果函数 <code>B</code> 会调用另外一个函数 <code>C</code>，那么会遵循相同的规律：会把返回地址（ <strong><code>call C</code> 后面的地址</strong>）入栈，然后跳转到 <code>C</code> 继续执行。当 <code>C</code> 执行结束的时候，<code>CPU</code> 会从栈上把保存的返回地址弹出到 <code>rip</code> 中，这样就可以继续从函数 <code>B</code> 中调用函数 <code>C</code> 的下一条指令继续执行了。</p></li></ul><p>根据以上几点可以得到一个非常重要的结论：如果 <code>A</code> 调用了 <code>B</code>，<code>B</code> 又调用了 <code>C</code>，<code>C</code> 又调用了 <code>D</code>。那么 <code>B</code> 返回到 <code>A</code> 的地址在线程栈的高处，<code>C</code> 返回到 <code>B</code> 的地址在线程栈的低处，<code>D</code> 返回到 <code>C</code> 的地址在线程栈的最低处。</p><p>有了以上的基本认识，就可以使用以下几种方法查看调用栈了。</p><h2 id="查看方法"><a href="#查看方法" class="headerlink" title="查看方法"></a>查看方法</h2><p><strong>方法1：</strong>使用 <code>.kframes</code> 设置默认显示的栈帧数量</p><p>​    增大默认显示数量，这样就可以一次性显示更多的调用栈</p><p><strong>方法2：</strong>使用 <code>dps</code>，自己识别调用栈</p><p>​    可以灵活高效的从指定的位置开始查找</p><p><strong>方法3：</strong>使用 <code>k</code> 命令的时候指定 <code>StackPtr</code></p><p>​    可以从指定位置开始显示调用栈，不必从头开始显示</p><p>为了方便验证每种方法的可行性，我写了一个非常简单的递归调用测试程序，为了让调用栈可以更深一些，我修改了工程设置中的<strong>堆栈保留大小</strong>为 <code>0x70800000</code>（大概 <code>1.75 GB</code> ）。</p><h2 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Recursive</span><span class="params">(<span class="keyword">int</span> depth)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (depth &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        Recursive(--depth);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CallRecursive</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Recursive(<span class="number">0x7fffffff</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    CallRecursive();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试工程可以到<a href="https://github.com/bianchengnan/MyBlogStuff/tree/master/how-to-view-startup-function-from-a-deep-recursive-stack-continue" target="_blank" rel="noopener">这里</a>下载。</p><p>接下来依次介绍每种查看方法。</p><h2 id="方法1：使用-kframes-设置默认显示的栈帧数量"><a href="#方法1：使用-kframes-设置默认显示的栈帧数量" class="headerlink" title="方法1：使用 .kframes 设置默认显示的栈帧数量"></a>方法1：使用 <code>.kframes</code> 设置默认显示的栈帧数量</h2><p>在 <code>windbg</code> 的帮助文档中发现可以通过 <code>.kframes</code> 命令来设置 <code>k</code> 命令默认显示的栈帧数量。但是也不是可以显示无限多个栈帧。</p><p>那么通过 <code>.kframes</code> 可以设置的最大栈帧数是多少呢？通过几次尝试，我发现 <code>.kframes</code> 可以接受的最大值是 <code>32</code> 位的带符号整数的最大值，也就是 <code>0x7fffffff</code>（对应的十进制是 <code>2147483647</code>）。</p><p><img src="http://resources.bianchengnan.tech/how-to-view-startup-function-from-a-deep-recursive-stack-continue/try-to-find-max-kframes-number.png" alt="try-to-find-max-kframes-number"></p><p> 但是，如果通过 <code>.kframes</code> 命令把栈帧数设置为 <code>0x7fffffff</code> 后，再执行 <code>k</code> 命令，发现 <code>windbg</code> 会直接提示内存分配失败。</p><p><img src="http://resources.bianchengnan.tech/how-to-view-startup-function-from-a-deep-recursive-stack-continue/windbg-k-failed-after-kframes-set-to-0x7fffffff.png" alt="windbg-k-failed-after-kframes-set-to-0x7fffffff"></p><p>尝试把栈帧数设置为 <code>0x1000000</code>，再执行 <code>k</code> 命令，发现 <code>windbg</code> 的内存占用非常高，高峰期大概消耗了 <code>20GB</code> 的物理内存（下图中的 <code>Working Set</code> 列），经过将近两分钟的努力，最终还是以内存分配失败告终~</p><p><img src="http://resources.bianchengnan.tech/how-to-view-startup-function-from-a-deep-recursive-stack-continue/windbg-memory-usage-kframe-0x10000000.png" alt="windbg-memory-usage-kframe-0x10000000"></p><p>又试了几个更小的值，发现在我的机器上（<code>24GB</code> 物理内存）设置为 <code>0x1000000</code> 时可以输出结果，但是因为数据量太大了，等了半个多小时也没执行完~</p><p>虽然这次 <code>.kframes</code> 没能成功，但这绝对是一个非常值得了解的命令，可以处理绝大多数情况下的线程栈查看问题。</p><p><strong>优点：</strong> </p><ol><li>操作非常简单</li><li>可以处理绝大多数情况</li></ol><p><strong>缺点：</strong> </p><ol><li>会影响后续 <code>k</code> 命令默认显示效果（仅限当前调试会话，<code>windbg</code> 重启后会自动失效）</li><li>当调用栈过深的时候，<code>k</code> 命令可能会<strong>非常非常非常</strong>慢（对于示例程序，半个小时还没执行完）</li><li>内存占用可能会非常高（需要分配内存来显示对应的信息）</li><li>不能解决调用栈过深的问题（受到物理内存的限制）</li><li>很难找到一个合适的值（设置的太大，可能消耗过多的资源，运行慢；设置的太小，调用栈可能显示不全）</li></ol><h2 id="方法2：使用-dps，自己识别调用栈"><a href="#方法2：使用-dps，自己识别调用栈" class="headerlink" title="方法2：使用 dps，自己识别调用栈"></a>方法2：使用 <code>dps</code>，自己识别调用栈</h2><p>在 <code>windbg</code> 中可以通过 <code>dps</code> 以指针长度为单位打印出指定内存范围的值，同时会输出匹配的符号。</p><p><strong>操作步骤：</strong></p><ol><li>通过 <code>!teb</code> 指令找到栈顶（<code>StackBase</code>）的位置，然后减去一定的值（比如 <code>64kb</code>）得到一个较低的地址 <code>A</code>。</li><li>执行 <code>dps A StackBase</code>。如果输出结果中没有包含感兴趣的函数，可以减去一个更大的值，再次执行 <code>dps</code> 并查看输出结果，直到输出结果中包含感兴趣的函数为止。</li><li>根据 <code>dps</code> 的输出内容手动识别调用栈。</li></ol><p><strong>实战：</strong></p><p>通过 <code>!teb</code> 命令获取栈顶位置（<code>0000002a33800000</code>）然后减去 <code>64KB</code> （<code>0x10000</code>，也可以换成其它值，一般情况下 <code>64KB</code> 足够了）得到地址 <code>0000002a337f0000</code>，然后执行 <code>dps 0000002a337f0000 0000002a33800000</code>。或者可以直接直接输入 <code>dps 0000002a33800000-0x10000 0000002a33800000</code>。</p><p><img src="http://resources.bianchengnan.tech/how-to-view-startup-function-from-a-deep-recursive-stack-continue/windbg-dps.png" alt="windbg-dps"></p><p>根据 <code>dps</code> 的结果可知，已经包含了关键的递归函数 —— <code>TestDeepRecursive!Recursive</code>，可以根据此次 <code>dps</code> 的输出结果手动识别调用栈。拉到输出结果的最下方，可以看到输出结果如下图：</p><p><img src="http://resources.bianchengnan.tech/how-to-view-startup-function-from-a-deep-recursive-stack-continue/windbg-dps-manual-reconstruct-callstack.png" alt="windbg-dps-manual-reconstruct-callstack"></p><p>从上图可以看到 <code>main</code> 函数，<code>CallRecursive</code> 函数，<code>Recursive</code> 函数。而且与 <code>vs</code> 中的调用栈完美匹配。</p><p><img src="http://resources.bianchengnan.tech/how-to-view-startup-function-from-a-deep-recursive-stack-continue/view-callstack-in-vs.png" alt="view-callstack-in-vs"></p><blockquote><p><strong>说明：</strong> 输出结果中<strong>极有可能</strong>包含很多无关的信息（比如上图中的黄色高亮部分），需要仔细甄别。</p></blockquote><p><strong>优点：</strong> </p><ol><li>输出结果速度非常快</li><li>非常灵活，强大</li></ol><p><strong>缺点：</strong></p><ol><li>需要对线程栈有一定的认识</li><li>需要人肉识别调用栈，有一定难度</li><li>比较依赖调试符号，如果没有调试符号，只根据地址信息，很难找出关联关系</li><li>容易出错，因为栈上的内容比较杂，可能包含很多无关的信息</li></ol><h2 id="方法3：使用-k-命令的时候指定-StackPtr"><a href="#方法3：使用-k-命令的时候指定-StackPtr" class="headerlink" title="方法3：使用 k 命令的时候指定 StackPtr"></a>方法3：使用 <code>k</code> 命令的时候指定 <code>StackPtr</code></h2><p>前两种方法都有各自的优缺点，可以在前两种方法的基础上使用本方法——使用 <code>k</code> 命令的时候指定正确的 <code>StackPtr</code>，<code>windbg</code> 会自动帮我们识别调用栈。</p><p>使用本方法时需要传递一个<strong>正确</strong>的 <code>StackPtr</code>（调试 <code>x64</code> 程序时需要传递 <code>rsp</code>，调试 <code>x86</code> 程序时需要传递 <code>ebp</code>，也叫 <code>BasePtr</code> ），也可以同时指定要显示的栈帧数量。</p><p>关于 <code>k</code> 命令的帮助文档可以参考下图（截取自 <code>windbg</code> 帮助文档）：</p><p><img src="http://resources.bianchengnan.tech/how-to-view-startup-function-from-a-deep-recursive-stack-continue/windbg-k-command-help.png" alt="windbg-k-command-help"></p><p>如果传递的 <code>StackPtr</code> 不对，那么输出结果很可能是错误的。比如，我使用一个错误的值执行 <code>k=0x0000002a337ff938</code> 输出结果如下：</p><p><img src="http://resources.bianchengnan.tech/how-to-view-startup-function-from-a-deep-recursive-stack-continue/output-of-wrong-stackptr-k-command.png" alt="output-of-wrong-stackptr-k-command"></p><p>所以，传递一个正确的 <code>StackPtr</code> 是必须的。那么，该如何获取一个正确的 <code>StackPtr</code> 呢？有两个方法：</p><ol><li><p>执行 <code>k</code> 命令的时候，最左侧那一列就是 <code>rsp</code>（<code>x86</code> 程序对应着 <code>ebp</code>）。可以这样处理：先通过 <code>.kframes</code> 设置一个相对合理的值，然后执行 <code>k</code> 命令，等命令执行完，取最后一条输出结果的 <code>rsp</code> 的值，假设是 <code>00000029c3004040</code>，然后执行 <code>k=00000029c3004040 3</code>，就可以继续显示后续的三条调用栈了。重复此过程即可。<br><img src="http://resources.bianchengnan.tech/how-to-view-startup-function-from-a-deep-recursive-stack-continue/windbg-k-start-at-specific-address.png" alt="windbg-k-start-at-specific-address"><br>实际使用的时候，可以尽量每次多显示一些栈帧，如果调用栈非常深，需要重复的次数会很多，但总比不能查看强！</p></li><li><p>在 <code>dps</code> 的输出结果中 <strong>“猜”</strong> 一个 <code>ebp</code> 或者 <code>rsp</code> 的值。说是猜，其实是有规律的。</p><p>2.1 对于 <code>x86</code> 的程序，<code>ebp</code> 保存了调用者的 <code>ebp</code>，<code>ebp+4</code> 的位置保存了返回地址。<br><img src="http://resources.bianchengnan.tech/how-to-view-startup-function-from-a-deep-recursive-stack-continue/view-ebp-by-dps.png" alt="view-ebp-by-dps"></p><p>根据上图可以猜测，一个合法的 <code>ebp</code> 的值是 <code>0x009ef908</code>。</p><p>在 <code>windbg</code> 中输入 <code>k=0x09ef908 0x100</code>，可以得到下图完美的调用栈：<img src="http://resources.bianchengnan.tech/how-to-view-startup-function-from-a-deep-recursive-stack-continue/k-0x009ef908-0x100.png" alt="k-0x009ef908-0x100"></p><p>2.2 对于 <code>x64</code> 的程序，<code>rsp-8</code> 的位置保存了返回地址。可以根据有意义的符号名称对应的最左侧地址值 <code>+8</code> 得到 <code>rsp</code> 的值。</p><p><img src="http://resources.bianchengnan.tech/how-to-view-startup-function-from-a-deep-recursive-stack-continue/view-rsp-by-dps.png" alt="view-rsp-by-dps"></p><p>根据上图可知，一个合法的 <code>rsp</code> 的值是 <code>0x0000002a337ffbd0</code>。在 <code>windbg</code> 中输入 <code>k=0x0000002a337ffbd0 0x100</code>，可以得到下图完美的调用栈：</p><p><img src="http://resources.bianchengnan.tech/how-to-view-startup-function-from-a-deep-recursive-stack-continue/k-0000002a337ffbd0-0x100.png" alt="k-0000002a337ffbd0-0x100"></p></li></ol><p><strong>优点：</strong></p><ol><li>输出效率高，只需要显示关心的栈帧即可</li><li>不用自己识别调用栈，可以像普通的 <code>k</code> 命令一样输出调用栈</li></ol><p><strong>缺点：</strong></p><ol><li>需要指定一个合法的 <code>StackPtr</code>，不能随便指定</li><li>需要非常了解  <code>x86/x64</code> 程序的调用栈，这样才能比较快速准确的找到合法的 <code>StackPtr</code></li></ol><p>所以，<code>dps</code> <code>+</code> <code>k=StackPtr [FrameCount]</code> 是最高效，最优雅的解决方案。</p><blockquote><p><strong>说明：</strong> 如果知道了一个合法的 <code>StackPtr</code>，也可以先通过 <code>r rsp = StackPtr</code> 修改 <code>rsp</code> 寄存器的值，然后再执行 <code>k</code> 命令显示调用栈。但是这个方法有一个<strong>特别不好</strong>的地方，<code>rsp</code> 会被修改，后续用到 <code>rsp</code> 寄存器的命令都会受影响。因此，不推荐使用。</p></blockquote><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>使用 <code>.kframes</code> 可以设置默认显示的栈帧数，可以突破默认最多显示 <code>0xffff</code> 个栈帧的限制，但是注意如果设置的值太大，会非常消耗内存</li><li><code>dps</code> 可以按指针打印一系列的值，并且会显示匹配的符号。务必记住此命令，非常有用</li><li>使用 <code>k</code> 命令时，可以指定 <code>StackPtr</code> 来从指定位置开始显示调用栈</li><li>对于 <code>x86</code> 的程序，<code>ebp</code> 保存了调用者的 <code>ebp</code>，<code>ebp+4</code> 的位置保存了返回地址。<strong>非常重要！！！</strong></li><li>对于 <code>x64</code> 的程序，<code>rsp-8</code> 的位置保存了返回地址。<strong>非常重要！！！</strong></li></ul><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://devblogs.microsoft.com/oldnewthing/20130906-00/?p=3303" target="_blank" rel="noopener">https://devblogs.microsoft.com/oldnewthing/20130906-00/?p=3303</a></p><p><a href="https://blog.aaronballman.com/2011/07/reconstructing-a-corrupted-stack-crawl/" target="_blank" rel="noopener">https://blog.aaronballman.com/2011/07/reconstructing-a-corrupted-stack-crawl/</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;缘起&quot;&gt;&lt;a href=&quot;#缘起&quot; class=&quot;headerlink&quot; title=&quot;缘起&quot;&gt;&lt;/a&gt;缘起&lt;/h2&gt;&lt;p&gt;在上篇&lt;a href=&quot;https://bianchengnan.github.io/articles/how-to-view-startup-function-from-a-deep-recursive-stack/&quot;&gt;文章&lt;/a&gt;中介绍了在 &lt;code&gt;windbg&lt;/code&gt; 中如何查看非常深的调用栈 —— 使用 &lt;code&gt;kN&lt;/code&gt; 命令指定栈帧数。&lt;code&gt;kN&lt;/code&gt; 虽好，但最多只能查看 &lt;code&gt;0xffff&lt;/code&gt; 个栈帧。如果栈帧数量比 &lt;code&gt;0xffff&lt;/code&gt; 还多，该如何查看呢？本文将介绍几种查看方法。&lt;/p&gt;
    
    </summary>
    
      <category term="调试" scheme="https://bianchengnan.github.io/categories/%E8%B0%83%E8%AF%95/"/>
    
    
      <category term="调试" scheme="https://bianchengnan.github.io/tags/%E8%B0%83%E8%AF%95/"/>
    
      <category term="debug" scheme="https://bianchengnan.github.io/tags/debug/"/>
    
      <category term="windbg" scheme="https://bianchengnan.github.io/tags/windbg/"/>
    
      <category term="dump" scheme="https://bianchengnan.github.io/tags/dump/"/>
    
      <category term="stack" scheme="https://bianchengnan.github.io/tags/stack/"/>
    
      <category term="递归" scheme="https://bianchengnan.github.io/tags/%E9%80%92%E5%BD%92/"/>
    
      <category term="栈" scheme="https://bianchengnan.github.io/tags/%E6%A0%88/"/>
    
  </entry>
  
  <entry>
    <title>调试实战 | 记一次有教益的递归栈查看</title>
    <link href="https://bianchengnan.github.io//articles/how-to-view-startup-function-from-a-deep-recursive-stack/"/>
    <id>https://bianchengnan.github.io//articles/how-to-view-startup-function-from-a-deep-recursive-stack/</id>
    <published>2024-01-06T02:00:22.000Z</published>
    <updated>2024-12-21T04:02:50.339Z</updated>
    
    <content type="html"><![CDATA[<h2 id="缘起"><a href="#缘起" class="headerlink" title="缘起"></a>缘起</h2><p>最近，遇到了一个由于递归导致的卡死问题。这个问题非常有意思，值得总结。</p><p>你知道什么情况下无限递归会卡死，而不崩溃吗？你知道递归层数过多时，如何找到导致递归调用的函数吗？你知道如何快速找到关键线程吗？你知道如何附加到一个正在被调试的进程吗？你知道如何在 <code>windbg</code> 中显示指定数量的栈帧吗？</p><p>带着这些疑问，一起来看看这个非常有意思的问题吧。</p><blockquote><p><strong>说明：</strong> 文章末尾有这些问题的答案，可以直接跳到末尾查看。</p></blockquote><a id="more"></a><h2 id="初遇错误"><a href="#初遇错误" class="headerlink" title="初遇错误"></a>初遇错误</h2><p>程序在执行某个功能时，迟迟不能完成，通过任务管理器可以发现 <code>CPU</code> 使用率比较高（<code>12.47%</code>），大概耗尽了一个核心（机器是八核的，每个核心占 <code>12.5%</code>）。</p><p><img src="http://resources.bianchengnan.tech/how-to-view-startup-function-from-a-deep-recursive-stack/high-cpu.png" alt="high-cpu"></p><p>心中暗喜，大概率是遇到了死循环，应该很好解决。赶紧用 <code>vs</code> 附加上去看看。</p><h2 id="了解错误"><a href="#了解错误" class="headerlink" title="了解错误"></a>了解错误</h2><p>附加到被调试进程后，手动暂停，然后通过<strong>并行堆栈</strong>找到可疑线程。</p><blockquote><p><strong>温馨提示：</strong> 可以通过 <code>调试 -&gt; 窗口 -&gt; 并行堆栈</code> 打开<strong>并行堆栈</strong>视图，也可以使用快捷键 <code>Ctrl+Shift+D, S</code> 打开 。</p></blockquote><p>一般情况下调用栈最长的线程就是可疑线程。即使不是，也可以在<strong>并行堆栈</strong>视图中快速切换线程。相比于手动一个个切换线程，并行堆栈简直是太方便了！</p><p><img src="http://resources.bianchengnan.tech/how-to-view-startup-function-from-a-deep-recursive-stack/view-thread-stack.png" alt="view-thread-stack"></p><p>通过并行堆栈视图，可以观察到当前线程的调用栈非常深，已经超出了 <code>vs</code> 所支持的最大栈帧数。仔细观察调用栈，可以发现 <code>00007ffc9dcb3cb5</code> 这个地址会<strong>重复</strong>出现，说明这很可能是一个递归问题。</p><p>然而，只知道这是一个递归问题还不够，我们需要找到引发递归调用的函数。如果能看到完整的调用栈，那么就可以找到罪魁祸首了。由于 <code>vs</code> 不能显示更多的调用栈帧，我们可以请老朋友 <code>windbg</code> 出马。</p><h2 id="请出-windbg"><a href="#请出-windbg" class="headerlink" title="请出 windbg"></a>请出 windbg</h2><p>启动 <code>windbg</code>，以 <code>Noninvasive</code> 模式附加到被调试进程（由于该进程正在被 <code>vs</code> 调试，如果不以 <code>Noninvasive</code> 模式附加，<code>windbg</code> 无法成功附加）。</p><p><img src="http://resources.bianchengnan.tech/how-to-view-startup-function-from-a-deep-recursive-stack/windbg-noninvasive-attach.png" alt="windbg-noninvasive-attach"></p><p>附加成功后，通过 <code>~~[12544]s</code> 切换到目标线程，没想到报错了。</p><p><img src="http://resources.bianchengnan.tech/how-to-view-startup-function-from-a-deep-recursive-stack/windbg-switch-thread-error.png" alt="windbg-switch-thread-error"></p><p>没关系，直接切不过去，还有其它方法可以找到目标线程。可以简单粗暴的使用 <code>~* k</code> 命令显示所有线程的调用栈，然后根据调用栈判断哪个线程是目标线程，也可以通过 <code>!runaway</code> 查看所有线程的运行时间，根据运行时间长短快速找出目标线程。</p><h2 id="runaway"><a href="#runaway" class="headerlink" title="!runaway"></a>!runaway</h2><p>在 <code>windbg</code> 中输入 <code>!runaway</code> 可以查看所有线程的运行时间。一般，<code>CPU</code> 占用率越高的线程，运行时间也越长。</p><p><img src="http://resources.bianchengnan.tech/how-to-view-startup-function-from-a-deep-recursive-stack/windbg-runaway.png" alt="windbg-runaway"></p><p>可以发现 <code>0</code> 号线程运行时间最长，然后是 <code>32</code> 号线程。先切换到 <code>0</code> 号线程，执行 <code>k</code> 命令查看调用栈，发现是主线程（一般情况下 <code>0</code> 号线程都是主线程），不是我们关心的线程。再执行 <code>~32s</code> 切换到运行时间排名第二的线程，然后执行 <code>k</code> 命令查看调用栈，发现与在 <code>vs</code> 中看到的调用栈吻合，<code>32</code> 号线程是目标线程了。</p><blockquote><p>*<em>说明： *</em> 当时比较着急，忘了 <code>windbg</code> 中默认使用十六进制。如果执行 <code>~~[0n12544]s</code> 即可正常切换过去了。<code>0n</code> 表示使用十进制。</p><p><img src="http://resources.bianchengnan.tech/how-to-view-startup-function-from-a-deep-recursive-stack/switch-to-0n12544-successfully.png" alt="switch-to-0n12544-successfully"></p></blockquote><p>找到对应的线程后，接下来的任务是查看完整调用栈。</p><h2 id="查看完整调用栈"><a href="#查看完整调用栈" class="headerlink" title="查看完整调用栈"></a>查看完整调用栈</h2><p>默认情况下，<code>windbg</code> 的 <code>k</code> 命令最多只显示 <code>256</code> 个调用栈帧，最大的栈帧号是 <code>ff</code>，从 <code>0</code> 开始计数。</p><p><img src="http://resources.bianchengnan.tech/how-to-view-startup-function-from-a-deep-recursive-stack/windbg-k-output-default.png" alt="windbg-k-output-default"></p><p>我们可以在 <code>windbg</code> 中执行 <code>kN</code>来指定要显示的栈帧数，如果 <code>N</code> 足够大，那么应该可以显示出完整的调用栈。</p><p>先尝试输入 <code>k200</code>，发现看不到头，再试试 <code>k2000</code>，依然看不到头，<code>k5000</code> 依然看不到头（这调用栈不是一般的深啊~）。 直接输入 <code>k50000</code>，这次应该够了吧？没想到报错了。</p><p><img src="http://resources.bianchengnan.tech/how-to-view-startup-function-from-a-deep-recursive-stack/windbg-k50000-error.png" alt="windbg-k50000-error"></p><p>根据提示可知，可以输入的最大值是 <code>0xffff</code>。在 <code>windbg</code> 中输入 <code>k0xffff</code>，耐心等待一会儿就可以看到完整的调用栈了。如下图：</p><p><img src="http://resources.bianchengnan.tech/how-to-view-startup-function-from-a-deep-recursive-stack/view-full-callstack-in-windbg.png" alt="view-full-callstack-in-windbg"></p><blockquote><p><strong>说明：</strong> 不要输入 <code>kffff</code>，因为会被解释为  <code>kf fff</code>，第一个 <code>f</code> 会被解释为选项，用来显示两个栈帧的间距。<img src="http://resources.bianchengnan.tech/how-to-view-startup-function-from-a-deep-recursive-stack/windbg-k-command-help.png" alt="windbg-k-command-help"></p></blockquote><h2 id="调用栈深的异常"><a href="#调用栈深的异常" class="headerlink" title="调用栈深的异常"></a>调用栈深的异常</h2><p>调用栈深的有点异常，总共有 <code>0x9032 + 1</code> 个栈帧（即 <code>36915</code> 个）。这样深的调用栈却未发生栈溢出，实属不可思议。要知道，线程栈预留空间默认只有 <code>1MB</code>。</p><p>在 <code>windbg</code> 中查看当前线程栈信息，重点查看线程栈总大小和当前已使用大小（具体查看方法可以参考<a href="https://bianchengnan.github.io/articles/how-to-check-thread-stack-base/">这篇文章</a>）。</p><p><img src="http://resources.bianchengnan.tech/how-to-view-startup-function-from-a-deep-recursive-stack/view-stack-total-size-and-current-used-size.png" alt="view-stack-total-size-and-current-used-size"></p><p>可以发现，线程栈预留空间大约是 <code>1.757 GB</code>，当前已使用大小大约是 <code>64.07 MB</code>。</p><p>说实话，我还是头一次遇到这么<strong>巨大</strong>的栈空间，难怪调用栈如此深却没有发生栈溢出。</p><p>但是等一下，线程栈怎么会这么大？默认不是只有 <code>1MB</code> 吗？是在创建线程的时候指定了<strong>线程栈预留空间</strong>大小？还是 <code>64</code> 位程序编译时使用的<strong>线程栈预留空间</strong>的默认值发生了变化，或者被手动修改了？又或者是有人调整了 <code>PE</code> 文件头中的 <code>SizeOfStackReserve</code> 值？</p><p>不论是修改编译参数，还是手动修改 <code>PE</code> 头，这些操作最终都会体现在 <code>PE</code> 文件上。先使用 <code>CFF Explorer</code> 查看 <code>PE</code> 文件头。</p><h2 id="查看-PE-头"><a href="#查看-PE-头" class="headerlink" title="查看 PE 头"></a>查看 PE 头</h2><p>果然，<code>PE</code> 文件头中的 <code>SizeOfStackReserve</code> 变成了 <code>0x0000000070800000</code> ，与上面在 <code>windbg</code> 中看到的线程栈总大小是一致的。<br><img src="http://resources.bianchengnan.tech/how-to-view-startup-function-from-a-deep-recursive-stack/view-pe-header.png" alt="view-pe-header"></p><p>为了验证是不是 <code>64</code> 位程序默认编译参数导致的，我特意建了一个简单的控制台程序，查看了工程设置参数，发现与 <code>32</code> 位程序一样，<strong>线程栈预留空间</strong>默认大小是 <code>1MB</code>。</p><p>一般不会有人修改生成的 <code>PE</code> 文件，回想到总是遇到栈溢出问题，猜测极有可能是某位同事修改了工程设置。不过栈空间修改的这么大，确实有待商榷。</p><p>至此，基本可以结案了。</p><h2 id="结案"><a href="#结案" class="headerlink" title="结案"></a>结案</h2><p>虽然递归了，调用栈很深，但是由于栈空间非常大，所以<strong>一时半会儿</strong>还不会导致栈溢出。最终看到的现象就是卡死、<code>CPU</code> 占用率高，而不是崩溃。当然，最终栈空间耗尽后，还是会触发栈溢出异常的。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>在 <code>windbg</code> 中可以通过 <code>kN</code> 查看指定数量的调用栈。只要 <code>N</code> 足够大，基本上可以看到完整的调用栈，但是默认情况下，<code>N</code> 不能超过 <code>0xffff</code>。</li><li>在 <code>vs</code> 中可以通过<strong>并行堆栈</strong>快速查看各个线程的调用栈，从而可以快速找到关键线程。强烈推荐！</li><li>在 <code>windbg</code> 中可以使用 <code>~* k</code> 快速查看所有线程的调用栈，与 <code>vs</code> 中的<strong>并行堆栈</strong>功能不相上下。</li><li>在 <code>windbg</code> 中可以通过 <code>!runaway</code> 查看运行时间最长的线程，从而可以快速找到关键线程。</li><li><code>windbg</code> 可以以 <code>Noninvasive</code> 的形式附加到一个正在被调试的进程。</li><li><code>PE</code> 文件头中的 <code>SizeOfStackReserve</code> 决定了线程栈预留空间的大小，可以手动修改此值来调整线程的默认栈预留空间大小。</li><li>在 <code>vs</code> 工程中可以通过修改<strong>堆栈保留大小</strong>选项（单位是字节）来控制 <code>PE</code> 文件头中的 <code>SizeOfStackReserve</code> 的值。</li></ul><h2 id="More"><a href="#More" class="headerlink" title="More"></a>More</h2><p>如果调用栈深度超出了 <code>0xffff</code>，该如何查看完整的调用栈呢？下篇更精彩，敬请期待~~</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;缘起&quot;&gt;&lt;a href=&quot;#缘起&quot; class=&quot;headerlink&quot; title=&quot;缘起&quot;&gt;&lt;/a&gt;缘起&lt;/h2&gt;&lt;p&gt;最近，遇到了一个由于递归导致的卡死问题。这个问题非常有意思，值得总结。&lt;/p&gt;
&lt;p&gt;你知道什么情况下无限递归会卡死，而不崩溃吗？你知道递归层数过多时，如何找到导致递归调用的函数吗？你知道如何快速找到关键线程吗？你知道如何附加到一个正在被调试的进程吗？你知道如何在 &lt;code&gt;windbg&lt;/code&gt; 中显示指定数量的栈帧吗？&lt;/p&gt;
&lt;p&gt;带着这些疑问，一起来看看这个非常有意思的问题吧。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;说明：&lt;/strong&gt; 文章末尾有这些问题的答案，可以直接跳到末尾查看。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="调试" scheme="https://bianchengnan.github.io/categories/%E8%B0%83%E8%AF%95/"/>
    
    
      <category term="调试" scheme="https://bianchengnan.github.io/tags/%E8%B0%83%E8%AF%95/"/>
    
      <category term="debug" scheme="https://bianchengnan.github.io/tags/debug/"/>
    
      <category term="windbg" scheme="https://bianchengnan.github.io/tags/windbg/"/>
    
      <category term="dump" scheme="https://bianchengnan.github.io/tags/dump/"/>
    
      <category term="stack" scheme="https://bianchengnan.github.io/tags/stack/"/>
    
      <category term="递归" scheme="https://bianchengnan.github.io/tags/%E9%80%92%E5%BD%92/"/>
    
      <category term="栈" scheme="https://bianchengnan.github.io/tags/%E6%A0%88/"/>
    
  </entry>
  
  <entry>
    <title>调试实战 | 从转储文件找出抛出的异常 —— 实战</title>
    <link href="https://bianchengnan.github.io//articles/search-throwing-exception-from-dump-file-part2/"/>
    <id>https://bianchengnan.github.io//articles/search-throwing-exception-from-dump-file-part2/</id>
    <published>2023-12-31T10:36:41.000Z</published>
    <updated>2024-12-21T04:02:50.545Z</updated>
    
    <content type="html"><![CDATA[<h2 id="缘起"><a href="#缘起" class="headerlink" title="缘起"></a>缘起</h2><p>我在<a href="https://bianchengnan.github.io/articles/search-throwing-exception-from-dump-file-part1/">上一篇文章</a>中介绍了定位抛出异常的理论知识，本文会通过几个实例介绍各种情况下的定位方法。有调试符号如何定位？没有调试符号如何定位？<code>32</code> 位程序如何定位？<code>64</code> 位程序又该如何定位？</p><p>其实，<code>32</code> 位程序和 <code>64</code> 位程序定位过程大同小异，只不过在解析过程中需要注意，很多关键字段在 <code>64</code> 位程序中是偏移，需要加上模块基址得到虚拟地址后才能使用，而在 <code>32</code> 位程序中对应的字段就是虚拟地址，可以直接使用。</p><p>没有调试符号的时候定位异常类型会比较困难，需要根据上一篇文章中总结的步骤一步步的找到异常类型。有调试符号的情况会比较容易，有很多简便的查看方法。</p><p>一起来实战吧！</p><a id="more"></a><p>在开始实战之前，把相关结构体再贴一下，方便参考。</p><h2 id="32-位关键结构"><a href="#32-位关键结构" class="headerlink" title="32 位关键结构"></a>32 位关键结构</h2> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span>:<span class="number">000</span>&gt; dt EHExceptionRecord</span><br><span class="line">TestThrowException!EHExceptionRecord</span><br><span class="line">   +<span class="number">0x000</span> ExceptionCode    : Uint4B</span><br><span class="line">   +<span class="number">0x004</span> ExceptionFlags   : Uint4B</span><br><span class="line">   +<span class="number">0x008</span> ExceptionRecord  : Ptr32 _EXCEPTION_RECORD</span><br><span class="line">   +<span class="number">0x00c</span> ExceptionAddress : Ptr32 Void</span><br><span class="line">   +<span class="number">0x010</span> NumberParameters : Uint4B</span><br><span class="line">   +<span class="number">0x014</span> params           : EHExceptionRecord::EHParameters <span class="comment">//&lt;----</span></span><br><span class="line"></span><br><span class="line"><span class="number">0</span>:<span class="number">000</span>&gt; dt EHExceptionRecord::EHParameters</span><br><span class="line">TestThrowException!EHExceptionRecord::EHParameters</span><br><span class="line">   +<span class="number">0x000</span> magicNumber      : Uint4B</span><br><span class="line">   +<span class="number">0x004</span> pExceptionObject : Ptr32 Void</span><br><span class="line">   +<span class="number">0x008</span> pThrowInfo       : Ptr32 _s_ThrowInfo <span class="comment">//&lt;----</span></span><br><span class="line"></span><br><span class="line"><span class="number">0</span>:<span class="number">000</span>&gt; dt _s_ThrowInfo</span><br><span class="line">TestThrowException!_s_ThrowInfo</span><br><span class="line">   +<span class="number">0x000</span> attributes       : Uint4B</span><br><span class="line">   +<span class="number">0x004</span> pmfnUnwind       : Ptr32     <span class="keyword">void</span> </span><br><span class="line">   +<span class="number">0x008</span> pForwardCompat   : Ptr32     <span class="keyword">int</span> </span><br><span class="line">   +<span class="number">0x00c</span> pCatchableTypeArray : Ptr32 _s_CatchableTypeArray <span class="comment">//&lt;----</span></span><br><span class="line"></span><br><span class="line"><span class="number">0</span>:<span class="number">000</span>&gt; dt _s_CatchableTypeArray</span><br><span class="line">TestThrowException!_s_CatchableTypeArray</span><br><span class="line">   +<span class="number">0x000</span> nCatchableTypes  : Int4B</span><br><span class="line">   +<span class="number">0x004</span> arrayOfCatchableTypes : [<span class="number">0</span>] Ptr32 _s_CatchableType <span class="comment">//&lt;----</span></span><br><span class="line"></span><br><span class="line"><span class="number">0</span>:<span class="number">000</span>&gt; dt _s_CatchableType</span><br><span class="line">TestThrowException!_s_CatchableType</span><br><span class="line">   +<span class="number">0x000</span> properties       : Uint4B</span><br><span class="line">   +<span class="number">0x004</span> pType            : Ptr32 TypeDescriptor <span class="comment">//&lt;----</span></span><br><span class="line">   +<span class="number">0x008</span> thisDisplacement : PMD</span><br><span class="line">   +<span class="number">0x014</span> sizeOrOffset     : Int4B</span><br><span class="line">   +<span class="number">0x018</span> copyFunction     : Ptr32     <span class="keyword">void</span></span><br><span class="line"></span><br><span class="line"><span class="number">0</span>:<span class="number">000</span>&gt; dt TypeDescriptor</span><br><span class="line">TestThrowException!TypeDescriptor</span><br><span class="line">   +<span class="number">0x000</span> hash             : Uint4B</span><br><span class="line">   +<span class="number">0x004</span> spare            : Ptr32 Void</span><br><span class="line">   +<span class="number">0x008</span> name             : [<span class="number">0</span>] Char <span class="comment">//&lt;====</span></span><br></pre></td></tr></table></figure><h2 id="64-位关键结构"><a href="#64-位关键结构" class="headerlink" title="64 位关键结构"></a>64 位关键结构</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span>:<span class="number">000</span>&gt; dt EHExceptionRecord</span><br><span class="line">VCRUNTIME140!EHExceptionRecord</span><br><span class="line">   +<span class="number">0x000</span> ExceptionCode    : Uint4B</span><br><span class="line">   +<span class="number">0x004</span> ExceptionFlags   : Uint4B</span><br><span class="line">   +<span class="number">0x008</span> ExceptionRecord  : Ptr64 _EXCEPTION_RECORD</span><br><span class="line">   +<span class="number">0x010</span> ExceptionAddress : Ptr64 Void</span><br><span class="line">   +<span class="number">0x018</span> NumberParameters : Uint4B</span><br><span class="line">   +<span class="number">0x020</span> params           : EHExceptionRecord::EHParameters <span class="comment">//&lt;----</span></span><br><span class="line"></span><br><span class="line"><span class="number">0</span>:<span class="number">000</span>&gt; dt EHExceptionRecord::EHParameters</span><br><span class="line">VCRUNTIME140!EHExceptionRecord::EHParameters</span><br><span class="line">   +<span class="number">0x000</span> magicNumber      : Uint4B</span><br><span class="line">   +<span class="number">0x008</span> pExceptionObject : Ptr64 Void</span><br><span class="line">   +<span class="number">0x010</span> pThrowInfo       : Ptr64 _s_ThrowInfo <span class="comment">//&lt;----</span></span><br><span class="line">   +<span class="number">0x018</span> pThrowImageBase  : Ptr64 Void</span><br><span class="line"></span><br><span class="line"><span class="number">0</span>:<span class="number">000</span>&gt; dt _s_ThrowInfo</span><br><span class="line">VCRUNTIME140!_s_ThrowInfo</span><br><span class="line">   +<span class="number">0x000</span> attributes       : Uint4B</span><br><span class="line">   +<span class="number">0x004</span> pmfnUnwind       : Int4B</span><br><span class="line">   +<span class="number">0x008</span> pForwardCompat   : Int4B</span><br><span class="line">   +<span class="number">0x00c</span> pCatchableTypeArray : Int4B <span class="comment">//&lt;----</span></span><br><span class="line"></span><br><span class="line"><span class="number">0</span>:<span class="number">000</span>&gt; dt CatchableTypeArray</span><br><span class="line">VCRUNTIME140!CatchableTypeArray</span><br><span class="line">   +<span class="number">0x000</span> nCatchableTypes  : Int4B</span><br><span class="line">   +<span class="number">0x004</span> arrayOfCatchableTypes : [<span class="number">0</span>] Int4B <span class="comment">//&lt;----</span></span><br><span class="line"></span><br><span class="line"><span class="number">0</span>:<span class="number">000</span>&gt; dt CatchableType</span><br><span class="line">VCRUNTIME140!CatchableType</span><br><span class="line">   +<span class="number">0x000</span> properties       : Uint4B</span><br><span class="line">   +<span class="number">0x004</span> pType            : Int4B <span class="comment">//&lt;----</span></span><br><span class="line">   +<span class="number">0x008</span> thisDisplacement : PMD</span><br><span class="line">   +<span class="number">0x014</span> sizeOrOffset     : Int4B</span><br><span class="line">   +<span class="number">0x018</span> copyFunction     : Int4B</span><br><span class="line"></span><br><span class="line"><span class="number">0</span>:<span class="number">000</span>&gt; dt TypeDescriptor</span><br><span class="line">VCRUNTIME140!TypeDescriptor</span><br><span class="line">   +<span class="number">0x000</span> pVFTable         : Ptr64 Void</span><br><span class="line">   +<span class="number">0x008</span> spare            : Ptr64 Void</span><br><span class="line">   +<span class="number">0x010</span> name             : [<span class="number">0</span>] Char <span class="comment">//&lt;====</span></span><br></pre></td></tr></table></figure><p>接下来，先介绍无调试符号时的定位方法，然后再介绍有调试符号时的定位方法。</p><h2 id="无调试符号"><a href="#无调试符号" class="headerlink" title="无调试符号"></a>无调试符号</h2><p>如果没有导致异常的模块的调试符号，定位过程会比较复杂，需要根据上一篇文章中总结的方法一步步定位。此方法的坏处是麻烦，好处是比较通用，任何情况下都可以使用。</p><h3 id="64-位程序"><a href="#64-位程序" class="headerlink" title="64 位程序"></a>64 位程序</h3><ol><li><p>获取 <code>EHParameters</code> 的地址。<code>_CxxThrowException</code> 栈帧的 <code>rsp+0x28</code> 指向了 <code>EHParameters</code>。</p><p><code>_CxxThrowException</code> 对应栈帧的 <code>rsp</code> 是 <code>000000b9f2effb80</code>。在 <code>windbg</code> 中输入 <code>? 000000b9f2effb80 + 0x28</code>，如下图：</p><p><img src="http://resources.bianchengnan.tech/search-throwing-exception-from-dump-file-part2/view-address-of-EHParameters.png" alt="view-address-of-EHParameters"></p><p>由上图红色高亮部分可知 <code>EHParameters</code> 的地址是 <code>000000b9f2effba8</code>。</p></li><li><p>获取 <code>ThrowInfo</code> 的地址。<code>EHParameters + 0x10</code> 的位置保存了 <code>ThrowInfo</code> 的地址，<code>EHParameters + 0x18</code> 的位置保存了异常模块基址。</p><p>在 <code>windbg</code> 中输入 <code>dq 000000b9f2effba8</code>，如下图：</p><p><img src="http://resources.bianchengnan.tech/search-throwing-exception-from-dump-file-part2/view-ThrowInfo-imagebase.png" alt="view-ThrowInfo-imagebase"></p><p>由上图红色高亮部分可知 <code>ThrowInfo</code> 的地址是 <code>00007ff71c542a20</code>，异常模块基址是 <code>00007ff71c540000</code>。</p><blockquote><p><strong>说明：</strong> 如果有 <code>vcruntimexxx.dll</code> 的调试符号，可以跳过前两步，直接切换到 <code>_CxxThrowException</code> 对应的栈帧即可得到 <code>ThrowInfo</code> 的地址和异常模块基址。</p></blockquote></li><li><p>获取 <code>CatchableTypeArray</code> 的地址。<code>ThrowInfo + 0xc</code> 保存了 <code>CatchableTypeArray</code> 的偏移。</p><p>在 <code>windbg</code> 中输入 <code>dd 00007ff71c542a20</code>，如下图：</p><p><img src="http://resources.bianchengnan.tech/search-throwing-exception-from-dump-file-part2/view-throwinfo.png" alt="view-throwinfo"></p><p>由上图红色高亮部分可知 <code>CatchableTypeArray</code> 的偏移是 <code>000029b8</code>。</p><p>异常模块基址是 <code>00007ff71c540000</code>，所以 <code>CatchableTypeArray</code> 的地址是 <code>00007ff71c540000 + 000029b8 = 00007ff71c5429b8</code>。</p></li><li><p>获取 <code>CatchableType</code> 的地址。<code>CatchableTypeArray + 0x04</code> 保存了第一个 <code>CatchableType</code> 对象的<strong>偏移</strong>，<code>CatchableTypeArray + 0x08</code> 保存了第二个 <code>CatchableType</code> 对象的<strong>偏移</strong>，以此类推。</p><p>在 <code>windbg</code> 中输入 <code>dd 00007ff71c5429b8</code>，如下图：</p><p><img src="http://resources.bianchengnan.tech/search-throwing-exception-from-dump-file-part2/view-CatchableTypeArray.png" alt="view-CatchableTypeArray"></p><p>由上图可知，一共有两个 <code>CatchableType</code> 类型的对象，第一个偏移是 <code>000029d0</code>，第二个偏移是 <code>000029f8</code>。</p><p>异常模块基址是 <code>00007ff71c540000</code>，所以第一个 <code>CatchableType</code> 对象的地址是 <code>00007ff71c540000 + 000029d0 = 00007ff71c5429d0</code>。</p></li><li><p>获取 <code>TypeDescriptor</code> 的地址。<code>CatchableType + 0x04</code> 保存了 <code>TypeDescriptor</code> 的偏移。</p><p>在 <code>windbg</code> 中输入 <code>dd 00007ff71c5429d0</code>，如下图：</p><p><img src="http://resources.bianchengnan.tech/search-throwing-exception-from-dump-file-part2/view-CatchableType.png" alt="view-CatchableType"></p><p>由上图红色高亮部分可知 <code>TypeDescriptor</code> 的偏移是 <code>00004058</code>。</p><p>异常模块基址是 <code>00007ff71c540000</code>，所以 <code>TypeDescriptor</code> 的地址是 <code>00007ff71c540000 + 00004058 = 00007ff71c544058</code>。</p></li><li><p>获取异常类型名。<code>TypeDescriptor + 0x10</code> 保存了编码后的异常类型名。</p><p>在 <code>windbg</code> 中输入 <code>da 00007ff71c544058 + 0x10</code>，如下图：</p><p><img src="http://resources.bianchengnan.tech/search-throwing-exception-from-dump-file-part2/view-TypeDescriptor.png" alt="view-TypeDescriptor"></p><p>从上图可知，异常类型是 <code>.?AVbad_alloc@std@@</code>，也就是 <code>std::bad_alloc</code>。</p></li></ol><h3 id="32-位程序"><a href="#32-位程序" class="headerlink" title="32 位程序"></a>32 位程序</h3><p><code>32</code> 位程序和 <code>64</code> 位程序定位过程大同小异，只需要把 <code>64</code> 位程序定位过程中的偏移值当成地址使用即可。这里就不赘述了，参考下图：</p><p><img src="http://resources.bianchengnan.tech/search-throwing-exception-from-dump-file-part2/view-exception-type-32-bit.png" alt="view-exception-type-32-bit"></p><p>其实，对于 <code>32</code> 位程序，如果有 <code>vcruntimexxx.dll</code> 对应的符号，还有一种极其简单的方法，在 <code>windbg</code> 中输入 <code>dt -r3 ThrowInfo address</code>，如下图：</p><p><img src="http://resources.bianchengnan.tech/search-throwing-exception-from-dump-file-part2/view-exception-type-by-dt-r3.png" alt="view-exception-type-by-dt-r3"></p><h2 id="有调试符号"><a href="#有调试符号" class="headerlink" title="有调试符号"></a>有调试符号</h2><p>对于有调试符号的情况，不仅可以使用无调试符号的定位方法，还可以使用更简单的方法查看——通过查看 <code>pExceptionObject</code> 对象的虚函数表来推断对应的对象类型。</p><p>在测试程序中，<code>pExceptionObject</code> 的地址是 <code>0x000000b9f2effc00</code>，可以在 <code>windbg</code> 中执行 <code>dps 0x000000b9f2effc00</code> 即可查看异常对象对应的虚表，如下图：</p><p><img src="http://resources.bianchengnan.tech/search-throwing-exception-from-dump-file-part2/view-exception-object-vtable.png" alt="view-exception-object-vtable"></p><p>从上图可知，异常类型是 <code>std::bad_alloc</code>，其虚表内容都是其基类（<code>std::exception</code>）的虚函数，因为  <code>std::bad_alloc</code> 没重写任何虚函数，也没新增任何虚函数。</p><p>为什么没调试符号的时候不能用这个方法呢？因为没有调试符号的情况下，从 <code>dps</code> 的输出结果中看不到关键的虚表名称，也就不能推断出具体的异常类型了。</p><p><img src="http://resources.bianchengnan.tech/search-throwing-exception-from-dump-file-part2/dps-result-no-symbol.png" alt="dps-result-no-symbol"></p><h2 id="亲自动手"><a href="#亲自动手" class="headerlink" title="亲自动手"></a>亲自动手</h2><p>对应的程序源码工程文件及对应的转储文件已经上传到我的个人仓库了，感兴趣的小伙伴儿可以从以下链接自行下载：</p><p><a href="https://github.com/bianchengnan/MyBlogStuff/tree/master/search-throwing-exception-from-dump-file-part2/TestThrowException" target="_blank" rel="noopener">https://github.com/bianchengnan/MyBlogStuff/tree/master/search-throwing-exception-from-dump-file-part2/TestThrowException</a></p><p>还有一个更真实的转储文件，可以实战一把。因为比较大，我传到百度云了，可以到这里下载：</p><p><a href="https://pan.baidu.com/s/1K7FzsseMlU6kmrMwm3jn4Q?pwd=8t47" target="_blank" rel="noopener">https://pan.baidu.com/s/1K7FzsseMlU6kmrMwm3jn4Q?pwd=8t47</a></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>获取通过 <code>throw</code> 抛出的异常的突破点在 <code>_CxxThrowException()</code> 函数，该函数有源码，涉及到的关键结构体都有源码可以查询。</li><li>查找 <code>throw</code> 抛出的异常，关在是掌握对应的数据结构，务必要把关键的数据结构牢记于心。</li><li>如果有调试符号，还可以直接查看  <code>pExceptionObject</code> 对象的虚函数表来进行推断。</li><li>在解析过程中，需要注意的是在 <code>64</code> 位程序中，很多成员变量都是相对于发生异常模块的偏移，而不是直接可用的地址，需要先把偏移转换成虚拟地址后再使用。</li></ul><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><code>vs</code> 源码</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;缘起&quot;&gt;&lt;a href=&quot;#缘起&quot; class=&quot;headerlink&quot; title=&quot;缘起&quot;&gt;&lt;/a&gt;缘起&lt;/h2&gt;&lt;p&gt;我在&lt;a href=&quot;https://bianchengnan.github.io/articles/search-throwing-exception-from-dump-file-part1/&quot;&gt;上一篇文章&lt;/a&gt;中介绍了定位抛出异常的理论知识，本文会通过几个实例介绍各种情况下的定位方法。有调试符号如何定位？没有调试符号如何定位？&lt;code&gt;32&lt;/code&gt; 位程序如何定位？&lt;code&gt;64&lt;/code&gt; 位程序又该如何定位？&lt;/p&gt;
&lt;p&gt;其实，&lt;code&gt;32&lt;/code&gt; 位程序和 &lt;code&gt;64&lt;/code&gt; 位程序定位过程大同小异，只不过在解析过程中需要注意，很多关键字段在 &lt;code&gt;64&lt;/code&gt; 位程序中是偏移，需要加上模块基址得到虚拟地址后才能使用，而在 &lt;code&gt;32&lt;/code&gt; 位程序中对应的字段就是虚拟地址，可以直接使用。&lt;/p&gt;
&lt;p&gt;没有调试符号的时候定位异常类型会比较困难，需要根据上一篇文章中总结的步骤一步步的找到异常类型。有调试符号的情况会比较容易，有很多简便的查看方法。&lt;/p&gt;
&lt;p&gt;一起来实战吧！&lt;/p&gt;
    
    </summary>
    
      <category term="调试" scheme="https://bianchengnan.github.io/categories/%E8%B0%83%E8%AF%95/"/>
    
    
      <category term="原" scheme="https://bianchengnan.github.io/tags/%E5%8E%9F/"/>
    
      <category term="总结" scheme="https://bianchengnan.github.io/tags/%E6%80%BB%E7%BB%93/"/>
    
      <category term="调试" scheme="https://bianchengnan.github.io/tags/%E8%B0%83%E8%AF%95/"/>
    
      <category term="异常" scheme="https://bianchengnan.github.io/tags/%E5%BC%82%E5%B8%B8/"/>
    
      <category term="debug" scheme="https://bianchengnan.github.io/tags/debug/"/>
    
      <category term="dump" scheme="https://bianchengnan.github.io/tags/dump/"/>
    
      <category term="转储文件" scheme="https://bianchengnan.github.io/tags/%E8%BD%AC%E5%82%A8%E6%96%87%E4%BB%B6/"/>
    
      <category term="part2" scheme="https://bianchengnan.github.io/tags/part2/"/>
    
      <category term="exception" scheme="https://bianchengnan.github.io/tags/exception/"/>
    
  </entry>
  
  <entry>
    <title>调试实战 | 从转储文件找出抛出的异常 —— 理论</title>
    <link href="https://bianchengnan.github.io//articles/search-throwing-exception-from-dump-file-part1/"/>
    <id>https://bianchengnan.github.io//articles/search-throwing-exception-from-dump-file-part1/</id>
    <published>2023-12-30T00:36:41.000Z</published>
    <updated>2024-12-21T04:02:50.537Z</updated>
    
    <content type="html"><![CDATA[<h2 id="缘起"><a href="#缘起" class="headerlink" title="缘起"></a>缘起</h2><p>最近在分析转储文件时，遇到了一个由 <code>throw</code> 抛出的异常。尽管在 <code>windbg</code> 中使用 <code>!analyze -v</code> 迅速知道了异常码是 <code>0xe06d7363</code>（对应的 <code>ASCII</code> 码是 <code>.msc</code>），但是根据异常码并不能确定具体抛出来的是哪种异常。针对这种情况，确定具体的异常类型才有意义。</p><p>本篇文章会简单介绍与抛出异常相关的内容，包括关键的函数及结构体。下一篇文章会通过实例介绍几种典型情况（有调试符号 / 没有调试符号 / <code>32</code> 位程序 / <code>64</code> 位程序）下的定位方法。</p><a id="more"></a><blockquote><p><strong>说明：</strong> 对源码不感兴趣的小伙伴而可以直接跳到【解析方法小结】查看结论。</p></blockquote><h2 id="突破口"><a href="#突破口" class="headerlink" title="突破口"></a>突破口</h2><p><code>throw</code> 关键字编译后对应的函数是 <code>_CxxThrowException()</code>，该函数内部会通过 <code>RaiseException()</code> 触发异常。<code>_CxxThrowException()</code> 是有源码可查的，我们可以从这个函数入手，先来熟悉下这个函数以及相关的结构体。</p><h2 id="CxxThrowException"><a href="#CxxThrowException" class="headerlink" title="_CxxThrowException"></a>_CxxThrowException</h2><p>该函数定义在 <code>vs</code> 自带的 <code>throw.cpp</code> 中，一般在 <code>crt\src\vcruntime\</code> 目录下。直接用 <code>everything</code> 搜索 <code>throw.cpp</code>，然后打开即可。<code>vs2019</code> 中的实现代码如下，有删减：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="string">"C"</span> __declspec(noreturn) <span class="keyword">void</span> __stdcall</span><br><span class="line">_CxxThrowException(</span><br><span class="line">  <span class="keyword">void</span>*       pExceptionObject, <span class="comment">// The object thrown</span></span><br><span class="line">  _ThrowInfo* pThrowInfo        <span class="comment">// Everything we need to know about it</span></span><br><span class="line">) &#123;</span><br><span class="line">    EHTRACE_ENTER_FMT1(<span class="string">"Throwing object @ 0x%p"</span>, pExceptionObject);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">const</span> EHExceptionRecord ExceptionTemplate = &#123; <span class="comment">// A generic exception record</span></span><br><span class="line">      EH_EXCEPTION_NUMBER,       <span class="comment">// Exception number</span></span><br><span class="line">      EXCEPTION_NONCONTINUABLE,  <span class="comment">// Exception flags (we don't do resume)</span></span><br><span class="line">      <span class="literal">nullptr</span>,                   <span class="comment">// Additional record (none)</span></span><br><span class="line">      <span class="literal">nullptr</span>,                   <span class="comment">// Address of exception (OS fills in)</span></span><br><span class="line">      EH_EXCEPTION_PARAMETERS,   <span class="comment">// Number of parameters</span></span><br><span class="line">      &#123; EH_MAGIC_NUMBER1,        <span class="comment">// Our version control magic number</span></span><br><span class="line">        <span class="literal">nullptr</span>,                 <span class="comment">// pExceptionObject</span></span><br><span class="line">        <span class="literal">nullptr</span>,</span><br><span class="line">#<span class="keyword">if</span> EH_EXCEPTION_PARAMETERS == <span class="number">4</span></span><br><span class="line">        <span class="literal">nullptr</span>                  <span class="comment">// Image base of thrown object</span></span><br><span class="line">#endif</span><br><span class="line">      &#125;                          <span class="comment">// pThrowInfo</span></span><br><span class="line">    &#125;;</span><br><span class="line">    EHExceptionRecord ThisException = ExceptionTemplate; <span class="comment">// This exception</span></span><br><span class="line"></span><br><span class="line">    ThrowInfo* pTI = (ThrowInfo*)pThrowInfo;</span><br><span class="line">    <span class="comment">// deleted ...</span></span><br><span class="line">    </span><br><span class="line">    ThisException.params.pExceptionObject = pExceptionObject;</span><br><span class="line">    ThisException.params.pThrowInfo = pTI;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> _EH_RELATIVE_TYPEINFO</span></span><br><span class="line">    PVOID ThrowImageBase = RtlPcToFileHeader((PVOID)pTI, &amp;ThrowImageBase);</span><br><span class="line">    ThisException.params.pThrowImageBase = ThrowImageBase;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="comment">// deleted ...</span></span><br><span class="line"></span><br><span class="line">    EHTRACE_EXIT;</span><br><span class="line">    RaiseException( ThisException.ExceptionCode,</span><br><span class="line">      ThisException.ExceptionFlags,</span><br><span class="line">      ThisException.NumberParameters,</span><br><span class="line">      (PULONG_PTR)&amp;ThisException.params );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>根据源码可知， <code>_CxxThrowException()</code> 内部会调用 <code>RaiseException()</code>，<code>RaiseException()</code> 的原型如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">VOID WINAPI <span class="title">RaiseException</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  _In_ DWORD dwExceptionCode,</span></span></span><br><span class="line"><span class="function"><span class="params">  _In_ DWORD dwExceptionFlags,</span></span></span><br><span class="line"><span class="function"><span class="params">  _In_ DWORD nNumberOfArguments,</span></span></span><br><span class="line"><span class="function"><span class="params">  _In_reads_opt_(nNumberOfArguments) CONST ULONG_PTR* lpArguments</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br></pre></td></tr></table></figure><p> <code>_CxxThrowException</code> 调用 <code>RaiseException()</code> 时传递的各个参数值如下：</p><ul><li><p><code>dwExceptionCode</code> 的值是 <code>EH_EXCEPTION_NUMBER</code>，对应的十六进制值是 <code>0xe06d7363</code>，也就是 <code>.msc</code>。</p></li><li><p><code>dwExceptionFlags</code> 的值是 <code>EXCEPTION_NONCONTINUABLE</code>，对应的十六进制值是 <code>0x1</code>。</p></li><li><p><code>nNumberOfArguments</code> 的值是 <code>EH_EXCEPTION_PARAMETERS</code>，在 <code>32</code> 位程序中是 <code>3</code>，在 <code>64</code> 位程序中是 <code>4</code>。定义如下：</p></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">if</span> (defined(_M_AMD64) || defined(_M_ARM) || defined(_M_ARM64)) &amp;&amp; !defined(_CHPE_X86_ARM64_EH_)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EH_EXCEPTION_PARAMETERS 4  <span class="comment">// Number of parameters in exception record</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EH_EXCEPTION_PARAMETERS 3  <span class="comment">// Number of parameters in exception record</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><ul><li><code>lpArguments</code> 指向具体的参数，来自 <code>ThisException.params</code>。<code>ThisException</code> 的类型是 <code>EHExceptionRecord</code>，其定义如下：</li></ul><h2 id="EHExceptionRecord"><a href="#EHExceptionRecord" class="headerlink" title="EHExceptionRecord"></a>EHExceptionRecord</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">EHExceptionRecord</span> &#123;</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">long</span>ExceptionCode;  <span class="comment">// The code of this exception. (= EH_EXCEPTION_NUMBER)</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">long</span>ExceptionFlags;<span class="comment">// Flags determined by NT</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">EXCEPTION_RECORD</span>* <span class="title">ExceptionRecord</span>;</span> <span class="comment">// An extra exception record (not used)</span></span><br><span class="line">  <span class="keyword">void</span>* ExceptionAddress;  <span class="comment">// Address at which exception occurred</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">long</span> NumberParameters; <span class="comment">// Number of extended parameters. (= EH_EXCEPTION_PARAMETERS)</span></span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">EHParameters</span> &#123;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> magicNumber; <span class="comment">// = EH_MAGIC_NUMBER1</span></span><br><span class="line">    <span class="keyword">void</span> * pExceptionObject;   <span class="comment">// Pointer to the actual object thrown</span></span><br><span class="line">    ThrowInfo* pThrowInfo;     <span class="comment">// Description of thrown object</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> _EH_RELATIVE_TYPEINFO</span></span><br><span class="line">  <span class="keyword">void</span> * pThrowImageBase;    <span class="comment">// Image base of thrown object</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">  &#125; params; <span class="comment">// &lt;-----</span></span><br><span class="line"></span><br><span class="line">&#125; EHExceptionRecord;</span><br></pre></td></tr></table></figure><p>根据定义可知，<code>ThisException.params</code> 的类型是 <code>EHExceptionRecord::EHParameters</code>，如果 <code>_EH_RELATIVE_TYPEINFO</code> 为 <code>0</code>，则包含 <code>3</code> 个成员，否则就会包含第 4 个成员 <code>pThrowImageBase</code>。</p><p>而 <code>_EH_RELATIVE_TYPEINFO</code> 在 <code>32</code> 位程序中是 <code>0</code>，在 <code>64</code> 位程序中是 <code>1</code>，定义如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(_M_CEE_PURE) || defined(BUILDING_C1XX_FORCEINCLUDE)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _EH_RELATIVE_TYPEINFO 0  <span class="comment">// &lt;-----</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _EH_RELATIVE_FUNCINFO 0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _RTTI_RELATIVE_TYPEINFO 0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">elif</span> defined(_CHPE_X86_ARM64_EH_)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _EH_RELATIVE_TYPEINFO 0  <span class="comment">// &lt;-----</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _EH_RELATIVE_FUNCINFO 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _RTTI_RELATIVE_TYPEINFO 0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">elif</span> defined(_M_ARM)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _EH_RELATIVE_TYPEINFO 1  <span class="comment">// &lt;-----</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _EH_RELATIVE_FUNCINFO 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _RTTI_RELATIVE_TYPEINFO 0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">elif</span> defined(_M_AMD64) || defined(_M_ARM64)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _EH_RELATIVE_TYPEINFO 1  <span class="comment">// &lt;-----</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _EH_RELATIVE_FUNCINFO 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _RTTI_RELATIVE_TYPEINFO 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _EH_RELATIVE_TYPEINFO 0  <span class="comment">// &lt;-----</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _EH_RELATIVE_FUNCINFO 0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _RTTI_RELATIVE_TYPEINFO 0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><p><code>EHExceptionRecord::EHParameters</code> 结构体的成员数量与调用 <code>RaiseException()</code> 时的 <code>nNumberOfArguments</code> 参数值是对应的。</p><p>在 <code>32</code> 位程序中，<code>nNumberOfArguments</code> 的值是 <code>3</code>，<code>EHExceptionRecord::EHParameters</code> 刚好有 <code>3</code> 个成员，在 <code>64</code> 位程序中 <code>nNumberOfArguments</code> 的值是 <code>4</code>，<code>EHExceptionRecord::EHParameters</code> 刚好有 <code>4</code> 个成员。</p><p><code>EHExceptionRecord::EHParameters</code> 中的 <code>pExceptionObject</code> 和 <code>pThrowInfo</code> 是查找异常类型的关键。</p><p>其中，<code>pExceptionObject</code> 是异常对象的地址，<code>pThrowInfo</code> 的类型是 <code>ThrowInfo</code>，用来描述异常对象的类型信息。一起来看看 <code>ThrowInfo</code> 的定义。</p><h2 id="ThrowInfo"><a href="#ThrowInfo" class="headerlink" title="ThrowInfo"></a>ThrowInfo</h2> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> _<span class="title">s_ThrowInfo</span> &#123;</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> attributes; <span class="comment">// Throw Info attributes (Bit field)</span></span><br><span class="line">  PMFN pmfnUnwind; <span class="comment">// Destructor to call when exception has been handled or aborted</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> _EH_RELATIVE_TYPEINFO &amp;&amp; !defined(BUILDING_C1XX_FORCEINCLUDE)</span></span><br><span class="line">  <span class="keyword">int</span> pForwardCompat;  <span class="comment">// Image relative offset of Forward compatibility frame handler</span></span><br><span class="line">  <span class="keyword">int</span> pCatchableTypeArray; <span class="comment">// Image relative offset of CatchableTypeArray</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">  <span class="keyword">int</span> (__cdecl * pForwardCompat)(...); <span class="comment">// Forward compatibility frame handler</span></span><br><span class="line">  CatchableTypeArray* pCatchableTypeArray; <span class="comment">// Pointer to list of pointers to types</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125; ThrowInfo;</span><br></pre></td></tr></table></figure><ul><li><p><code>pmfnUnwind</code> 是处理异常时会调用的回卷函数，一般是析构函数，可以根据此值判断异常对象的类型！</p></li><li><p><code>pForwardCompat</code> 一般情况下都是 <code>0</code>，不用太关心</p></li><li><p><code>pCatchableTypeArray</code> <strong>非常重要</strong>，记录了类型信息</p></li></ul><p><code>_EH_RELATIVE_TYPEINFO</code> 在上面已经贴出来了，在 <code>32</code> 位程序中被定义为 <code>0</code>，在 <code>64</code> 位程序中被定义为 <code>1</code>。</p><p>所以，<code>pForwardCompat</code> 和 <code>pCatchableTypeArray</code> 在 <code>32</code> 位程序中是地址，在 <code>64</code> 位程序中是偏移。</p><p>还记得 <code>EHExceptionRecord::EHParameters</code> 在 <code>64</code> 位程序中有 <code>4</code> 个成员吗？第 <code>4</code> 个成员就是抛出异常对应的模块基址，用这个基址加上这里的偏移就得到了对应成员在内存中的位置。<strong>一定要记住这个结论</strong>，在分析 <code>64</code> 位程序的异常对象类型时会用到！</p><p>接下来看看关键的 <code>CatchableTypeArray</code> 类型的定义，摘录如下：</p><h2 id="CatchableTypeArray"><a href="#CatchableTypeArray" class="headerlink" title="CatchableTypeArray"></a>CatchableTypeArray</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> _<span class="title">s_CatchableTypeArray</span> &#123;</span></span><br><span class="line">  <span class="keyword">int</span> nCatchableTypes;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> _EH_RELATIVE_TYPEINFO</span></span><br><span class="line">  <span class="keyword">int</span> arrayOfCatchableTypes[];<span class="comment">// Image relative offset of Catchable Types</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">  CatchableType* arrayOfCatchableTypes[];</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125; CatchableTypeArray;</span><br></pre></td></tr></table></figure><ul><li><code>nCatchableTypes</code> 记录了数组 <code>arrayOfCatchableTypes</code> 的数量。</li><li><code>arrayOfCatchableTypes</code> 记录了异常类型信息。同样的，在 <code>32</code> 位程序中是地址，在 <code>64</code> 位程序中是偏移。</li></ul><blockquote><p><strong>说明：</strong> 这里为什么使用数组呢？因为抛出的异常可能继承自某个基类。<code>arrayOfCatchableTypes</code> 会把继承链上的所有类型信息按照从子类到基类的顺序记录下来。拿 <code>std::bad_alloc</code> 举例，它继承自 <code>std::exception</code>。所以，<code>nCatchableTypes</code> 的值为 <code>2</code>，<code>arrayOfCatchableTypes[0]</code> 记录了 <code>std::bad_alloc</code> 的类型信息，<code>arrayOfCatchableTypes[1]</code> 记录了 <code>std::exception</code> 的类型信息。</p></blockquote><p>再来看看结构体 <code>CatchableType</code> 的定义，摘录如下：</p><h2 id="CatchableType"><a href="#CatchableType" class="headerlink" title="CatchableType"></a>CatchableType</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> _<span class="title">s_CatchableType</span> &#123;</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> properties; <span class="comment">// Catchable Type properties (Bit field)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> _EH_RELATIVE_TYPEINFO</span></span><br><span class="line">  <span class="keyword">int</span> pType; <span class="comment">// Image relative offset of TypeDescriptor</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">  TypeDescriptor* pType; <span class="comment">// Pointer to the type descriptor for this type</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">  PMD thisDisplacement;<span class="comment">// Pointer to instance of catch type within thrown object.</span></span><br><span class="line">  <span class="keyword">int</span> sizeOrOffset;  <span class="comment">// Size of simple-type object or offset into</span></span><br><span class="line">           <span class="comment">// buffer of 'this' pointer for catch object</span></span><br><span class="line">  PMFN copyFunction; <span class="comment">// Copy constructor or CC-closure</span></span><br><span class="line">&#125; CatchableType;</span><br></pre></td></tr></table></figure><p>我们只需要关注 <code>pType</code> 成员即可。同样的，在 <code>32</code> 位程序中是地址，在 <code>64</code> 位程序中是偏移。 <code>pType</code> 对应的类型是 <code>TypeDescriptor</code>，接下来看看 <code>TypeDescriptor</code> 的定义。</p><h2 id="TypeDescriptor"><a href="#TypeDescriptor" class="headerlink" title="TypeDescriptor"></a>TypeDescriptor</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">TypeDescriptor</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(_WIN64) || defined(_RTTI) || defined(BUILDING_C1XX_FORCEINCLUDE)</span></span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">void</span>* pVFTable; <span class="comment">// Field overloaded by RTTI</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">long</span>hash; <span class="comment">// Hash value computed from type's decorated name</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">  <span class="keyword">void</span>*spare; <span class="comment">// reserved, possible for RTTI</span></span><br><span class="line">  <span class="keyword">char</span> name[]; <span class="comment">// The decorated name of the type; 0 terminated.</span></span><br><span class="line">&#125; TypeDescriptor;</span><br></pre></td></tr></table></figure><p>其中，<code>name</code> 成员是经过名字改编后的异常类型，它是一个以 <code>\0</code> 结尾的字符串，可以在 <code>windbg</code> 中通过 <code>da</code> 查看。</p><p>源码有点乱，还是在 <code>windbg</code> 中看的直观舒服，还可以看到偏移。以下是  <code>32</code> 位和 <code>64</code> 位程序中对应的结构体定义：</p><h2 id="关键结构"><a href="#关键结构" class="headerlink" title="关键结构"></a>关键结构</h2><h3 id="32-位关键结构"><a href="#32-位关键结构" class="headerlink" title="32 位关键结构"></a>32 位关键结构</h3> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span>:<span class="number">000</span>&gt; dt EHExceptionRecord</span><br><span class="line">TestThrowException!EHExceptionRecord</span><br><span class="line">   +<span class="number">0x000</span> ExceptionCode    : Uint4B</span><br><span class="line">   +<span class="number">0x004</span> ExceptionFlags   : Uint4B</span><br><span class="line">   +<span class="number">0x008</span> ExceptionRecord  : Ptr32 _EXCEPTION_RECORD</span><br><span class="line">   +<span class="number">0x00c</span> ExceptionAddress : Ptr32 Void</span><br><span class="line">   +<span class="number">0x010</span> NumberParameters : Uint4B</span><br><span class="line">   +<span class="number">0x014</span> params           : EHExceptionRecord::EHParameters <span class="comment">//&lt;----</span></span><br><span class="line"></span><br><span class="line"><span class="number">0</span>:<span class="number">000</span>&gt; dt EHExceptionRecord::EHParameters</span><br><span class="line">TestThrowException!EHExceptionRecord::EHParameters</span><br><span class="line">   +<span class="number">0x000</span> magicNumber      : Uint4B</span><br><span class="line">   +<span class="number">0x004</span> pExceptionObject : Ptr32 Void</span><br><span class="line">   +<span class="number">0x008</span> pThrowInfo       : Ptr32 _s_ThrowInfo <span class="comment">//&lt;----</span></span><br><span class="line"></span><br><span class="line"><span class="number">0</span>:<span class="number">000</span>&gt; dt _s_ThrowInfo</span><br><span class="line">TestThrowException!_s_ThrowInfo</span><br><span class="line">   +<span class="number">0x000</span> attributes       : Uint4B</span><br><span class="line">   +<span class="number">0x004</span> pmfnUnwind       : Ptr32     <span class="keyword">void</span> </span><br><span class="line">   +<span class="number">0x008</span> pForwardCompat   : Ptr32     <span class="keyword">int</span> </span><br><span class="line">   +<span class="number">0x00c</span> pCatchableTypeArray : Ptr32 _s_CatchableTypeArray <span class="comment">//&lt;----</span></span><br><span class="line"></span><br><span class="line"><span class="number">0</span>:<span class="number">000</span>&gt; dt _s_CatchableTypeArray</span><br><span class="line">TestThrowException!_s_CatchableTypeArray</span><br><span class="line">   +<span class="number">0x000</span> nCatchableTypes  : Int4B</span><br><span class="line">   +<span class="number">0x004</span> arrayOfCatchableTypes : [<span class="number">0</span>] Ptr32 _s_CatchableType <span class="comment">//&lt;----</span></span><br><span class="line"></span><br><span class="line"><span class="number">0</span>:<span class="number">000</span>&gt; dt _s_CatchableType</span><br><span class="line">TestThrowException!_s_CatchableType</span><br><span class="line">   +<span class="number">0x000</span> properties       : Uint4B</span><br><span class="line">   +<span class="number">0x004</span> pType            : Ptr32 TypeDescriptor <span class="comment">//&lt;----</span></span><br><span class="line">   +<span class="number">0x008</span> thisDisplacement : PMD</span><br><span class="line">   +<span class="number">0x014</span> sizeOrOffset     : Int4B</span><br><span class="line">   +<span class="number">0x018</span> copyFunction     : Ptr32     <span class="keyword">void</span></span><br><span class="line"></span><br><span class="line"><span class="number">0</span>:<span class="number">000</span>&gt; dt TypeDescriptor</span><br><span class="line">TestThrowException!TypeDescriptor</span><br><span class="line">   +<span class="number">0x000</span> hash             : Uint4B</span><br><span class="line">   +<span class="number">0x004</span> spare            : Ptr32 Void</span><br><span class="line">   +<span class="number">0x008</span> name             : [<span class="number">0</span>] Char <span class="comment">//&lt;====</span></span><br></pre></td></tr></table></figure><h3 id="64-位关键结构"><a href="#64-位关键结构" class="headerlink" title="64 位关键结构"></a>64 位关键结构</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span>:<span class="number">000</span>&gt; dt EHExceptionRecord</span><br><span class="line">VCRUNTIME140!EHExceptionRecord</span><br><span class="line">   +<span class="number">0x000</span> ExceptionCode    : Uint4B</span><br><span class="line">   +<span class="number">0x004</span> ExceptionFlags   : Uint4B</span><br><span class="line">   +<span class="number">0x008</span> ExceptionRecord  : Ptr64 _EXCEPTION_RECORD</span><br><span class="line">   +<span class="number">0x010</span> ExceptionAddress : Ptr64 Void</span><br><span class="line">   +<span class="number">0x018</span> NumberParameters : Uint4B</span><br><span class="line">   +<span class="number">0x020</span> params           : EHExceptionRecord::EHParameters <span class="comment">//&lt;----</span></span><br><span class="line"></span><br><span class="line"><span class="number">0</span>:<span class="number">000</span>&gt; dt EHExceptionRecord::EHParameters</span><br><span class="line">VCRUNTIME140!EHExceptionRecord::EHParameters</span><br><span class="line">   +<span class="number">0x000</span> magicNumber      : Uint4B</span><br><span class="line">   +<span class="number">0x008</span> pExceptionObject : Ptr64 Void</span><br><span class="line">   +<span class="number">0x010</span> pThrowInfo       : Ptr64 _s_ThrowInfo <span class="comment">//&lt;----</span></span><br><span class="line">   +<span class="number">0x018</span> pThrowImageBase  : Ptr64 Void</span><br><span class="line"></span><br><span class="line"><span class="number">0</span>:<span class="number">000</span>&gt; dt _s_ThrowInfo</span><br><span class="line">VCRUNTIME140!_s_ThrowInfo</span><br><span class="line">   +<span class="number">0x000</span> attributes       : Uint4B</span><br><span class="line">   +<span class="number">0x004</span> pmfnUnwind       : Int4B</span><br><span class="line">   +<span class="number">0x008</span> pForwardCompat   : Int4B</span><br><span class="line">   +<span class="number">0x00c</span> pCatchableTypeArray : Int4B <span class="comment">//&lt;----</span></span><br><span class="line"></span><br><span class="line"><span class="number">0</span>:<span class="number">000</span>&gt; dt CatchableTypeArray</span><br><span class="line">VCRUNTIME140!CatchableTypeArray</span><br><span class="line">   +<span class="number">0x000</span> nCatchableTypes  : Int4B</span><br><span class="line">   +<span class="number">0x004</span> arrayOfCatchableTypes : [<span class="number">0</span>] Int4B <span class="comment">//&lt;----</span></span><br><span class="line"></span><br><span class="line"><span class="number">0</span>:<span class="number">000</span>&gt; dt CatchableType</span><br><span class="line">VCRUNTIME140!CatchableType</span><br><span class="line">   +<span class="number">0x000</span> properties       : Uint4B</span><br><span class="line">   +<span class="number">0x004</span> pType            : Int4B <span class="comment">//&lt;----</span></span><br><span class="line">   +<span class="number">0x008</span> thisDisplacement : PMD</span><br><span class="line">   +<span class="number">0x014</span> sizeOrOffset     : Int4B</span><br><span class="line">   +<span class="number">0x018</span> copyFunction     : Int4B</span><br><span class="line"></span><br><span class="line"><span class="number">0</span>:<span class="number">000</span>&gt; dt TypeDescriptor</span><br><span class="line">VCRUNTIME140!TypeDescriptor</span><br><span class="line">   +<span class="number">0x000</span> pVFTable         : Ptr64 Void</span><br><span class="line">   +<span class="number">0x008</span> spare            : Ptr64 Void</span><br><span class="line">   +<span class="number">0x010</span> name             : [<span class="number">0</span>] Char <span class="comment">//&lt;====</span></span><br></pre></td></tr></table></figure><blockquote><p><strong>划重点：</strong> 务必记住以上结构体的定义，尤其是关键字段的偏移。这是解析的依据！</p></blockquote><h2 id="解析方法小结"><a href="#解析方法小结" class="headerlink" title="解析方法小结"></a>解析方法小结</h2><ol><li><p>先找到 <code>EHParameters</code> 类型的对象（可省略此步）</p><p>可以通过 <code>RaiseException()</code> 的第四个参数查找。</p><p>在 <code>32</code> 位程序中，定位方法非常简单，可以直接查看 <code>RaiseException()</code> 的第 <code>4</code> 个参数，<code>ebp+0x14</code>。</p><p>在 <code>x64</code> 位中可以通过 <code>_CxxThrowException()</code> 的 <code>rsp + 0x28</code> 定位。因为在调用 <code>RaiseException()</code> 的时候， <code>_CxxThrowException()</code> 会把此参数存在自己栈帧中 <code>rsp + 0x28</code> 的位置。</p></li></ol><ol start="2"><li><p>再找到  <code>ThrowInfo</code> 类型的对象</p><p>解析 <code>EHParameters</code> 中的第 <code>3</code> 个成员 <code>pThrowInfo</code>，在 <code>32</code> 位程序中偏移是 <code>0x8</code>，在 <code>64</code> 位程序中偏移是 <code>0x10</code>。</p><blockquote><p><strong>说明：</strong> 还有两种查看方法： </p><ol><li><p>对于 <code>32</code> 位程序可以通过 <code>_CxxThrowException()</code> 对应栈帧的第 <code>2</code> 个参数（<code>ebp+c</code>）直接查看。</p></li><li><p>如果有 <code>vcruntimexxx.dll</code> 的调试符号，可以直接切到 <code>_CxxThrowException()</code> 对应的栈帧，<code>windbg</code> 会自动帮忙列出对应的值。 </p></li></ol></blockquote></li></ol><ol start="3"><li><p>再找到 <code>CatchableTypeArray</code> 类型的对象</p><p>解析 <code>ThrowInfo</code> 的第 <code>4</code> 个成员 <code>pCatchableTypeArray</code>，其偏移是 <code>0xc</code>（<code>32</code>位 <code>64</code> 位通用）。</p><p><strong>需要注意的是，此成员在 <code>32</code> 位程序中是地址；在 <code>64</code> 位程序中是偏移，需要加上镜像基址得到最终的地址。</strong></p></li></ol><ol start="4"><li><p>再找到 <code>CatchableType</code> 类型的对象</p><p>解析 <code>CatchableTypeArray</code> 的第 <code>2</code>个成员 <code>arrayOfCatchableTypes</code> ，偏移是 <code>0x4</code>（<code>32</code>位 <code>64</code> 位通用）。</p><p>该成员记录了 <code>CatchableType</code> 数组的首地址或者偏移。</p><p><strong>需要注意的是，此成员在 <code>32</code> 位程序中是地址；在 <code>64</code> 位程序中是偏移，需要加上镜像基址得到最终的地址。</strong></p><blockquote><p><strong>说明：</strong> 第 <code>1</code> 个成员 <code>nCatchableTypes</code> 记录了 <code>CatchableType</code> 数组的个数。</p></blockquote></li></ol><ol start="5"><li><p>再找到 <code>TypeDescriptor</code> 类型的对象</p><p>解析 <code>CatchableType</code> 数组中的每个对象（其实，只需要解析第一个即可）。重点关注第 <code>2</code> 个成员 <code>pType</code>，偏移是 <code>0x4</code>（<code>32</code>位 <code>64</code> 位通用）。</p><p><strong>需要注意的是，此成员在 <code>32</code> 位程序中是地址；在 <code>64</code> 位程序中是偏移，需要加上镜像基址得到最终的地址。</strong></p></li></ol><ol start="6"><li><p>最后找到异常类型名</p><p>解析 <code>TypeDescriptor</code> 对象，只需要关注第 <code>3</code> 个成员 <code>name</code> 成员即可，在 <code>32</code> 位程序中偏移是 <code>0x8</code>，在 <code>64</code> 位程序中偏移是 <code>0x10</code>。</p><p>它是一个以 <code>\0</code> 结尾的字符串，可以在 <code>windbg</code> 用 <code>da</code> 显示其内容。</p></li></ol><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li><code>throw</code> 对应的实现函数是 <code>_CxxThrowException()</code> 函数，该函数定义在 <code>throw.cpp</code> 中，可以查看源码。</li><li><code>_CxxThrowException()</code> 内部会调用 <code>RaiseException()</code>，调用时传递的错误码是 <code>0xe06d7363</code>（对应的字符是 <code>.msc</code>）。</li><li>【关键结构】中的结构体是解析时的依据，务必要熟悉。</li><li>【解析方法小结】中总结的方法是通用方法，适用于任何情况。在实际解析过程中还可以利用虚表等其它相关信息进行解析。</li><li>在解析过程中，需要注意的是在 <code>64</code> 位程序中，很多成员变量都是相对于发生异常模块的偏移，而不是直接可用的地址，需要先把偏移转换成虚拟地址后再使用。</li></ul><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><code>vs</code> 源码</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;缘起&quot;&gt;&lt;a href=&quot;#缘起&quot; class=&quot;headerlink&quot; title=&quot;缘起&quot;&gt;&lt;/a&gt;缘起&lt;/h2&gt;&lt;p&gt;最近在分析转储文件时，遇到了一个由 &lt;code&gt;throw&lt;/code&gt; 抛出的异常。尽管在 &lt;code&gt;windbg&lt;/code&gt; 中使用 &lt;code&gt;!analyze -v&lt;/code&gt; 迅速知道了异常码是 &lt;code&gt;0xe06d7363&lt;/code&gt;（对应的 &lt;code&gt;ASCII&lt;/code&gt; 码是 &lt;code&gt;.msc&lt;/code&gt;），但是根据异常码并不能确定具体抛出来的是哪种异常。针对这种情况，确定具体的异常类型才有意义。&lt;/p&gt;
&lt;p&gt;本篇文章会简单介绍与抛出异常相关的内容，包括关键的函数及结构体。下一篇文章会通过实例介绍几种典型情况（有调试符号 / 没有调试符号 / &lt;code&gt;32&lt;/code&gt; 位程序 / &lt;code&gt;64&lt;/code&gt; 位程序）下的定位方法。&lt;/p&gt;
    
    </summary>
    
      <category term="调试" scheme="https://bianchengnan.github.io/categories/%E8%B0%83%E8%AF%95/"/>
    
    
      <category term="原" scheme="https://bianchengnan.github.io/tags/%E5%8E%9F/"/>
    
      <category term="总结" scheme="https://bianchengnan.github.io/tags/%E6%80%BB%E7%BB%93/"/>
    
      <category term="调试" scheme="https://bianchengnan.github.io/tags/%E8%B0%83%E8%AF%95/"/>
    
      <category term="异常" scheme="https://bianchengnan.github.io/tags/%E5%BC%82%E5%B8%B8/"/>
    
      <category term="debug" scheme="https://bianchengnan.github.io/tags/debug/"/>
    
      <category term="dump" scheme="https://bianchengnan.github.io/tags/dump/"/>
    
      <category term="转储文件" scheme="https://bianchengnan.github.io/tags/%E8%BD%AC%E5%82%A8%E6%96%87%E4%BB%B6/"/>
    
      <category term="part1" scheme="https://bianchengnan.github.io/tags/part1/"/>
    
      <category term="exception" scheme="https://bianchengnan.github.io/tags/exception/"/>
    
  </entry>
  
  <entry>
    <title>调试实战 | 谁在偷偷占用我的文件？原来是我自己</title>
    <link href="https://bianchengnan.github.io//articles/findout-who-is-using-my-file-with-the-help-of-perfview-and-process-explorer/"/>
    <id>https://bianchengnan.github.io//articles/findout-who-is-using-my-file-with-the-help-of-perfview-and-process-explorer/</id>
    <published>2023-12-24T12:14:23.000Z</published>
    <updated>2024-12-21T04:02:50.153Z</updated>
    
    <content type="html"><![CDATA[<h2 id="缘起"><a href="#缘起" class="headerlink" title="缘起"></a>缘起</h2><p>之前基于 <code>.net</code> 官方提供的 <code>FileSystemWatcher</code> 写了一个文件变化监听工具，具体参考<a href="https://bianchengnan.github.io/articles/A-better-file-system-wacher-based-on-dotnet-FileSystemWatcher/">这篇文章</a> 。主要解决了以下三个问题：</p><ol><li>事件触发时，文件可能还不能被访问。</li><li>如果监听选项设置的过多，有可能会多次触发文件变化事件。</li><li>监听过滤器不够灵活，我没找到同时监听多种特定文件类型的方法（比如，同时只监听 <code>.docx</code> 和 <code>.bmp</code> 文件）。</li></ol><p>为了解决<strong>问题1</strong>，我在调用用户注册的回调函数前，会先调用 <code>WaitUntilCanAccess()</code> 来确保文件是可访问状态。没想到在测试过程中发现了一个意想不到的问题。本文记录了解决这个问题的过程。</p><a id="more"></a><blockquote><p><strong>说明：</strong> 我写了一个示例工程，本文所有的叙述都是基于这个示例工程的。</p></blockquote><h2 id="测试程序"><a href="#测试程序" class="headerlink" title="测试程序"></a>测试程序</h2><p><code>TestMonitorImage.exe</code> 会<strong>递归</strong>监听当前程序所在目录中的所有 <code>.bmp</code> 类型的文件变化，监听到相应事件后会调用 <code>picturebox.Load(path)</code> 把图像显示到界面上。</p><p><code>copy.ps1</code> 是一个辅助脚本，会每隔一秒拷贝一张图片到子目录中，会触发文件变化事件。按理说，每隔一秒界面上应该显示一张新图片，如此往复，如下图：</p><p><img src="http://resources.bianchengnan.tech/findout-who-is-using-my-file-with-the-help-of-perfview-and-process-explorer/right-result.gif" alt="right-result"></p><p>但是……</p><h2 id="初遇问题"><a href="#初遇问题" class="headerlink" title="初遇问题"></a>初遇问题</h2><p>没想到只显示了一张图片后就停止显示了，就像下面这样。</p><p><img src="http://resources.bianchengnan.tech/findout-who-is-using-my-file-with-the-help-of-perfview-and-process-explorer/wrong-result.png" alt="wrong-result"></p><p>这不可能啊（哈哈，最近的口头禅）！但是现象确实是不对的，到底是哪里出了问题呢？</p><h2 id="调查"><a href="#调查" class="headerlink" title="调查"></a>调查</h2><p>附加调试器，通过调试信息可以判断监听还在正常进行，因为能不断输出调试日志。</p><p><img src="http://resources.bianchengnan.tech/findout-who-is-using-my-file-with-the-help-of-perfview-and-process-explorer/debug-output.gif" alt="debug-output"></p><p>接着观察一下回调函数是否正常。在回调函数里加断点，奇怪，怎么没命中？难道是通知环节出了问题？</p><p>观察一下通知线程的运行情况，观察了几秒钟，发现这个线程会反复遇到同一个异常——文件正由另一进程使用，因此该进程无法访问此文件。</p><p><img src="http://resources.bianchengnan.tech/findout-who-is-using-my-file-with-the-help-of-perfview-and-process-explorer/file-is-being-used-by-another-process-exception.png" alt="file-is-being-used-by-another-process-exception"></p><p>按理说，<code>powershell</code> 脚本拷贝完文件后，就不会占用这个文件了。而且我机器上装的是固态硬盘，本地文件拷贝过程应该非常快，就算再慢，<code>1</code> 秒也应该拷贝完了。即使遇到文件被占用的异常，最多只会在最开始的十几毫秒内遇到，不应该过了这么久还会遇到这种异常。那到底是谁在占用这个文件呢？</p><h2 id="请出-process-explorer"><a href="#请出-process-explorer" class="headerlink" title="请出 process explorer"></a>请出 process explorer</h2><p>打开 <code>process explorer</code>，搜索 <code>testimage1.bmp</code>，发现只搜到一条结果，而且居然还是自己的进程！</p><p><img src="http://resources.bianchengnan.tech/findout-who-is-using-my-file-with-the-help-of-perfview-and-process-explorer/search-testimage1.png" alt="search-testimage1"></p><p>看来应该是某处代码打开了这个文件，但是没有关闭。在 <code>windows</code> 中，打开文件后会返回一个句柄（<code>HANDLE</code>），不再使用这个文件的时候需要关闭。如果打开了文件，但是没有关闭它，则会导致句柄泄露，而且下次再尝试打开这个文件的时候<strong>可能</strong>会遇到文件被占用，无法访问的情况。有没有一种机制可以追踪句柄打开/关闭的情况呢？如果能同时显示对应的调用栈，那就更完美了。我知道两种方法：</p><ol><li>使用 <code>windbg</code> 的 <code>!htrace</code> 命令</li><li>使用 <code>ETW(Event Trace for Windows)</code> 追踪句柄。</li></ol><p>如果可以调试的话，可以用 <code>windbg</code> 附加到对应的进程中，然后执行 <code>!htrace -enable</code> 开启句柄追踪，等程序运行一段时间后，执行 <code>!htrace -diff</code> 即可查看句柄变化情况，而且可以看到对应的调用栈。虽然 <code>windbg</code> 很强大，但是今天的主角不是 <code>windbg</code>，而是 <a href="https://github.com/microsoft/perfview" target="_blank" rel="noopener">perfView</a> —— 一款开源、免费、绿色而且非常强大的 <code>ETW</code> 事件收集及分析工具。</p><h2 id="采集数据"><a href="#采集数据" class="headerlink" title="采集数据"></a>采集数据</h2><p>打开 <code>perfView</code>，点击 <code>Collect -&gt; Collect   Alt+C</code>，会以管理员权限弹出收集界面，如下图：</p><p><img src="http://resources.bianchengnan.tech/findout-who-is-using-my-file-with-the-help-of-perfview-and-process-explorer/perfview-collect.png" alt="perfview-collect"></p><p>点击 <code>Advance Options</code> 按钮，即可打开高级选项。勾选 <code>Handle</code> 即可追踪句柄，勾选 <code>File I/O</code> 即可追踪文件操作。</p><p>设置好后，点击 <code>Start Collection</code> 即可开始收集。问题重现后，点击 <code>Stop Collection</code> 停止收集。完整操作过程如下：</p><p><img src="http://resources.bianchengnan.tech/findout-who-is-using-my-file-with-the-help-of-perfview-and-process-explorer/collect-event-with-perfview.gif" alt="collect-event-with-perfview"></p><blockquote><p><strong><em>说明：</em></strong></p><ol><li>除了点击 <code>Collect</code> 菜单下的 <code>Collect</code>，还可以点击 <code>Run</code>，与 <code>Collect</code> 的区别是：<code>Run</code> 可以自动启动指定的程序，当程序结束运行时，自动停止收集。</li><li>需要说明的是：不论是 <code>Collect</code> 还是 <code>Run</code>，收集是机器级别的，不能只针对某个进程进行收集。</li></ol></blockquote><h2 id="分析数据"><a href="#分析数据" class="headerlink" title="分析数据"></a>分析数据</h2><p>点击 <code>Stop Collection</code> 按钮后， <code>perfView</code> 会自动保存采集结果，然后显示在左侧列表中。</p><p><img src="http://resources.bianchengnan.tech/findout-who-is-using-my-file-with-the-help-of-perfview-and-process-explorer/perfview-left-expand.png" alt="perfview-left-expand"></p><p>选中刚刚采集的文件，找到 <code>Events</code> 项，<strong>双击</strong>即可查看所有原始的 <code>ETW</code> 数据。其它项都是为了方便查看某些数据而创建的。比如，<code>CPU Stacks</code> 可以查看进程 <code>CPU</code> 使用情况。</p><p>因为采集的文件中包含<strong>海量</strong>的数据，而且大多数与我们要分析的问题无关，因此我们需要过滤出感兴趣的数据。</p><h2 id="过滤数据"><a href="#过滤数据" class="headerlink" title="过滤数据"></a>过滤数据</h2><p><code>perfView</code> 提供了很灵活的过滤机制，既可以根据进程过滤，也可以根据事件类型过滤，还可以根据事件内容进行过滤。</p><p><code>Process Filter</code> 可以根据进程进行过滤。输入 <code>TestMonitorImage</code>。</p><p><code>Event Types</code> 可以根据事件类型进行过滤。在对应的 <code>Filters</code> 中输入 <code>file|handle</code>（表示过滤文件和句柄事件），在过滤出来的结果中选择具体的事件类型（<code>CloseHandle, CreateHandle, DuplicateHandle, HandleDCEnd</code>），按回车即可在右侧显示出过滤后的事件。</p><p><code>Text Filter</code> 可以根据事件内容进行过滤。输入 <code>.bmp</code>，回车即可过滤出事件内容中包含 <code>.bmp</code> 的记录。</p><p><code>Columns To Display</code>  可以设置显示的列。为了更好的观察感兴趣的字段，点击 <code>Cols</code> 按钮选择需要显示的列，我选择了 <code>ObjectName</code>, <code>ThreadID</code> 和 <code>*</code>。</p><blockquote><p> <strong>注意：</strong></p><p>我在操作的过程中先显示了 <code>file</code> 和 <code>handle</code> 相关的事件，然后才只显示 <code>handle</code> 相关的事件。如果上来就只显示 <code>handle</code> 相关的事件，那么根据 <code>.bmp</code> 过滤的话，会过滤不出来任何记录。我猜是 <code>perfView</code> 自动根据 <code>file</code> 事件中的句柄和文件名推断出了对应的 <code>handle</code> 事件的 <code>ObjectName</code>。</p></blockquote><p><img src="http://resources.bianchengnan.tech/findout-who-is-using-my-file-with-the-help-of-perfview-and-process-explorer/filter-result.png" alt="filter-result"></p><p>从上图可以很清楚的看到 <code>.bmp</code> 相关的事件。注意 <code>ThreadID</code> 一列，<code>线程ID</code> 为 <code>10164</code> 的线程只出现了一次，对应的事件是 <code>CreateHandle</code>。（缺少了对应的 <code>CloseHandle</code>，说明这个线程只打开了文件，并没有关闭）在对应行的 <code>Time MSec</code> 这一列，右键，点击 <code>Open Any Stack   Alt+S</code> （或者在对应列上按 <code>Alt + S</code>）即可查看对应的调用栈，如下图：</p><p><img src="http://resources.bianchengnan.tech/findout-who-is-using-my-file-with-the-help-of-perfview-and-process-explorer/call-stack.png" alt="call-stack"></p><p>在对应行上，右键，点击 <code>Goto SOurce(Def)  Alt+D</code> （或者在对应行上按 <code>Alt+D</code>）即可打开对应的源码，如下图：</p><p><img src="http://resources.bianchengnan.tech/findout-who-is-using-my-file-with-the-help-of-perfview-and-process-explorer/go-to-source.png" alt="go-to-source"></p><p>可以发现在 <code>OnFileChanged()</code> 回调函数中，会使用 <code>s_form.pictureBox1.Load(e.FullPath)</code> 加载文件。可以猜测 <code>Load()</code> 函数内部打开对应的文件后并没有关闭。</p><p>目前程序在每次通知前会使用 <code>WaitUntilCanAccess()</code> 检查文件是否可以读写（内部通过  <code>File.Open(e.FullPath, FileMode.Open, FileAccess.ReadWrite, FileShare.None);</code> 进行判断）。</p><p>试想，如果下次收到同一个文件变化的通知，<code>WaitUntilCanAccess()</code> 内部会使用 <code>File.Open()</code> 尝试打开这个文件，而这个文件已经被打开了，是不是有可能触发文件被占用的异常呢？确实有可能会，也可能不会！</p><p>文件打开后没关闭，再次尝试打开时<strong>不一定</strong>会触发异常，比如两次都是通过 <code>File.Open(e.FullPath, FileMode.Open, FileAccess.ReadWrite, FileShare.ReadWrite);</code> 打开文件，第二次是可以顺利打开文件的。</p><p>那么什么情况下会触发文件被占用的异常呢？</p><h2 id="深入分析"><a href="#深入分析" class="headerlink" title="深入分析"></a>深入分析</h2><p>关于<code>FileAcess</code> 和 <code>FileShare</code> 的关系，请参考我总结的这篇文章 —— <a href="https://bianchengnan.github.io/articles/review-CreateFile-DesireAccess-ShareMode/">《开发常识 | 彻底理清 CreateFile 读写权限与共享模式的关系》</a>。</p><p>简单来说就是：后续的<strong>访问权限</strong>与先前的<strong>共享权限</strong>不能冲突。后续的<strong>共享权限</strong>与先前的<strong>访问权限</strong>不能冲突。</p><p>检查一下 <code>线程ID</code> 为 <code>10164</code> 的线程打开文件时指定的 <code>ShareAccess</code>，是 <code>ShareAccess.Read</code>，如下图：</p><p><img src="http://resources.bianchengnan.tech/findout-who-is-using-my-file-with-the-help-of-perfview-and-process-explorer/fileIO-Create-on-callback.png" alt="fileIO-Create-on-callback"></p><p>后续如果用 <code>FileAccess.ReadWrite</code> 打开，肯定会报错。而 <code>WaitUntilCanAccess()</code> 内部调用 <code>File.Open()</code> 时 <code>FileAccess</code> 参数的值就是 <code>FileAccess.ReadWrite</code>。  </p><p>而且 <code>WaitUntilCanAccess()</code> 指定的 <code>ShareAccess</code> 是 <code>FileShare.None</code>。只要在调用  <code>WaitUntilCanAccess()</code>  的时候，已经在其它地方打开了这个文件，肯定会触发文件被占用的异常。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>简单做个总结，整个过程是这样的：</p><p>当监听目录下的文件发生变化后，会进入内部的监听回调函数，监听回调函数会通过 <code>AddEventData()</code> 把数据放到通知队列中，并通过 <code>eventFiredEvent.Set()</code> 触发通知事件，通知线程收到消息后开始依次处理队列中的事件。</p><p>通知线程会先通过 <code>WaitUntilCanAccess()</code> 确保这个文件是可读写的状态，然后再调用外部回调函数。在外部回调函数中打开了文件但是并没有关闭。</p><p>当通知线程处理后续事件时，对应的文件刚好是上一个被占用的文件，<code>WaitUntilCanAccess()</code> 内部调用 <code>File.Open()</code> 尝试打开文件时触发了文件被占用的异常，休息 <code>FileAccessCheckIntervalMs</code> 毫秒后，又会调用 <code>File.Open()</code> 检查文件是否可以访问，又会触发文件被占用的异常，如此往复。后续所有的事件都得不到通知了。</p><p>问题的核心有两点：</p><ol><li>同一个文件的变化事件被通知了 <code>2</code> 次或多次。</li><li>外部回调函数中打开了对应的文件，但是没有关闭，而且打开文件时指定的 <code>FileShare</code> 是 <code>FileShare.Read</code> 。而通知线程在调用  <code>WaitUntilCanAccess()</code> 检测文件是否可用时指定的 <code>FileAccess</code> 是 <code>FileAccess.ReadWrite</code>，与 <code>FileShare.Read</code> 冲突。</li></ol><h2 id="解决问题"><a href="#解决问题" class="headerlink" title="解决问题"></a>解决问题</h2><ol><li><p>在调用外部回调函数前，尽量避免同一事件被通知多次。需要增加去除重复事件的支持。</p><p>我已经在 <code>FileSystemWatcherEx</code> 中增加了 <code>TryMergeSameEvent</code> 和 <code>DelayTriggerMs</code>。</p><p><code>TryMergeSameEvent</code> 表示是否合并”相同”事件，默认是 <code>true</code>。</p><p><code>DelayTriggerMs</code> 只有在 <code>TryMergeSameEvent</code> 为 <code>true</code> 的时候才有效。表示在通知事件前等待的毫秒数，默认是 <code>10</code> 毫秒。在这段时间内发生的事件会做去重处理。</p><blockquote><p><strong>说明：</strong> 虽然在一定程度上可以避免事件重复通知的问题，但依然有可能发生重复通知的情况，需要用户自己根据情况进行调整。</p></blockquote></li></ol><ol start="2"><li><p>在外部回调中打开文件后尽快关闭。在本示例代码中，只需要换一种方式显示图片即可——把图像加载到内存后就立刻关闭文件。</p><p>把回调函数中的代码改成下面这样即可。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">OnFileChanged_Ok</span>(<span class="params"><span class="keyword">object</span> sender, System.IO.FileSystemEventArgs e</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (e.ChangeType == System.IO.WatcherChangeTypes.Created </span><br><span class="line">      || e.ChangeType == System.IO.WatcherChangeTypes.Changed)</span><br><span class="line">  &#123;</span><br><span class="line">    s_form.Invoke(<span class="keyword">new</span> MethodInvoker(<span class="keyword">delegate</span>()</span><br><span class="line">    &#123;</span><br><span class="line">      ShowImage(s_form.pictureBox1, e.FullPath);</span><br><span class="line">    &#125;));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">ShowImage</span>(<span class="params">System.Windows.Forms.PictureBox pictureBox, <span class="keyword">string</span> imagePath</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">try</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">using</span> (<span class="keyword">var</span> imageStream = <span class="keyword">new</span> FileStream(imagePath, FileMode.Open))</span><br><span class="line">    &#123;</span><br><span class="line">      pictureBox.Image = (Bitmap)Image.FromStream(imageStream);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">catch</span> (System.Exception)</span><br><span class="line">  &#123;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>还有一点可以优化：</p><p><code>WaitUntilCanAccess()</code> 中用来判断文件是否可以访问的语句如下：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">File.Open(e.FullPath, FileMode.Open, FileAccess.ReadWrite, FileShare.None);</span><br></pre></td></tr></table></figure><p>，其中的 <code>FileShare</code> 指定的太严格了，可以不做限制。改为如下语句：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">File.Open(e.FullPath, FileMode.Open, FileAccess.ReadWrite, (FileShare)<span class="number">0xff</span>);</span><br></pre></td></tr></table></figure></li></ol><h2 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h2><p>直接克隆</p><p><code>github</code> ：<a href="https://github.com/BianChengNan/FileSystemWatcherEx" target="_blank" rel="noopener">https://github.com/BianChengNan/FileSystemWatcherEx</a></p><p><code>gitee</code> ：  <a href="https://gitee.com/bianchengnan/FileSystemWatcherEx" target="_blank" rel="noopener">https://gitee.com/bianchengnan/FileSystemWatcherEx</a></p><p>也可以直接下载压缩包：</p><p>百度云：<a href="https://pan.baidu.com/s/1OBSFpQYRDQHhO5A0Yviqmw" target="_blank" rel="noopener">https://pan.baidu.com/s/1OBSFpQYRDQHhO5A0Yviqmw</a> 提取码: yic3</p><p>CSDN：<a href="https://download.csdn.net/download/xiaoyanilw/19648448" target="_blank" rel="noopener">https://download.csdn.net/download/xiaoyanilw/19648448</a></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li><p><code>process explorer</code> 不仅可以用来查看进程基本信息，还可以查看哪些文件被哪些进程占用。</p></li><li><p><code>windbg</code> 中的 <code>!htrace</code> 也可以用来追踪句柄情况，但是要求附加到对应的程序中。</p></li><li><p><code>perfView</code> 是非常强大的 <code>ETW</code> 收集及分析工具，可以收集机器级别的信息，包括但不限于句柄，文件读写，注册表读写，进程事件，网络事件等等。</p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;缘起&quot;&gt;&lt;a href=&quot;#缘起&quot; class=&quot;headerlink&quot; title=&quot;缘起&quot;&gt;&lt;/a&gt;缘起&lt;/h2&gt;&lt;p&gt;之前基于 &lt;code&gt;.net&lt;/code&gt; 官方提供的 &lt;code&gt;FileSystemWatcher&lt;/code&gt; 写了一个文件变化监听工具，具体参考&lt;a href=&quot;https://bianchengnan.github.io/articles/A-better-file-system-wacher-based-on-dotnet-FileSystemWatcher/&quot;&gt;这篇文章&lt;/a&gt; 。主要解决了以下三个问题：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;事件触发时，文件可能还不能被访问。&lt;/li&gt;
&lt;li&gt;如果监听选项设置的过多，有可能会多次触发文件变化事件。&lt;/li&gt;
&lt;li&gt;监听过滤器不够灵活，我没找到同时监听多种特定文件类型的方法（比如，同时只监听 &lt;code&gt;.docx&lt;/code&gt; 和 &lt;code&gt;.bmp&lt;/code&gt; 文件）。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;为了解决&lt;strong&gt;问题1&lt;/strong&gt;，我在调用用户注册的回调函数前，会先调用 &lt;code&gt;WaitUntilCanAccess()&lt;/code&gt; 来确保文件是可访问状态。没想到在测试过程中发现了一个意想不到的问题。本文记录了解决这个问题的过程。&lt;/p&gt;
    
    </summary>
    
      <category term="调试实战" scheme="https://bianchengnan.github.io/categories/%E8%B0%83%E8%AF%95%E5%AE%9E%E6%88%98/"/>
    
    
      <category term="原" scheme="https://bianchengnan.github.io/tags/%E5%8E%9F/"/>
    
      <category term="总结" scheme="https://bianchengnan.github.io/tags/%E6%80%BB%E7%BB%93/"/>
    
      <category term="调试" scheme="https://bianchengnan.github.io/tags/%E8%B0%83%E8%AF%95/"/>
    
      <category term="process explorer" scheme="https://bianchengnan.github.io/tags/process-explorer/"/>
    
      <category term="c#" scheme="https://bianchengnan.github.io/tags/c/"/>
    
      <category term="dotnet" scheme="https://bianchengnan.github.io/tags/dotnet/"/>
    
      <category term="perfview" scheme="https://bianchengnan.github.io/tags/perfview/"/>
    
  </entry>
  
  <entry>
    <title>开发常识 | 彻底理清 CreateFile 读写权限与共享模式的关系</title>
    <link href="https://bianchengnan.github.io//articles/review-CreateFile-DesireAccess-ShareMode/"/>
    <id>https://bianchengnan.github.io//articles/review-CreateFile-DesireAccess-ShareMode/</id>
    <published>2023-12-23T07:44:22.000Z</published>
    <updated>2024-12-21T04:02:50.522Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>前一阵子，我在编写文件变化监控程序的时候遇到了文件被占用的问题。很早之前写过一篇关于 <code>CreateFile</code> 函数的 <code>dwDesiredAccess</code> 和 <code>dwShareMode</code> 参数的笔记。我发现之前的理解不够全面、准确。为了更好的理解这两个参数的作用，我搜索了大量资料，编写了测试程序及测试脚本，参考了 <code>xp</code> 源码，终于搞清楚这两个参数的作用。简而言之，需要遵循以下两个规则：</p><p><strong>规则 1</strong>：后续的<strong>访问权限</strong>与先前的<strong>共享模式</strong>不能冲突。</p><p><strong>规则 2</strong>：后续的<strong>共享模式</strong>与先前的<strong>访问权限</strong>不能冲突。</p><p>如果你对下面的几个问题有明确的答案并且清楚的知道原因，那么可以跳过本文了。</p><ol><li>第一次以<strong>读</strong>访问权限，<strong>写</strong>共享模式打开文件，会成功吗？</li><li>如果第一次打开成功了，第二次以<strong>写</strong>访问权限，<strong>读</strong>共享模式打开。会成功吗？</li><li>如果第二次打开成功了，第三次以<strong>读</strong> / <strong>写</strong> / <strong>读写</strong>访问权限，<strong>读写</strong>共享模式打开，会成功吗？</li><li>第一次以<strong>读</strong>访问权限，<strong>写</strong>共享模式打开文件，第二次以<strong>写</strong>访问权限，<strong>读写</strong>共享模式打开。第三次以<strong>写</strong>访问权限，<strong>读写</strong>共享模式打开，会成功吗？</li></ol><a id="more"></a><p>在总结之前，先看一下关键的权限检查代码。</p><h2 id="参考源码"><a href="#参考源码" class="headerlink" title="参考源码"></a>参考源码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">NTSTATUS <span class="title">IoCheckShareAccess</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  IN ACCESS_MASK DesiredAccess,</span></span></span><br><span class="line"><span class="function"><span class="params">  IN ULONG DesiredShareAccess,</span></span></span><br><span class="line"><span class="function"><span class="params">  IN OUT PFILE_OBJECT FileObject,</span></span></span><br><span class="line"><span class="function"><span class="params">  IN OUT PSHARE_ACCESS ShareAccess,</span></span></span><br><span class="line"><span class="function"><span class="params">  IN BOOLEAN Update</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  PAGED_CODE();</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 获取本次调用时，指定的 读/写/删除 访问权限标志</span></span><br><span class="line">  FileObject-&gt;ReadAccess = (BOOLEAN) ((DesiredAccess &amp; (FILE_EXECUTE | FILE_READ_DATA)) != <span class="number">0</span>);</span><br><span class="line">  FileObject-&gt;WriteAccess = (BOOLEAN) ((DesiredAccess &amp; (FILE_WRITE_DATA | FILE_APPEND_DATA)) != <span class="number">0</span>);</span><br><span class="line">  FileObject-&gt;DeleteAccess = (BOOLEAN) ((DesiredAccess &amp; DELETE) != <span class="number">0</span>);</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span> (FileObject-&gt;ReadAccess || FileObject-&gt;WriteAccess || FileObject-&gt;DeleteAccess)</span><br><span class="line">  &#123;      </span><br><span class="line">    <span class="comment">// 获取本次调用时，指定的 读/写/删除 共享模式标志</span></span><br><span class="line">    FileObject-&gt;SharedRead = (BOOLEAN) ((DesiredShareAccess &amp; FILE_SHARE_READ) != <span class="number">0</span>);</span><br><span class="line">    FileObject-&gt;SharedWrite = (BOOLEAN) ((DesiredShareAccess &amp; FILE_SHARE_WRITE) != <span class="number">0</span>);</span><br><span class="line">    FileObject-&gt;SharedDelete = (BOOLEAN) ((DesiredShareAccess &amp; FILE_SHARE_DELETE) != <span class="number">0</span>);</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">if</span> (FileObject-&gt;Flags &amp; FO_FILE_OBJECT_HAS_EXTENSION)</span><br><span class="line">    &#123;</span><br><span class="line">      PIOP_FILE_OBJECT_EXTENSION  fileObjectExtension =(PIOP_FILE_OBJECT_EXTENSION)(FileObject + <span class="number">1</span>);</span><br><span class="line">      <span class="keyword">if</span> (fileObjectExtension-&gt;FileObjectExtensionFlags &amp; FO_EXTENSION_IGNORE_SHARE_ACCESS_CHECK)</span><br><span class="line">        <span class="keyword">return</span> STATUS_SUCCESS;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    ULONG ocount = ShareAccess-&gt;OpenCount;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">if</span> ( <span class="comment">// 本次调用时 DesiredAccess 包含了读/写/删除标志，并且</span></span><br><span class="line">         <span class="comment">// 在之前的调用中，DesiredShareAccess 缺少对应的读/写/删除标志（ShareXXX &lt; ocount）</span></span><br><span class="line">         (FileObject-&gt;ReadAccess &amp;&amp; (ShareAccess-&gt;SharedRead &lt; ocount))</span><br><span class="line">      || (FileObject-&gt;WriteAccess &amp;&amp; (ShareAccess-&gt;SharedWrite &lt; ocount))</span><br><span class="line">      || (FileObject-&gt;DeleteAccess &amp;&amp; (ShareAccess-&gt;SharedDelete &lt; ocount))</span><br><span class="line">         <span class="comment">// 之前的调用中 DesiredAccess 包含了读/写/删除标志，并且</span></span><br><span class="line">         <span class="comment">// 本次调用时 DesiredShareAccess 缺少对应读/写/删除标志 </span></span><br><span class="line">      || ((ShareAccess-&gt;Readers != <span class="number">0</span>) &amp;&amp; !FileObject-&gt;SharedRead)</span><br><span class="line">      || ((ShareAccess-&gt;Writers != <span class="number">0</span>) &amp;&amp; !FileObject-&gt;SharedWrite)</span><br><span class="line">      || ((ShareAccess-&gt;Deleters != <span class="number">0</span>) &amp;&amp; !FileObject-&gt;SharedDelete)</span><br><span class="line">    )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">return</span> STATUS_SHARING_VIOLATION;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (Update)</span><br><span class="line">    &#123;</span><br><span class="line">      ShareAccess-&gt;OpenCount++; <span class="comment">// 每次权限检查通过后，打开计数 +1</span></span><br><span class="line">    </span><br><span class="line">      <span class="comment">// 本次调用时 DesiredAccess 包含了读/写/删除标志，对应的计数 +1</span></span><br><span class="line">      ShareAccess-&gt;Readers += FileObject-&gt;ReadAccess;</span><br><span class="line">      ShareAccess-&gt;Writers += FileObject-&gt;WriteAccess;</span><br><span class="line">      ShareAccess-&gt;Deleters += FileObject-&gt;DeleteAccess;</span><br><span class="line">    </span><br><span class="line">      <span class="comment">// 本次调用时 DesiredShareAccess 包含了读/写/删除标志，对应的计数 +1</span></span><br><span class="line">      ShareAccess-&gt;SharedRead += FileObject-&gt;SharedRead;</span><br><span class="line">      ShareAccess-&gt;SharedWrite += FileObject-&gt;SharedWrite;</span><br><span class="line">      ShareAccess-&gt;SharedDelete += FileObject-&gt;SharedDelete;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> STATUS_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><strong>说明：</strong> <code>DesiredAccess</code> 表示 访问权限，<code>DesiredShareAccess</code> 表示 共享模式。</p></blockquote><p>代码中的注释已经写的很清楚了，再整体梳理一下：</p><p><strong>更新逻辑（else if 分支）：</strong></p><p>每次权限检查成功后，如果指定了 <code>Update</code> 参数，<code>SharedAccess-&gt;OpenCount</code> 计数会加一。</p><p>当 <code>DesiredAccess</code> 包含<strong>读</strong> / <strong>写</strong> / <strong>删除</strong>标志的时候，<code>SharedAccess-&gt;Readers / Writers / Deleters</code> 计数会加一。</p><p>当 <code>DesiredShareAccess</code> 包含<strong>读</strong> / <strong>写</strong> / <strong>删除</strong>标志的时候，<code>ShareAccess-&gt;SharedRead / SharedWrite / SharedDelete</code> 计数会加一。</p><p><strong>检查逻辑（if 分支）：</strong></p><ul><li><p>如果本次调用时 <code>DesiredAccess</code> 包含了<strong>读</strong> / <strong>写</strong> / <strong>删除</strong>标志（<code>FileObject-&gt;ReadAccess / WriteAccess / DeleteAccess</code> 为真）并且在之前的调用中 <code>DesiredShareAccess</code> 缺少对应的<strong>读</strong> / <strong>写</strong> / <strong>删除</strong>标志（<code>ShareAccess-&gt;SharedRead / SharedWrite / SharedDelete &lt; ocount</code>），违反<strong>规则 1</strong>，权限检查会失败。</p></li><li><p>如果在之前的调用中 <code>DesiredAccess</code> 包含了<strong>读</strong> / <strong>写</strong> / <strong>删除</strong>标志（<code>ShareAccess-&gt;Readers / Writers / Deleters != 0</code>），并且本次调用时 <code>DesiredShareAccess</code> 缺少对应<strong>读</strong> / <strong>写</strong> / <strong>删除</strong>标志（<code>FileObject-&gt;SharedRead / SharedWrite / SharedDelete</code> 为假），违反<strong>规则 2</strong>，权限检查会失败。</p></li></ul><p>我把各种情况下的打开结果整理成了表格，供大家参考。</p><h2 id="结果表"><a href="#结果表" class="headerlink" title="结果表"></a>结果表</h2><table><thead><tr><th>访问权限 1</th><th>共享模式 1</th><th>访问权限 2</th><th>共享模式 2</th><th>结果</th><th>说明</th></tr></thead><tbody><tr><td>—</td><td>N</td><td>R / W / RW</td><td>—</td><td>失败</td><td>违反了 <strong>规则1</strong></td></tr><tr><td>—</td><td>R</td><td>W / RW</td><td>—</td><td>失败</td><td>违反了 <strong>规则1</strong></td></tr><tr><td>—</td><td>W</td><td>R / RW</td><td>—</td><td>失败</td><td>违反了 <strong>规则1</strong></td></tr><tr><td>R / W / RW</td><td>—</td><td>—</td><td>N</td><td>失败</td><td>违反了 <strong>规则2</strong></td></tr><tr><td>W / RW</td><td>—</td><td>—</td><td>R</td><td>失败</td><td>违反了 <strong>规则2</strong></td></tr><tr><td>R / RW</td><td>—</td><td>—</td><td>W</td><td>失败</td><td>违反了 <strong>规则2</strong></td></tr><tr><td>R</td><td>R</td><td>R</td><td>R / RW</td><td>成功</td><td>第二次的<strong>访问权限</strong>与第一次的<strong>共享模式</strong>不冲突。 <br>第二次的<strong>共享模式</strong>与第一次的<strong>访问权限</strong>不冲突。</td></tr><tr><td>R</td><td>W</td><td>W</td><td>R / RW</td><td>成功</td><td>同上</td></tr><tr><td>R</td><td>RW</td><td>R / W / RW</td><td>R / RW</td><td>成功</td><td>同上</td></tr><tr><td>W</td><td>W</td><td>W</td><td>W / RW</td><td>成功</td><td>同上</td></tr><tr><td>W</td><td>R</td><td>R</td><td>W / RW</td><td>成功</td><td>同上</td></tr><tr><td>W</td><td>RW</td><td>R / W / RW</td><td>W / RW</td><td>成功</td><td>同上</td></tr><tr><td>RW</td><td>R</td><td>R</td><td>RW</td><td>成功</td><td>同上</td></tr><tr><td>RW</td><td>W</td><td>W</td><td>RW</td><td>成功</td><td>同上</td></tr><tr><td>RW</td><td>RW</td><td>R / W / RW</td><td>RW</td><td>成功</td><td>同上</td></tr></tbody></table><p>各项的意义解释如下：</p><ul><li><p><code>访问权限</code> 代表 <code>dwDesiredAccess</code> 参数，<code>共享模式</code> 代表 <code>dwShareAccess</code> 参数。<code>1</code> 表示第一次调用，<code>2</code> 表示第二次调用。</p></li><li><p><code>R</code> <code>Read</code>，表示<strong>读</strong>。<code>W</code> <code>Write</code>，表示<strong>写</strong>。<code>RW</code> <code>ReadWrite</code>，表示<strong>读写</strong>。<code>N</code> <code>None</code>， 表示<strong>独占</strong>。</p></li><li><p><code>/</code> 表示或者。为了减少组合数量。比如第一行中的 <strong>访问权限 2</strong> 可以是<strong>读</strong> / <strong>写</strong> / <strong>读写</strong>中的任意一种。</p></li><li><p><code>---</code> 表示对应位置是什么都可以，不影响结果。比如，第一行的 <strong>访问权限 1</strong> 可以是<strong>读</strong> / <strong>写</strong> / <strong>读写</strong>中的任意一种，不论是哪种都会打开失败。</p></li><li><p><strong>结果</strong>列只统计了第二次的结果，因为第一次总是成功的。</p></li></ul><p>以上结论我在 <code>win10</code> 系统上亲自验证过，整体验证思路是用不同的参数调用 <code>CreateFile</code> 打开同一个文件。关键验证代码如下：</p><h2 id="验证代码"><a href="#验证代码" class="headerlink" title="验证代码"></a>验证代码</h2><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> System.CommandLine;</span><br><span class="line"><span class="keyword">using</span> System.IO;</span><br><span class="line"><span class="keyword">using</span> System.Linq;</span><br><span class="line"><span class="keyword">using</span> System.Text;</span><br><span class="line"><span class="keyword">using</span> System.Threading.Tasks;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">CreateFile</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// ref https://learn.microsoft.com/en-us/dotnet/standard/commandline/define-commands</span></span><br><span class="line">        <span class="function"><span class="keyword">static</span> Command <span class="title">SetupCommandHandler</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>        &#123;</span><br><span class="line">            <span class="keyword">var</span> filePathOption = <span class="keyword">new</span> Option&lt;<span class="keyword">string</span>&gt;(name: <span class="string">"--path"</span>, getDefaultValue: () =&gt; <span class="string">"test.txt"</span>, description: <span class="string">"file path"</span>);</span><br><span class="line">            filePathOption.AddAlias(<span class="string">"-f"</span>);</span><br><span class="line">            filePathOption.AddAlias(<span class="string">"-p"</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">var</span> fileModeOption = <span class="keyword">new</span> Option&lt;<span class="keyword">string</span>&gt;(name: <span class="string">"--mode"</span>, getDefaultValue: () =&gt; <span class="string">"Open"</span>, description: <span class="string">"file mode"</span>)</span><br><span class="line">                .FromAmong(<span class="string">"CreateNew"</span>, <span class="string">"Create"</span>, <span class="string">"Open"</span>, <span class="string">"OpenOrCreate"</span>, <span class="string">"Truncate"</span>, <span class="string">"Append"</span>);</span><br><span class="line">            fileModeOption.AddAlias(<span class="string">"-m"</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">var</span> fileShareOption = <span class="keyword">new</span> Option&lt;<span class="keyword">string</span>&gt;(<span class="string">"--share"</span>, <span class="string">"file share"</span>) &#123; IsRequired = <span class="literal">true</span> &#125;</span><br><span class="line">                .FromAmong(<span class="string">"None"</span>, <span class="string">"Read"</span>, <span class="string">"Write"</span>, <span class="string">"ReadWrite"</span>, <span class="string">"Delete"</span>, <span class="string">"Inheritable"</span>);</span><br><span class="line">            fileShareOption.AddAlias(<span class="string">"-s"</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">var</span> fileAccessOption = <span class="keyword">new</span> Option&lt;<span class="keyword">string</span>&gt;(<span class="string">"--access"</span>, <span class="string">"file access"</span>) &#123; IsRequired = <span class="literal">true</span> &#125;</span><br><span class="line">                .FromAmong(<span class="string">"Read"</span>, <span class="string">"Write"</span>, <span class="string">"ReadWrite"</span>);</span><br><span class="line">            fileAccessOption.AddAlias(<span class="string">"-a"</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">var</span> autoQuitOption = <span class="keyword">new</span> Option&lt;<span class="keyword">bool</span>&gt;(name: <span class="string">"--autoquit"</span>, getDefaultValue: () =&gt; <span class="literal">false</span>, description: <span class="string">"auto quit"</span>);</span><br><span class="line">            autoQuitOption.AddAlias(<span class="string">"-q"</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">var</span> command = <span class="keyword">new</span> RootCommand();</span><br><span class="line">            command.Add(filePathOption);</span><br><span class="line">            command.Add(fileModeOption);</span><br><span class="line">            command.Add(fileShareOption);</span><br><span class="line">            command.Add(fileAccessOption);</span><br><span class="line">            command.Add(autoQuitOption);</span><br><span class="line"></span><br><span class="line">            command.SetHandler((filePath, fileMode, fileShare, fileAccess, autoQuit) =&gt;</span><br><span class="line">            &#123;</span><br><span class="line">                OpenFileAndWait(filePath, fileMode, fileShare, fileAccess, autoQuit);</span><br><span class="line">            &#125;, filePathOption, fileModeOption, fileShareOption, fileAccessOption, autoQuitOption);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> command;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="keyword">string</span>[] args</span>)</span></span><br><span class="line"><span class="function"></span>        &#123;</span><br><span class="line">            <span class="keyword">var</span> command = SetupCommandHandler();</span><br><span class="line">            command.Invoke(args);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">OpenFileAndWait</span>(<span class="params"><span class="keyword">string</span> strFilePath, <span class="keyword">string</span> strFileMode, <span class="keyword">string</span> strFileShare, <span class="keyword">string</span> strFileAccess, <span class="keyword">bool</span> autoQuit</span>)</span></span><br><span class="line"><span class="function"></span>        &#123;</span><br><span class="line">            FileStream stream = <span class="literal">null</span>;</span><br><span class="line">            <span class="keyword">try</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">var</span> fileMode = (FileMode)System.Enum.Parse(<span class="keyword">typeof</span>(FileMode), strFileMode);</span><br><span class="line">                <span class="keyword">var</span> fileShare = (FileShare)System.Enum.Parse(<span class="keyword">typeof</span>(FileShare), strFileShare);</span><br><span class="line">                <span class="keyword">var</span> fileAccess = (FileAccess)System.Enum.Parse(<span class="keyword">typeof</span>(FileAccess), strFileAccess);</span><br><span class="line"></span><br><span class="line">                System.Console.WriteLine(<span class="keyword">string</span>.Format(<span class="string">"[&#123;0&#125;] file:&#123;1&#125;, mode: &#123;2&#125;, share: &#123;3&#125;, access: &#123;4&#125;!"</span></span><br><span class="line">                  , System.DateTime.Now.ToString(<span class="string">"yyyy-MM-dd HH:mm:ss.fff"</span>), strFilePath, strFileMode, strFileShare, strFileAccess));</span><br><span class="line"></span><br><span class="line">                stream = File.Open(strFilePath, fileMode, fileAccess, fileShare);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">catch</span> (Exception ex)</span><br><span class="line">            &#123;</span><br><span class="line">                System.Console.WriteLine(<span class="keyword">string</span>.Format(<span class="string">"opening file [&#123;0&#125;] failed with &#123;1&#125;!"</span>, strFilePath, ex));</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (!autoQuit)</span><br><span class="line">            &#123;</span><br><span class="line">                System.Console.WriteLine(<span class="string">"press any key to continue..."</span>);</span><br><span class="line">                System.Console.ReadKey();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (stream != <span class="literal">null</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                stream.Dispose();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>生成的程序名是 <code>CreateFile.exe</code>，该程序可以接收命令行参数，通过 <code>-f</code> 指定文件名，通过 <code>-a</code> 指定访问权限，通过 <code>-s</code> 指定共享模式， 通过 <code>-h</code> 显示帮助。</p><h2 id="验证脚本"><a href="#验证脚本" class="headerlink" title="验证脚本"></a>验证脚本</h2><p>为了更方便的验证，我又写了批处理脚本，关键脚本如下：</p><figure class="highlight bat"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">:: read-readwrite-write-none.bat</span><br><span class="line">CreateFileBatchCaller.bat <span class="variable">%~n0%</span></span><br></pre></td></tr></table></figure><figure class="highlight bat"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">:: CreateFileBatchCaller.bat</span><br><span class="line">@<span class="built_in">echo</span> off</span><br><span class="line"><span class="built_in">cd</span> /d %~dp0</span><br><span class="line"></span><br><span class="line"><span class="built_in">setlocal</span> enabledelayedexpansion</span><br><span class="line"></span><br><span class="line"><span class="built_in">set</span> AccessParams=<span class="variable">%1%</span></span><br><span class="line"><span class="built_in">set</span> AccessParams=<span class="variable">%AccessParams:read=Read%</span></span><br><span class="line"><span class="built_in">set</span> AccessParams=<span class="variable">%AccessParams:write=Write%</span></span><br><span class="line"><span class="built_in">set</span> AccessParams=<span class="variable">%AccessParams:none=None%</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">For</span> /f "tokens=<span class="number">1</span>-<span class="number">4</span> delims=_/. " <span class="variable">%%i</span> <span class="keyword">In</span> ("<span class="variable">%AccessParams%</span>") <span class="keyword">do</span> (</span><br><span class="line">  <span class="built_in">set</span> Access1=<span class="variable">%%i</span></span><br><span class="line">  <span class="built_in">set</span> SharedAccess1=<span class="variable">%%j</span></span><br><span class="line">  <span class="built_in">set</span> Access2=<span class="variable">%%k</span></span><br><span class="line">  <span class="built_in">set</span> SharedAccess2=<span class="variable">%%l</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="built_in">start</span> CreateFile -f test.txt -a <span class="variable">%Access1%</span> -s <span class="variable">%SharedAccess1%</span></span><br><span class="line"></span><br><span class="line">:: will this success?</span><br><span class="line">timeout /T <span class="number">1</span></span><br><span class="line"><span class="built_in">start</span> CreateFile -f test.txt -a <span class="variable">%Access2%</span> -s <span class="variable">%SharedAccess2%</span></span><br></pre></td></tr></table></figure><p>脚本 <code>CreateFileBatchCaller.bat</code> 接收一个参数，内部会根据 <code>-</code> 分割参数，前四项有固定意义，分别表示第一次调用 <code>CreateFile.exe</code> 的访问权限和共享模式、第二次调用 <code>CreateFile.exe</code> 的访问权限和共享模式。</p><p><code>read-readwrite-write-none-failed.bat</code> 是众多调用脚本中的一个，内部会把当前脚本的文件名（不包括扩展名）当作参数调用 <code>CreateFileBatchCaller.bat</code> 。 该脚本可以验证第一次以<strong>读</strong>访问权限、<strong>读写</strong>共享模式打开文件，第二次以<strong>写</strong>访问权限、<strong>独占</strong>共享模式打开文件的情况。 </p><h2 id="亲自动手"><a href="#亲自动手" class="headerlink" title="亲自动手"></a>亲自动手</h2><p>所有脚本及源码我已经上传到我的个人仓库了。如果你也想亲自动手验证一下，可以从如下位置获取测试代码，编译好的程序及测试脚本。</p><p>github:</p><p><a href="https://github.com/BianChengNan/MyBlogStuff/tree/master/review-CreateFile-DesireAccess-ShareMode" target="_blank" rel="noopener">https://github.com/BianChengNan/MyBlogStuff/tree/master/review-CreateFile-DesireAccess-ShareMode</a></p><p>gitee:</p><p><a href="https://gitee.com/bianchengnan/my-blog-stuff/tree/master/review-CreateFile-DesireAccess-ShareMode" target="_blank" rel="noopener">https://gitee.com/bianchengnan/my-blog-stuff/tree/master/review-CreateFile-DesireAccess-ShareMode</a></p><p>百度云盘：</p><p><a href="https://pan.baidu.com/s/10BMMhPGiiBYjlMFrbQH-3g?pwd=tibm" target="_blank" rel="noopener">https://pan.baidu.com/s/10BMMhPGiiBYjlMFrbQH-3g?pwd=tibm</a></p><p>至此，文章开头的几个问题的答案应该已经很明显了。一起来看一下。</p><h2 id="解惑"><a href="#解惑" class="headerlink" title="解惑"></a>解惑</h2><ol><li><p>第一次尝试以<strong>读</strong>访问权限，<strong>写</strong>共享模式打开文件，会成功吗？</p><p><strong>答：会成功。</strong></p><p>第一次打开时总会成功。</p></li></ol><ol start="2"><li><p>如果第一次打开成功了，第二次尝试以<strong>写</strong>访问权限，<strong>读</strong>共享模式打开。会成功吗？</p><p><strong>答：会成功。</strong></p><p>第一次的共享模式是<strong>写</strong>，第二次的访问权限是<strong>写</strong>，第二次的访问权限与第一次的共享模式不冲突。</p><p>第二次的共享模式是<strong>读</strong>，第一次的访问权限是<strong>读</strong>，第二次的共享模式与第一次的访问权限不冲突。</p><p><img src="http://resources.bianchengnan.tech/review-CreateFile-DesireAccess-ShareMode/open-result-2.png" alt="open-result-2"></p></li></ol><ol start="3"><li><p>如果第二次打开成功了，第三次尝试以<strong>读</strong>/<strong>写</strong>/<strong>读写</strong>访问权限，<strong>读写</strong>共享模式打开，会成功吗？</p><p><strong>答：不会成功。</strong></p><p>第三次的访问权限是<strong>读</strong>的话，与第一次的共享模式（<strong>写</strong>）冲突。</p><p>第三次的访问权限是<strong>写</strong>的话，与第二次的共享模式（<strong>读</strong>）冲突。</p><p>第三次的访问权限是<strong>读写</strong>的话，既与第一次的共享模式（<strong>写</strong>）冲突，又与第二次的共享模式（<strong>读</strong>）冲突。<br><img src="http://resources.bianchengnan.tech/review-CreateFile-DesireAccess-ShareMode/open-result-3.png" alt="open-result-3"></p><p>这里只贴了第三次的访问权限是<strong>写</strong>的情况，其它两种情况也会失败。</p></li><li><p>第一次尝试以<strong>读</strong>访问权限，<strong>写</strong>共享模式打开文件，第二次尝试以<strong>写</strong>访问权限，<strong>读写</strong>共享模式打开。第三次尝试以<strong>写</strong>访问权限，<strong>读写</strong>共享模式打开，会成功吗？</p><p><strong>答：会成功。</strong></p><p>第三次的访问权限（<strong>写</strong>），既不与第一次的共享模式（<strong>写</strong>）冲突，又不与第二次的共享模式（<strong>读写</strong>）冲突。</p><p>第三次的共享模式（<strong>读写</strong>），既不与第一次的访问权限（<strong>读</strong>）冲突，又不与第二次的访问权限（<strong>写</strong>）冲突。<br><img src="http://resources.bianchengnan.tech/review-CreateFile-DesireAccess-ShareMode/open-result-4.png" alt="open-result-4"></p></li></ol><p>最后，贴一下之前整理的笔记，基本正确，但是不够全面，不够深刻。</p><h2 id="CreateFile-参数"><a href="#CreateFile-参数" class="headerlink" title="CreateFile 参数"></a>CreateFile 参数</h2><p>一直对 <code>CreateFile</code> 的参数 <code>dwDesiredAccess</code> 和 <code>dwShareMode</code> 的具体作用不是很清楚，今天重读《windows 核心编程》的时候有了一些新感悟。 简要总结如下：</p><ul><li><code>dwDesiredAccess</code> 表示本次 <code>CreateFile</code> 想要获取的权限: 只读(<code>GENERIC_READ</code>)，只写(<code>GENERIC_WRITE</code>)，可读写 (<code>GENERIC_READ | GENERIC_WRITE</code>)。</li><li><code>dwShareMode</code> 表示后续 <code>CreateFile</code> 可以取得什么权限。</li></ul><p>对 <code>dwDesiredAccess</code> 各种值及含义抄录如下（摘自 《Windows核心编程》第 <code>5</code> 版 第<code>10</code> 章 <code>p279</code>）：</p><table><thead><tr><th>值</th><th>含义</th></tr></thead><tbody><tr><td>0</td><td>我们不希望从设备读取数据或向设备写入数据。如果只想改变设备的配置（比如只是修改文件的时间戳），那么可以传 <code>0</code></td></tr><tr><td>GENERIC_READ</td><td>允许对设备进行只读访问</td></tr><tr><td>GENERIC_WRITE</td><td>允许对设备进行只写访问。例如，备份软件会用到这个标志，如果想把数据发送到打印机，也可以使用这个标志。注意，<code>GENERIC_WRITE</code> 标志并没有隐式地包含 <code>GENERIC_READ</code> 标志</td></tr><tr><td>GENERIC_READ | GENERIC_WRITE</td><td>允许对设备进行读写操作。由于这个标志允许我们和设备之间自由地交换数据，因此最为常用</td></tr></tbody></table><p>对 <code>dwShareMode</code> 的各种值及含义抄录如下（摘自 《Windows核心编程》第 <code>5</code> 版 第<code>10</code> 章 <code>p279</code>）：</p><table><thead><tr><th>值</th><th>含义</th></tr></thead><tbody><tr><td>0</td><td>要求独占对设备的访问。 如果设备己经打开，<code>CreateFile</code> 调用会失败。如果我们成功地打开了设备，那么后续的 <code>CreateFile</code> 调用会失败</td></tr><tr><td>FILE_SHARE_READ</td><td>如果有其他内核对象要使用该设备，我们要求它们不得修改设备的数据。 如果设备已经以写入方式或独占方式打开，那么我们的 <code>CreateFile</code> 会失败。 如果我们成功地打开了设备，那么后续的使用了 <code>GENERIC_WRITE</code> 访问标志的 <code>CreateFile</code> 调用会失败</td></tr><tr><td>FILE_SHARE_WRITE</td><td>如果有其他内核对象要使用该设备，我们要求它们不得读取设备的数据。 如果设备已经以读取方式或独占方式打开，那么我们的 <code>CreateFile</code> 调用会失败。 如果我们成功地打开了设备，那么后续的使用了<code>GENERIC_READ</code> 访问标志的 <code>CreateFile</code> 调用会失畋</td></tr><tr><td>FILE_SHARE_READ | FILE_SHARE_WRITE</td><td>如果有其他内核对象要使用该设备，我们不关心它们会从设备读取数据还是会向设备写入数据。如果设备已经以独占方式打开，那么我们的 <code>CreateFile</code> 调用会失败。如果我们成功地打开了设备，那么后续的要求独占读取访问、独占写入访问或独占读写访问的 <code>CreateFile</code> 调用会失败</td></tr><tr><td>FILE_SHARE_DELETE</td><td>当对文件进行操作的时候，我们不关心文件是否被逻辑删除或是被移动。在 <code>Windows</code> 内部，系统会先将文件标记为待删除，然后当该文件所有已打开的句柄都被关闭的时候，再将其真正的删除</td></tr></tbody></table><blockquote><p><strong>友情提示：</strong> 上表中的 <code>如果设备已经以 xxx 方式打开</code> 指的是先前调用的 <code>dwShareMode</code> 参数。</p></blockquote><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://0cch.com/2011/05/22/e585b3e4ba8ee69687e4bbb6shareaccess/" target="_blank" rel="noopener">https://0cch.com/2011/05/22/e585b3e4ba8ee69687e4bbb6shareaccess/</a>  强烈推荐阅读！！！</li><li><a href="https://docs.microsoft.com/en-us/windows/win32/api/fileapi/nf-fileapi-createfilea" target="_blank" rel="noopener">https://docs.microsoft.com/en-us/windows/win32/api/fileapi/nf-fileapi-createfilea</a></li><li><a href="https://community.osr.com/discussion/32329/file-object-fscontext9" target="_blank" rel="noopener">https://community.osr.com/discussion/32329/file-object-fscontext9</a></li><li>《windows 核心编程》第 <code>5</code> 版 第<code>10</code> 章</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;前一阵子，我在编写文件变化监控程序的时候遇到了文件被占用的问题。很早之前写过一篇关于 &lt;code&gt;CreateFile&lt;/code&gt; 函数的 &lt;code&gt;dwDesiredAccess&lt;/code&gt; 和 &lt;code&gt;dwShareMode&lt;/code&gt; 参数的笔记。我发现之前的理解不够全面、准确。为了更好的理解这两个参数的作用，我搜索了大量资料，编写了测试程序及测试脚本，参考了 &lt;code&gt;xp&lt;/code&gt; 源码，终于搞清楚这两个参数的作用。简而言之，需要遵循以下两个规则：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;规则 1&lt;/strong&gt;：后续的&lt;strong&gt;访问权限&lt;/strong&gt;与先前的&lt;strong&gt;共享模式&lt;/strong&gt;不能冲突。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;规则 2&lt;/strong&gt;：后续的&lt;strong&gt;共享模式&lt;/strong&gt;与先前的&lt;strong&gt;访问权限&lt;/strong&gt;不能冲突。&lt;/p&gt;
&lt;p&gt;如果你对下面的几个问题有明确的答案并且清楚的知道原因，那么可以跳过本文了。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;第一次以&lt;strong&gt;读&lt;/strong&gt;访问权限，&lt;strong&gt;写&lt;/strong&gt;共享模式打开文件，会成功吗？&lt;/li&gt;
&lt;li&gt;如果第一次打开成功了，第二次以&lt;strong&gt;写&lt;/strong&gt;访问权限，&lt;strong&gt;读&lt;/strong&gt;共享模式打开。会成功吗？&lt;/li&gt;
&lt;li&gt;如果第二次打开成功了，第三次以&lt;strong&gt;读&lt;/strong&gt; / &lt;strong&gt;写&lt;/strong&gt; / &lt;strong&gt;读写&lt;/strong&gt;访问权限，&lt;strong&gt;读写&lt;/strong&gt;共享模式打开，会成功吗？&lt;/li&gt;
&lt;li&gt;第一次以&lt;strong&gt;读&lt;/strong&gt;访问权限，&lt;strong&gt;写&lt;/strong&gt;共享模式打开文件，第二次以&lt;strong&gt;写&lt;/strong&gt;访问权限，&lt;strong&gt;读写&lt;/strong&gt;共享模式打开。第三次以&lt;strong&gt;写&lt;/strong&gt;访问权限，&lt;strong&gt;读写&lt;/strong&gt;共享模式打开，会成功吗？&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="开发" scheme="https://bianchengnan.github.io/categories/%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="开发" scheme="https://bianchengnan.github.io/tags/%E5%BC%80%E5%8F%91/"/>
    
      <category term="基础知识" scheme="https://bianchengnan.github.io/tags/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
      <category term="win10" scheme="https://bianchengnan.github.io/tags/win10/"/>
    
      <category term="xp" scheme="https://bianchengnan.github.io/tags/xp/"/>
    
      <category term="权限" scheme="https://bianchengnan.github.io/tags/%E6%9D%83%E9%99%90/"/>
    
      <category term="CreateFile" scheme="https://bianchengnan.github.io/tags/CreateFile/"/>
    
  </entry>
  
  <entry>
    <title>如何确定线程栈的基址？</title>
    <link href="https://bianchengnan.github.io//articles/how-to-check-thread-stack-base/"/>
    <id>https://bianchengnan.github.io//articles/how-to-check-thread-stack-base/</id>
    <published>2023-10-28T23:44:04.000Z</published>
    <updated>2024-12-21T04:02:50.226Z</updated>
    
    <content type="html"><![CDATA[<h2 id="缘起"><a href="#缘起" class="headerlink" title="缘起"></a>缘起</h2><p>很早之前，我遇到过几个与栈相关的问题，当时总结过几篇关于线程栈的文章，分别是 <a href="https://bianchengnan.github.io/articles/interesting-exception-0xc00000fd-continue-how-to-increase-stack-size/">《栈大小可以怎么改？》</a>、<a href="https://bianchengnan.github.io/articles/stack-variable-usage-optimization-investigation/">《栈局部变量优化探究，意外发现了 vs 的一个 bug ？》</a>、<a href="https://bianchengnan.github.io/articles/another-interesting-stackoverflow/">《栈又溢出了》</a>、<a href="https://bianchengnan.github.io/articles/interesting-exception-0xc00000fd/">《有趣的异常》</a>。在这几篇总结中，简单的总结了栈溢出的原因，设置线程栈大小的方法。但是还有一点没弄清楚：操作系统是怎么知道一个线程的栈大小的？一定记录在某个位置了，否则就不能正确的在栈溢出的时候抛出异常了。不能根据 <code>PE</code> 头中的字段判断，因为在创建线程的时候可以指定线程栈大小。<code>TEB</code> 中的 <code>StackLimit</code> 是真正的栈底吗？带着这些疑问一起来刨根问底吧~</p><blockquote><p><strong>友情提示</strong>：结论在文章末尾。</p></blockquote><a id="more"></a><h2 id="teb-命令"><a href="#teb-命令" class="headerlink" title="!teb 命令"></a>!teb 命令</h2><p>相信，很多小伙伴儿都知道，可以使用 <code>!teb</code> 查看线程相关的信息。</p><p><img src="http://resources.bianchengnan.tech/how-to-check-thread-stack-base/view-thread-using-teb-command.png" alt="view-thread-using-teb-command"></p><p>其中的 <code>StackBase</code> 和 <code>StackLimit</code> 分别指示了栈顶和当前栈使用情况。因为栈是从上向下增长的，所以 <code>StackBase</code> 的值比较大。</p><p>我之前一直认为这两个字段分别指向了栈顶和栈底（线程栈可以到达的最低位置），可以通过这两个字段计算出线程栈大小。后来才发现 <code>StackLimit</code> 并没有指向栈底，而是指向了线程栈当前所到达的最低位置。</p><p>线程栈默认的大小是 <code>1MB</code>。如果计算一下 <code>StackBase - StackLimit</code> 的值即可知道，它们的差值是 <code>256KB</code>，而不是 <code>1MB</code>。</p><p><img src="http://resources.bianchengnan.tech/how-to-check-thread-stack-base/calculate-current-thread-stack-size.png" alt="calculate-current-thread-stack-size"></p><p>那么当前线程栈的大小是不是 <code>1MB</code> 呢？该如何确认呢？可以通过 <code>vmmap</code> 确定。</p><h2 id="vmmap"><a href="#vmmap" class="headerlink" title="vmmap"></a>vmmap</h2><p>打开 <code>vmmap.exe</code>，并选择想要查看的进程，即可进行查看。</p><blockquote><p><strong>注意：</strong> 当选择的进程已经中断到调试器时，<code>vmmap.exe</code> 会一直等待，需要让目标进程运行起来。</p></blockquote><p><img src="http://resources.bianchengnan.tech/how-to-check-thread-stack-base/view-stack-size-in-vmmap.png" alt="view-stack-size-in-vmmap"></p><p>可以看到，线程 <code>9804</code> 的线程栈大小确实是 <code>1MB</code>。</p><p>根据以上信息，可以确定 <code>StackLimit</code> 并不是真正的线程栈栈底。那么，栈底位置到底记录在哪里了呢？</p><p>最近在重翻《软件调试》的时候，发现了一个关键函数。</p><h2 id="栈空间自动增长的关键函数"><a href="#栈空间自动增长的关键函数" class="headerlink" title="栈空间自动增长的关键函数"></a>栈空间自动增长的关键函数</h2><p>在第 <code>22</code> 章 <code>22.8.1</code> 节 栈空间的自动增长（<code>P617</code>）中提到了一个关键函数 <code>MiCheckForUserStackOverflow</code>。该函数是判断栈空间能否增长的关键函数。如果知道该函数是如何实现的，就能找到栈底了。</p><p>脑子里很快有了三个选项：<code>google</code> 搜索，<code>ReactOS</code> 和 <code>server03</code> 源码。正好电脑上有源码，不用考虑其它两个选项了。</p><h2 id="参考源码"><a href="#参考源码" class="headerlink" title="参考源码"></a>参考源码</h2><p>知道了函数名，但是还不知道这个函数在哪个文件中实现的。这个简单，在 <code>File Locator</code> 中输入 <code>MiCheckForUserStackOverflow</code>，很快就找到了关键的文件。</p><p><img src="http://resources.bianchengnan.tech/how-to-check-thread-stack-base/search-MiCheckForUserStackOverflow.png" alt="search-MiCheckForUserStackOverflow"></p><p>双击打开 <code>accesschk.c</code>，找到 <code>MiCheckForUserStackOverflow</code>。注释很清晰的解释了这个函数的作用。</p><p><img src="http://resources.bianchengnan.tech/how-to-check-thread-stack-base/MiCheckForUserStackOverflow-description.png" alt="MiCheckForUserStackOverflow-description"></p><blockquote><p><strong>说明：</strong> 该函数的实现在 <code>wrk</code> 中也可以找到，地址是 <a href="https://github.com/mic101/windows/blob/master/WRK-v1.2/base/ntos/mm/acceschk.c。" target="_blank" rel="noopener">https://github.com/mic101/windows/blob/master/WRK-v1.2/base/ntos/mm/acceschk.c。</a></p></blockquote><p>整个函数虽然行数很多，但是有大部分是注释，而且考虑了各种情况。我截取了最关键的部分，如下图：</p><p><img src="http://resources.bianchengnan.tech/how-to-check-thread-stack-base/MiCheckForUserStackOverflow-key-flow.png" alt="MiCheckForUserStackOverflow-key-flow"></p><p>看样子 <code>teb-&gt;DeallocationStack</code> 记录了栈底。 <code>StackBase</code> 减去 <code>teb-&gt;DeallocationStack</code> 的值应该是栈大小（默认是 <code>1MB</code>）。在 <code>windbg</code> 中验证一下。</p><h2 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h2><p>在 <code>windbg</code> 中输入如下命令 <code>dt _teb 0043f000 -y DeallocationStack -y NtTib.StackBase</code>，只查看 <code>DeallocationStack</code> 和 <code>NtTib.StackBase</code> 的值。然后计算差值，发现正好是 <code>1MB</code> （<code>0x100000</code>）。</p><p><img src="http://resources.bianchengnan.tech/how-to-check-thread-stack-base/view-stack-base-and-stack-size.png" alt="view-stack-base-and-stack-size"></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li><p><code>_TEB</code> 结构体的 <code>DeallocationStack</code> 指向线程栈底，而 <code>NtTib.StackLimit</code> 指向的是线程栈当前所到达的最低位置。</p></li><li><p>可以在 <code>dt</code> 命令中通过 <code>-y</code> 选项来显示特定字段。</p></li><li><p><code>vmmap.exe</code> 可以非常详细的展示进程虚拟内存情况。</p></li></ul><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li>《软件调试》第一版 第 <code>22</code> 章</li><li><code>srv03rtm</code> 源码</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;缘起&quot;&gt;&lt;a href=&quot;#缘起&quot; class=&quot;headerlink&quot; title=&quot;缘起&quot;&gt;&lt;/a&gt;缘起&lt;/h2&gt;&lt;p&gt;很早之前，我遇到过几个与栈相关的问题，当时总结过几篇关于线程栈的文章，分别是 &lt;a href=&quot;https://bianchengnan.github.io/articles/interesting-exception-0xc00000fd-continue-how-to-increase-stack-size/&quot;&gt;《栈大小可以怎么改？》&lt;/a&gt;、&lt;a href=&quot;https://bianchengnan.github.io/articles/stack-variable-usage-optimization-investigation/&quot;&gt;《栈局部变量优化探究，意外发现了 vs 的一个 bug ？》&lt;/a&gt;、&lt;a href=&quot;https://bianchengnan.github.io/articles/another-interesting-stackoverflow/&quot;&gt;《栈又溢出了》&lt;/a&gt;、&lt;a href=&quot;https://bianchengnan.github.io/articles/interesting-exception-0xc00000fd/&quot;&gt;《有趣的异常》&lt;/a&gt;。在这几篇总结中，简单的总结了栈溢出的原因，设置线程栈大小的方法。但是还有一点没弄清楚：操作系统是怎么知道一个线程的栈大小的？一定记录在某个位置了，否则就不能正确的在栈溢出的时候抛出异常了。不能根据 &lt;code&gt;PE&lt;/code&gt; 头中的字段判断，因为在创建线程的时候可以指定线程栈大小。&lt;code&gt;TEB&lt;/code&gt; 中的 &lt;code&gt;StackLimit&lt;/code&gt; 是真正的栈底吗？带着这些疑问一起来刨根问底吧~&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;友情提示&lt;/strong&gt;：结论在文章末尾。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="调试实战" scheme="https://bianchengnan.github.io/categories/%E8%B0%83%E8%AF%95%E5%AE%9E%E6%88%98/"/>
    
      <category term="工具" scheme="https://bianchengnan.github.io/categories/%E8%B0%83%E8%AF%95%E5%AE%9E%E6%88%98/%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="原" scheme="https://bianchengnan.github.io/tags/%E5%8E%9F/"/>
    
      <category term="总结" scheme="https://bianchengnan.github.io/tags/%E6%80%BB%E7%BB%93/"/>
    
      <category term="调试" scheme="https://bianchengnan.github.io/tags/%E8%B0%83%E8%AF%95/"/>
    
      <category term="windbg" scheme="https://bianchengnan.github.io/tags/windbg/"/>
    
      <category term="转储" scheme="https://bianchengnan.github.io/tags/%E8%BD%AC%E5%82%A8/"/>
    
      <category term="stack" scheme="https://bianchengnan.github.io/tags/stack/"/>
    
      <category term="vmmap" scheme="https://bianchengnan.github.io/tags/vmmap/"/>
    
  </entry>
  
  <entry>
    <title>调试实战 | 记一次有教益的 MFC 程序崩溃分析</title>
    <link href="https://bianchengnan.github.io//articles/troubleshoot-crash-after-tidy-dialog-control-id/"/>
    <id>https://bianchengnan.github.io//articles/troubleshoot-crash-after-tidy-dialog-control-id/</id>
    <published>2023-10-22T03:50:01.000Z</published>
    <updated>2024-12-21T04:02:50.749Z</updated>
    
    <content type="html"><![CDATA[<h2 id="缘起"><a href="#缘起" class="headerlink" title="缘起"></a>缘起</h2><p>实际项目中，<code>resource.h</code> 文件中的控件太多太乱了，合并代码的时候非常痛苦。为了解决这个问题，需要对 <code>resource.h</code> 中的 <code>ID</code> 进行整理。根据之前整理的成果，很快把控件 <code>ID</code> 按对话框分类整理好了。没想到测试的时候遇到了各种崩溃，废了好大劲儿才解决。究其原因，是对 <code>MFC</code> 资源管理机制认识不够深刻。尝试创建某个模块内的对话框的时候，意外地找到了其它模块中的对话框资源。<code>MFC</code> 到底是怎么查找资源模块的呢？应该如何排查这种问题呢？一起来看看吧。</p><a id="more"></a><h2 id="背景介绍"><a href="#背景介绍" class="headerlink" title="背景介绍"></a>背景介绍</h2><p>根据之前的认知，同一个模块中，对话框 <code>ID</code> 不能重复，对话框之间的控件 <code>ID</code> 是可以重复的。因为查找资源的时候是分层查找的，先找到对应的对话框资源，然后在此对话框范围内再查找控件。如果认知没错，那么不同对话框可以使用重复的控件 <code>ID</code> ，也就是说对话框 <code>A</code> 用到的控件 <code>ID</code> 值可以与对话框 <code>B</code> 用到的控件 <code>ID</code> 值一样。以此为依据，我遍历并解析了 <code>.rc</code> 文件中的所有对话框及其控件 <code>ID</code>，并以对话框为组，把每个对话框用到的控件 <code>ID</code> 重新归类。整理后的 <code>resource.h</code> 如下图所示：</p><p><img src="http://resources.bianchengnan.tech/troubleshoot-crash-after-tidy-dialog-control-id/grouped_resource_h.png" alt="grouped_resource_h"></p><p><code>IDD_DIALOG1</code> 和 <code>IDD_DIALOG2</code> 都用到宏名为 <code>IDC_BUTTON1</code> 和 <code>IDC_BUTTON2</code> 的按钮。因为有多个对话框用到了同样的控件名，需要把重复的控件名整理到 <code>IdGroup.Common</code> 组下，<code>IDC_BUTTON3</code> 和 <code>IDC_BUTTON4</code> 的值都被设置为了 <code>20003</code>。整理前，控件 <code>ID</code> 是递增排列的，整理后两个对话框中的控件 <code>ID</code> 值是完全重复的。</p><h2 id="理想很丰满，现实很骨感"><a href="#理想很丰满，现实很骨感" class="headerlink" title="理想很丰满，现实很骨感"></a>理想很丰满，现实很骨感</h2><p>在本地测试通过后，就开始在实际项目中实战了。没想到遇到了各种各样的编译问题。</p><p>比如，<code>.rc</code> 中用了一个控件名，实际代码中用了另外一个名字（使用 <code>vs</code> 修改控件名就会产生名称不同，但是值相同的宏）。</p><p>又比如，代码中用到了 <code>.rc</code> 中没有的控件，<code>GetDlgItem(IDC_NOT_EXISTED)-&gt;ShowWindow(SW_HIDE)</code>，这个肯定是错误，只不过相关的代码已经废弃不用了，所以一直没出问题。</p><blockquote><p><strong>说明：</strong> 因为整理后的 <code>resource.h</code> 中的控件 <code>id</code> 完全是根据 <code>.rc</code> 文件来的，所以会有编译问题。</p></blockquote><p>解决完这些编译问题后，终于可以测试功能是否受影响了。没想到刚开始测试就“翻车”了……</p><h2 id="意外的崩溃"><a href="#意外的崩溃" class="headerlink" title="意外的崩溃"></a>意外的崩溃</h2><p>没想到测试到第 <code>2</code> 个功能的时候就崩溃了。心里咯噔一下。难道之前的认知错了？不管怎么样，需要先把崩溃问题解决掉。先看看是哪里崩溃了，原来是下面的代码导致了崩溃：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GetDlgItem(IDC_BTN_TITLE)-&gt;ShowWindow(SW_HIDE);</span><br></pre></td></tr></table></figure><p>而且从错误提示看，是个内存访问违例，很显然应该是 <code>GetDlgItem(IDC_BTN_TITLE)</code> 没取到对应的控件，返回了 <code>NULL</code>。这让我更虚了，因为这次主要的改动就是整理控件 <code>ID</code>。根据经验，很可能是 <code>IDC_BTN_TITLE</code> 宏的值与生成后的二进制资源没对应上。</p><p>使用 <code>resource hacker</code> 查看编译生成模块中的对话框资源，可以正常解析。又在 <code>vs</code> 中确认了 <code>IDC_BTN_TITLE</code> 的值，跟模块中的结果是匹配的。因为 <code>vs</code> 有时候会出现一些诡异的 <code>bug</code>，我又确认了对应的反汇编代码，确定一切都是正常的。</p><p>难道真的是我之前的认知出现了偏差？于是赶紧又写了一段测试代码，还是没问题。<code>google</code>、<code>bing</code>、<code>baidu</code> 都没搜到有用的资料。</p><p>难道就这样放弃，不处理了？放弃是不可能放弃的。找不到资料，只能自己调试了。</p><h2 id="上调试器"><a href="#上调试器" class="headerlink" title="上调试器"></a>上调试器</h2><p>一般调用某个 <code>API</code> 失败都会有错误码，可以通过 <code>GetLastError()</code> 或者在 <code>vs</code> 的 <code>watch</code> 窗口中输入 <code>$err,hr</code> 查看。</p><p><img src="http://resources.bianchengnan.tech/troubleshoot-crash-after-tidy-dialog-control-id/invalid_window_handle.png" alt="invalid_window_handle"></p><p>从错误提示可知，<strong>无效的窗口句柄</strong>，说明创建对话框的时候就失败了，而不是调用 <code>GetDlgItem(IDC_BTN_TITLE)</code> 在对话框中查找控件的时候才失败。这说得通，因为使用 <code>resource hacker</code> 查看到的资源确实是对的。</p><blockquote><p><strong>说明：</strong> </p><ol><li><p>为了更好的调查问题，我把原代码中的 <code>GetDlgItem(IDC_BTN_TITLE)-&gt;ShowWindow(SW_HIDE);</code> 拆分成了两句 <code>auto title = ::GetDlgItem(m_hWnd, IDC_BTN_TITLE); title-&gt;ShowWindow(SW_HIDE);</code></p></li><li><p><code>GetDlgItem(IDC_BTN_TITLE)</code> 内部会调用 <code>CWnd::FromHandle(::GetDlgItem(m_hWnd, nID));</code>，会导致 <code>LastError</code> 的值被覆盖。如下图：</p><p><img src="http://resources.bianchengnan.tech/troubleshoot-crash-after-tidy-dialog-control-id/failed_but_last_error_success.png" alt="failed_but_last_error_success"></p></li></ol></blockquote><p>但是对话框为什么会创建失败呢？调呗，单步步入对话框创建函数（这里用的是 <code>Create()</code>），发现跟不进去，因为没有对应的调试符号。<code>Create()</code> 失败后，使用<code>$err,hr</code> 或者手动调用 <code>GetLastError()</code> 函数得到的都是 <code>ERROR_SUCCESS</code>，没有任何帮助。到这里真有打退堂鼓的想法了。查也查不到，调也调不了（缺少调试符号，没法调试源码）。</p><blockquote><p><strong>说明：</strong> 当时调试的时候，是在内网环境，无法连接微软的符号服务器。</p></blockquote><h2 id="救星来了"><a href="#救星来了" class="headerlink" title="救星来了"></a>救星来了</h2><p>费了好大劲儿终于把调试符号拷贝到内网环境。但是因为调试符号与内网的 <code>dll</code> 不匹配，<code>vs</code> 又不能像 <code>windbg</code> 那样强制加载不匹配的调试符号。又折腾了半天符号加载的问题，使用 <code>chkmatch</code> 修改调试符号后， <code>vs</code> 还是加载不上。最后无奈，只能使用 <code>windbg</code> 调试了。</p><blockquote><p><strong>说明：</strong> 关于 <code>chkmatch</code> 还有一段故事，后面有机会总结成文，分享给大家</p></blockquote><h2 id="上-windbg"><a href="#上-windbg" class="headerlink" title="上 windbg"></a>上 windbg</h2><p>使用 <code>windbg</code> 附加进程后，加载好对应模块的调试符号并在调用 <code>Create()</code> 函数的地方设置好断点，然后让程序重新运行起来，中断后，单步步入（跟 <code>vs</code> 一样，<code>F11</code>），简单跟踪了一下，没发现异常。<code>::CreateDialogIndirect()</code> 返回 <code>NULL</code>，<code>LastError</code> 的值是 <code>0</code>。后面调试时，发现 <code>hInst</code> 的值有些奇怪，不是预期的模块。<code>hInst</code> 本来应该是 <code>AssemblyDesign_Tools.dll</code>，但是现在却是 <code>PBimsPCDrawing.dll</code>。</p><p><img src="http://resources.bianchengnan.tech/troubleshoot-crash-after-tidy-dialog-control-id/view-hInst-and-find-it-not-right.png" alt="view-hInst-and-find-it-not-right"></p><p>这很不正常！说明在创建对话框的时候，在错误的模块 <code>PBimsPCDrawing.dll</code> 中找到了对应 <code>ID</code> 值的对话框。手动修改 <code>PBimsPCDrawing.dll</code>  中相应的对话框 <code>ID</code> 为其它值，再次编译运行，果然不再崩溃了。</p><p>但是为什么在创建对话框的时候，会到 <code>PBimsPCDrawing.dll</code> 中查找，而不是到预期的  <code>AssemblyDesign_Tools.dll</code> 中查找呢？</p><h2 id="hInst-从哪来"><a href="#hInst-从哪来" class="headerlink" title="hInst 从哪来"></a>hInst 从哪来</h2><p>简单排查后发现 <code>hInst</code> 来自 <code>AfxFindResourceHandle()</code> 的返回值。此函数内部会按照如下顺序查找：</p><ol><li><p>如果 <code>AfxGetModuleState()</code> 不是系统模块（通过 <code>m_bSystem</code> 判断），则调用 <code>AfxGetResourceHandle()</code>，内部又会调用 <code>afxCurrentResourceHandle</code> 宏，展开后是 <code>AfxGetModuleState()-&gt;m_hCurrentResourceHandle</code>。</p></li><li><p>如果步骤 1 没找到的话，会继续到 <code>AfxGetModuleState()-&gt;m_libraryList</code> 列表里的<strong>非系统模块</strong>中查找。</p></li><li><p>如果步骤 2 也没找到的话，会到 <code>AfxGetModuleState()-&gt;m_appLangDll</code> 中找。</p></li><li><p>如果步骤 3 也没找到的话，并且当前是系统模块，会到 <code>AfxGetResourceHandle()</code> 中找。</p></li><li><p>如果步骤 4 也没找到的话，会继续到 <code>AfxGetModuleState()-&gt;m_libraryList</code> 列表里的<strong>系统模块</strong>中查找。</p></li><li><p>如果以上步骤都没找到的话，会直接返回 <code>AfxGetResourceHandle()</code>。</p></li></ol><p>在我们的程序中，在 <code>步骤 2</code> 找到了错误的模块。因为在我们的程序中，会把模块信息添加到 <code>AfxGetModuleState()-&gt;m_libraryList</code> 中，而且 <code>PBimsPCDrawing.dll</code> 在 <code>AssemblyDesign_Tools.dll</code> 前面。</p><blockquote><p><strong>说明：</strong> 根据上述逻辑，只要在创建对话框之前，调用 <code>AfxSetResourceHandle()</code> 把对话框所在的模块设置为当前的资源模块即可保证加载正确的对话框资源。</p></blockquote><h2 id="CDynLinkLibrary"><a href="#CDynLinkLibrary" class="headerlink" title="CDynLinkLibrary"></a>CDynLinkLibrary</h2><p>经过简单代码搜索，发现每个模块都会使用 <code>CDynLinkLibrary</code> 把自己加到 <code>AfxGetModuleState()-&gt;m_libraryList</code> 中。</p><p><code>CDynLinkLibrary</code> 的构造函数会保存传入的 <code>hModule</code>，并把自己加到 <code>m_pModuleState-&gt;m_libraryList</code> 中。</p><p><img src="http://resources.bianchengnan.tech/troubleshoot-crash-after-tidy-dialog-control-id/cdynlinklibrary-constructor.png" alt="cdynlinklibrary-constructor"></p><p>至此，基本弄清了创建对话框失败的原因 —— <code>AfxFindResourceHandle()</code>  返回了错误的模块。</p><p><code>AssemblyDesign_Tools.dll</code> 模块<strong>先</strong>被加载，在其 <code>DllMain()</code> 中把自己加到 <code>AfxGetModuleState()-&gt;m_libraryList</code> 中，然后 <code>PBimsPCDrawing.dll</code> 模块也被加载，也在 <code>DllMain()</code> 中把自己添加到 <code>AfxGetModuleState()-&gt;m_libraryList</code> 中，而且添加到 <code>AssemblyDesign_Tools.dll</code> 模块的前面。当创建 <code>AssemblyDesign_Tools.dll</code> 中的对话框时，如果 <code>PBimsPCDrawing.dll</code> 模块中包含相同 <code>ID</code> 的对话框，那么会加载错误模块中的对话框资源。</p><h2 id="收工？"><a href="#收工？" class="headerlink" title="收工？"></a>收工？</h2><p>本以为到此就可以再水一篇文章了。但是当我在本地按照上述逻辑新建测试工程，准备重现时，发现测试程序能正常创建对话框。调试确认在创建 <code>Dialog1</code> 中的对话框时，<code>AfxFindResourceHandle()</code> 返回的确实是另外一个模块的句柄。</p><p>为什么同样是找到了错误的模块，在测试程序中创建对话框成功了，但是在实际项目中却创建失败了？看来，虽然加载了其它模块的对话框资源，但是创建对话框不一定会失败。难道是其它原因导致的崩溃？</p><h2 id="继续调查"><a href="#继续调查" class="headerlink" title="继续调查"></a>继续调查</h2><p>使用 <code>windbg</code> 附加到进程，中断下来后，执行到创建对话框的关键函数 <code>::CreateDialogIndirect()</code> （实际上是从此函数开始没有源码可跟了）。在此函数开头位置执行 <code>wt</code>，经过漫长的等待，查看统计结果，发现有对 <code>win32u!NtUserCreateWindowEx</code> 的调用。</p><p>在 <code>win32u!NtUserCreateWindowEx()</code> 中设置断点，重新运行程序。中断后，执行 <code>gu</code> 让该函数执行完，然后执行 <code>r</code> 命令查看寄存器，<code>rax</code> 寄存器保存了执行结果。当 <code>rax</code> 的值是 <code>0</code> 时，说明创建窗体失败了。这时候执行 <code>!gle</code> 可知错误码是 <code>0x57f</code>（也就是十进制的 <code>1407</code>）。</p><p><img src="http://resources.bianchengnan.tech/troubleshoot-crash-after-tidy-dialog-control-id/createwindow-return-0-last-error-1407.png" alt="createwindow-return-0-last-error-1407"></p><p>经过查询可知，这个错误码是 <strong>ERROR_CANNOT_FIND_WND_CLASS</strong>，也就是 <strong>找不到窗口类</strong>。居然是窗口类没有注册！要知道一般的控件已经注册过了。遇到窗口类没注册的错误，大概率是使用了自定义控件类。</p><blockquote><p><strong>说明：</strong> 可以使用如下命令在 <code>NtUserCreateWindowEx()</code> 失败时自动中断下来，并显示 <code>LastError</code>。</p><p><code>bp win32u!NtUserCreateWindowEx &quot;bp /1 @$ra \&quot;.if (@rax == 0) {.echo ****; r; !gle } .else {gc;}\&quot;;gc;&quot;</code></p><p><code>@$ra</code> 表示返回地址。<code>bp /1 @$ra</code> 表示在函数返回地址处设置一次性断点。</p></blockquote><h2 id="MFCGridCtrl"><a href="#MFCGridCtrl" class="headerlink" title="MFCGridCtrl"></a>MFCGridCtrl</h2><p>于是赶紧查看 <code>.rc</code> 中对应的对话框内容，发现了一个可疑的控件 —— <code>MFCGridCtrl</code>。</p><p><img src="http://resources.bianchengnan.tech/troubleshoot-crash-after-tidy-dialog-control-id/dialog-custom-control-MFCGridCtrl.png" alt="dialog-custom-control-MFCGridCtrl"></p><p>这个名字太有迷惑性了，乍一看还以为是 <code>MFC</code> 提供的呢。<code>google</code> 之后发现是三方控件，源码可以在 <a href="https://www.codeproject.com/Articles/8/MFC-Grid-control-2-27" target="_blank" rel="noopener">codeproject</a> 上找到。</p><p>下载相应源码并把关键文件添加到项目中，关联好对应的控件后，重新编译运行，这次果然没报错了。</p><h2 id="破案"><a href="#破案" class="headerlink" title="破案"></a>破案</h2><p>至此，这个问题算是水落石出了 —— 实际项目中创建对话框失败是因为对话框中使用了未注册窗口类的控件。创建对话框的时候会依次创建对话框中的控件，在创建这个没注册窗口类的控件时失败了，从而导致整个对话框创建失败。</p><h2 id="这个-bug-这么长寿？"><a href="#这个-bug-这么长寿？" class="headerlink" title="这个 bug 这么长寿？"></a>这个 bug 这么长寿？</h2><p>按理说，这个问题应该很容易被测试出来才对。带着这个疑问，搜索了一下项目代码，发现已经没有代码在使用这个对话框了。所以，实际项目中不会出问题。直到这次意外的 “撞衫”，这个问题才显现出来，有点“坑”。</p><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>后来在折腾符号加载时，发现 <code>chkmatch</code> 修改完的调试符号是可以被 <code>vs</code> 加载的。是我当时手动修改 <code>dll</code> 名字的时候改错了，<code>vs</code> 在加载 <code>mfc140u.dll</code> 的调试符号时，只会查找名字为 <code>mfc140u.amd64.pdb</code> 的调试符号，而我却手动改成了 <code>mfc140u.pdb</code>，所以 <code>vs</code> 加载调试符号失败了。可以在<strong>模块</strong>对话框（可以通过 <code>ctrl + alt + u</code> 打开）中指定的模块上<strong>右键</strong>，<strong>符号加载信息</strong> 查看某个模块对应的符号文件加载信息。</p><p><img src="http://resources.bianchengnan.tech/troubleshoot-crash-after-tidy-dialog-control-id/mfc140u.amd64.pdb.png" alt="mfc140u.amd64.pdb"></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li><p>调试符号对于调试简直太重要了。</p></li><li><p>创建对话框之前，务必确保对话框所在的模块是默认的资源模块，否则可能加载到其它模块中的对话框资源。</p></li><li><p>不同对话框中的控件 <code>ID</code> 可以重复，但是同一个对话框中的控件 <code>ID</code> 不能重复。</p></li><li><p>一般 <code>vs</code> 不能加载不匹配的调试符号，可以使用 <code>chkmatch</code> 修改 <code>pdb</code> 使其与 <code>dll</code> 匹配。</p></li></ul><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://learn.microsoft.com/en-us/windows/win32/debug/system-error-codes--1300-1699-" target="_blank" rel="noopener">https://learn.microsoft.com/en-us/windows/win32/debug/system-error-codes--1300-1699-</a></p><p><a href="https://learn.microsoft.com/en-us/cpp/mfc/reference/afx-extension-module-structure?view=msvc-170" target="_blank" rel="noopener">https://learn.microsoft.com/en-us/cpp/mfc/reference/afx-extension-module-structure?view=msvc-170</a></p><p><a href="https://learn.microsoft.com/en-us/previous-versions/visualstudio/visual-studio-2010/0asx94f7(v=vs.100)" target="_blank" rel="noopener">https://learn.microsoft.com/en-us/previous-versions/visualstudio/visual-studio-2010/0asx94f7(v=vs.100)</a></p><p><a href="https://learn.microsoft.com/en-us/previous-versions/visualstudio/visual-studio-2010/30c674tx(v=vs.100)?redirectedfrom=MSDN" target="_blank" rel="noopener">https://learn.microsoft.com/en-us/previous-versions/visualstudio/visual-studio-2010/30c674tx(v=vs.100)?redirectedfrom=MSDN</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;缘起&quot;&gt;&lt;a href=&quot;#缘起&quot; class=&quot;headerlink&quot; title=&quot;缘起&quot;&gt;&lt;/a&gt;缘起&lt;/h2&gt;&lt;p&gt;实际项目中，&lt;code&gt;resource.h&lt;/code&gt; 文件中的控件太多太乱了，合并代码的时候非常痛苦。为了解决这个问题，需要对 &lt;code&gt;resource.h&lt;/code&gt; 中的 &lt;code&gt;ID&lt;/code&gt; 进行整理。根据之前整理的成果，很快把控件 &lt;code&gt;ID&lt;/code&gt; 按对话框分类整理好了。没想到测试的时候遇到了各种崩溃，废了好大劲儿才解决。究其原因，是对 &lt;code&gt;MFC&lt;/code&gt; 资源管理机制认识不够深刻。尝试创建某个模块内的对话框的时候，意外地找到了其它模块中的对话框资源。&lt;code&gt;MFC&lt;/code&gt; 到底是怎么查找资源模块的呢？应该如何排查这种问题呢？一起来看看吧。&lt;/p&gt;
    
    </summary>
    
      <category term="调试" scheme="https://bianchengnan.github.io/categories/%E8%B0%83%E8%AF%95/"/>
    
    
      <category term="原" scheme="https://bianchengnan.github.io/tags/%E5%8E%9F/"/>
    
      <category term="总结" scheme="https://bianchengnan.github.io/tags/%E6%80%BB%E7%BB%93/"/>
    
      <category term="调试" scheme="https://bianchengnan.github.io/tags/%E8%B0%83%E8%AF%95/"/>
    
      <category term="windbg" scheme="https://bianchengnan.github.io/tags/windbg/"/>
    
      <category term="pdb" scheme="https://bianchengnan.github.io/tags/pdb/"/>
    
      <category term="chkmatch" scheme="https://bianchengnan.github.io/tags/chkmatch/"/>
    
      <category term="mfc" scheme="https://bianchengnan.github.io/tags/mfc/"/>
    
  </entry>
  
  <entry>
    <title>如何查找已注册消息的名称?</title>
    <link href="https://bianchengnan.github.io//articles/how-to-find-registered-message-name/"/>
    <id>https://bianchengnan.github.io//articles/how-to-find-registered-message-name/</id>
    <published>2023-10-22T03:40:01.000Z</published>
    <updated>2024-12-21T04:02:50.300Z</updated>
    
    <content type="html"><![CDATA[<h2 id="TL-DR"><a href="#TL-DR" class="headerlink" title="TL;DR"></a>TL;DR</h2><p>在 <code>Windows</code> 中，通过 <a href="https://learn.microsoft.com/en-us/windows/win32/api/winuser/nf-winuser-registerwindowmessagew" target="_blank" rel="noopener">RegisterWindowMessage()</a> 注册的消息，其消息 <code>ID</code> 在 <code>0xC000 ~ 0xFFFF</code> 之间。可以使用 <a href="https://learn.microsoft.com/en-us/windows/win32/api/winuser/nf-winuser-getclipboardformatnamew" target="_blank" rel="noopener">GetClipboardFormatName()</a> 根据消息 <code>ID</code> 反向查找已注册消息的名称。</p><a id="more"></a><h2 id="缘起"><a href="#缘起" class="headerlink" title="缘起"></a>缘起</h2><p>前一阵子，我在学习 <code>c#</code> 中的 <code>async/await</code> 工作机制时遇到了一个有趣的现象 —— 在下列代码片段中，<code>await</code> 后面的代码是在 <code>UI</code> 线程执行的，不论执行多少次，都是在 <code>UI</code> 线程中执行的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">private async void Button2_Click(object sender, EventArgs e)</span><br><span class="line">&#123;</span><br><span class="line">  Debug.WriteLine(string.Format(&quot;Btn Click Begin(), in thread &#123;0&#125;&quot;, Thread.CurrentThread.ManagedThreadId));</span><br><span class="line">  await Task.Delay(10000);</span><br><span class="line">  Debug.WriteLine(string.Format(&quot;Btn Click End(), in thread &#123;0&#125;&quot;, Thread.CurrentThread.ManagedThreadId));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果把 <code>Button2_Click</code> 中的三行代码放到控制台程序中，<code>await</code> 后面的代码会在哪个线程执行，是不确定的，很有可能与 <code>await</code> 前面的那行代码不在同一个线程中。</p><p><code>await</code> 后面的代码会在哪个线程中执行，情况非常复杂，不在本文讨论范围。</p><p>那么问题来了，为什么 <code>await</code> 后面的代码可以在 <code>UI</code> 线程执行呢？或者说是怎么做到的呢？</p><h2 id="查看调用栈"><a href="#查看调用栈" class="headerlink" title="查看调用栈"></a>查看调用栈</h2><p>通过下图中的调用栈可以猜测，<code>await</code> 后面的代码能在 <code>UI</code> 线程执行是通过消息机制实现的。</p><p><img src="http://resources.bianchengnan.tech/how-to-find-registered-message-name/async-await-msg.png" alt="async-await-msg"></p><p>而且根据上图中调用栈信息可知，这是一个已注册的消息，因为消息 <code>ID</code> 为<code>0xc396</code>，位于<code>0xC000 ~ 0xFFFF</code> 的范围内。根据 <a href="https://learn.microsoft.com/en-us/windows/win32/winmsg/about-messages-and-message-queues#system-defined-messages" target="_blank" rel="noopener">MSDN 文档</a> 可知，这个消息是通过 <code>RegisterWindowMessage()</code> 注册的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">The system returns a message identifier in the range 0xC000 through 0xFFFF when an application calls the RegisterWindowMessage function to register a message. The message identifier returned by this function is guaranteed to be unique throughout the system. Use of this function prevents conflicts that can arise if other applications use the same message identifier for different purposes.</span><br></pre></td></tr></table></figure><p>那么本文的重点来了，这个注册的消息对应的名字是什么？因为数字对我们来说是冰冷的，无意义的，名字才是有意义的。</p><h2 id="注册消息的名字"><a href="#注册消息的名字" class="headerlink" title="注册消息的名字"></a>注册消息的名字</h2><p>在 <code>google</code> 中输入 <code>get registered message name</code>，第一条记录是 <code>stackoverflow</code> 上的一篇<a href="https://stackoverflow.com/questions/40417023/get-name-of-message-registered-by-registerwindowmessage" target="_blank" rel="noopener">文章</a>，里面介绍了可以通过 <a href="https://learn.microsoft.com/en-us/windows/win32/api/winuser/nf-winuser-getclipboardformatnamew" target="_blank" rel="noopener">GetClipboardFormatName()</a> 来根据消息 <code>ID</code> 获取对应的消息名字。这是因为操作系统内部将已注册的消息视为剪贴板格式，并且 <code>GetClipboardFormatName()</code> 函数可以根据特定格式获取名称。</p><h2 id="测试代码"><a href="#测试代码" class="headerlink" title="测试代码"></a>测试代码</h2><p>以下是使用 <code>C#</code> 编写的获取注册消息名称的示例代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">[DllImport(&quot;user32.dll&quot;)]</span><br><span class="line">static extern int GetClipboardFormatName(int format, StringBuilder lpszFormatName, int cchMaxCount);</span><br><span class="line"></span><br><span class="line">public static string GetRegisteredMessageName(int msg)</span><br><span class="line">&#123;</span><br><span class="line">  var sb = new StringBuilder(256);</span><br><span class="line">  GetClipboardFormatName(msg, sb, sb.Capacity);</span><br><span class="line">  return sb.ToString();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static void Main(string[] args)</span><br><span class="line">&#123;</span><br><span class="line">  try</span><br><span class="line">  &#123;</span><br><span class="line">    int msgId = Convert.ToInt32(args[0], 16);</span><br><span class="line">    Console.WriteLine(string.Format(&quot;MsgName: &#123;0&#125;&quot;, GetRegisteredMessageName(msgId)));</span><br><span class="line">  &#125;</span><br><span class="line">  catch (Exception)</span><br><span class="line">  &#123;</span><br><span class="line">    Console.WriteLine(&quot;Usage: GetRegisteredMessageName 0xc001&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>希望本篇文章可以帮助您了解如何查找已注册消息的名称。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><code>await</code> 后面的代码执行在哪个线程中是不确定的，写代码的时候要注意线程相关问题。</p><p>可以使用 <code>GetClipboardFormatName()</code> 获取注册的消息名称。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://stackoverflow.com/questions/40417023/get-name-of-message-registered-by-registerwindowmessage" target="_blank" rel="noopener">https://stackoverflow.com/questions/40417023/get-name-of-message-registered-by-registerwindowmessage</a></p><p><a href="https://linux.m2osw.com/recover-name-message-registered-registerwindowmessage" target="_blank" rel="noopener">https://linux.m2osw.com/recover-name-message-registered-registerwindowmessage</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;TL-DR&quot;&gt;&lt;a href=&quot;#TL-DR&quot; class=&quot;headerlink&quot; title=&quot;TL;DR&quot;&gt;&lt;/a&gt;TL;DR&lt;/h2&gt;&lt;p&gt;在 &lt;code&gt;Windows&lt;/code&gt; 中，通过 &lt;a href=&quot;https://learn.microsoft.com/en-us/windows/win32/api/winuser/nf-winuser-registerwindowmessagew&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;RegisterWindowMessage()&lt;/a&gt; 注册的消息，其消息 &lt;code&gt;ID&lt;/code&gt; 在 &lt;code&gt;0xC000 ~ 0xFFFF&lt;/code&gt; 之间。可以使用 &lt;a href=&quot;https://learn.microsoft.com/en-us/windows/win32/api/winuser/nf-winuser-getclipboardformatnamew&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;GetClipboardFormatName()&lt;/a&gt; 根据消息 &lt;code&gt;ID&lt;/code&gt; 反向查找已注册消息的名称。&lt;/p&gt;
    
    </summary>
    
      <category term="调试" scheme="https://bianchengnan.github.io/categories/%E8%B0%83%E8%AF%95/"/>
    
    
      <category term="原" scheme="https://bianchengnan.github.io/tags/%E5%8E%9F/"/>
    
      <category term="总结" scheme="https://bianchengnan.github.io/tags/%E6%80%BB%E7%BB%93/"/>
    
      <category term="async" scheme="https://bianchengnan.github.io/tags/async/"/>
    
      <category term="await" scheme="https://bianchengnan.github.io/tags/await/"/>
    
      <category term="消息" scheme="https://bianchengnan.github.io/tags/%E6%B6%88%E6%81%AF/"/>
    
      <category term="windows" scheme="https://bianchengnan.github.io/tags/windows/"/>
    
  </entry>
  
  <entry>
    <title>调试实战 | 解决另外一个链接错误</title>
    <link href="https://bianchengnan.github.io//articles/troubleshoot-LNK2001-unresovled-external-symbol-error/"/>
    <id>https://bianchengnan.github.io//articles/troubleshoot-LNK2001-unresovled-external-symbol-error/</id>
    <published>2023-10-22T03:30:01.000Z</published>
    <updated>2024-12-21T04:02:50.772Z</updated>
    
    <content type="html"><![CDATA[<h2 id="缘起"><a href="#缘起" class="headerlink" title="缘起"></a>缘起</h2><p>最近，在加班的过程中遇到一个链接错误 —— <code>fatal error LNK1120: 1 unresolved externals</code>。这种错误是老朋友了，对我这种常年写 <code>bug</code> 的老手来说，完全不是事儿，轻松+愉快。</p><p>根据以下的排查思路基本上能解决大多数链接错误：</p><p>既然报了链接错误，说明编译已经通过了，问题基本出现在库文件上。</p><p>有可能是找不到库文件（缺少库，或者库文件搜索路径不对），可以先确认工程配置是否正确或者使用 <code>/verbose:lib</code> 查看链接过程。</p><p>也可能是库文件不对（没包含对应的导出符号），可以通过 <code>dumpbin /exports error.lib &gt; error.txt</code> 查看 <code>lib</code> 库中的导出符号。按照以上步骤排查基本上可以解决绝大多数链接错误。</p><p>好的，让我们一起来实战一下吧。</p><a id="more"></a><blockquote><p><strong>说明：</strong> 实际项目需要保密，本文的截图是我在本地用测试工程做的。</p></blockquote><h2 id="确保-lib-存在并且路径正确"><a href="#确保-lib-存在并且路径正确" class="headerlink" title="确保 lib 存在并且路径正确"></a>确保 lib 存在并且路径正确</h2><p>通过查看工程设置可以得知，依赖的库文件是 <code>TestLNK1120Dll.lib</code>，附加库目录中也添加了这个 <code>lib</code> 所在的路径。肉眼看上去没问题。为了保险（之前遇到过更诡异的错误，配置看上去都对，但是实际的值不对），还是通过 <code>/verbose:lib</code> 选项看一下链接过程。</p><p>在对应工程上，<code>右键 -&gt; 属性 -&gt; Configuration Property -&gt; Linker -&gt; Command Line</code>，在 <code>Additional Options</code> 下面输入 <code>/verbose:lib</code> 即可。</p><p><img src="http://resources.bianchengnan.tech/troubleshoot-LNK2001-unresovled-external-symbol-error/link-option-verbose-lib.png" alt="link-option-verbose-lib"></p><p>设置好后，重新编译。可以看到链接时整个库查找过程，如下图。</p><p><img src="http://resources.bianchengnan.tech/troubleshoot-LNK2001-unresovled-external-symbol-error/verbose-lib-link-process.png" alt="verbose-lib-link-process"></p><p>至此，可以确定库文件路径配置没错，那大概率是库文件中的符号与程序中的符号不匹配导致的。</p><blockquote><p><strong>说明：</strong> 如果找不到 <code>.lib</code> 文件，报错应该类似下面这样：</p><p><code>fatal error LNK1104: cannot open file &#39;TestLNK1120Dll.lib&#39;</code></p></blockquote><h2 id="查看-lib-文件中的导出符号"><a href="#查看-lib-文件中的导出符号" class="headerlink" title="查看 lib 文件中的导出符号"></a>查看 lib 文件中的导出符号</h2><p>使用 <code>dumpbin</code> 可以查看 <code>lib</code> 库中的所有导出符号，命令如下：</p><p><code>dumpbin /exports d:\test\TestLNK1120.lib &gt; d:\TestLNK1120.txt</code></p><blockquote><p><strong>注意：</strong> 以上命令需要在 <code>dumpbin.exe</code> 所在目录下执行，或者启动 <code>Developer Command Prompt for VS xxx</code>。</p></blockquote><p>然后根据 <code>vs</code> 编译错误提示中的符号在 <code>TestLNK1120.txt</code> 中搜索，应该是没有匹配项目。</p><h2 id="搜索报错的符号"><a href="#搜索报错的符号" class="headerlink" title="搜索报错的符号"></a>搜索报错的符号</h2><p>确实可以在 <code>TestLNK1120.txt</code> 中根据函数名 <code>GetStaticData</code> 搜到相关记录，但是根据完整的符号名称搜不到。</p><p><code>TestLNK1120.txt</code> 文件中与 <code>GetStaticData</code> 相关的内容是：</p><p><code>?GetStaticData@@YAAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ (class std::basic_string&lt;char,struct std::char_traits&lt;char&gt;,class std::allocator&lt;char&gt; &gt; &amp; __cdecl GetStaticData(void))</code></p><p>而 <code>vs</code> 报错提示是：</p><p><code>TestLNK1120.obj : error LNK2001: unresolved external symbol &quot;class std::basic_string&lt;char,struct std::char_traits&lt;char&gt;,class std::allocator&lt;char&gt; &gt; __cdecl GetStaticData(void)&quot; (?GetStaticData@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ)</code></p><p>让我们对比一下这两个结果哪里不一样。</p><h2 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h2><p>别看上面的输出很多很乱，其实我们最需要关心的是经过名字改编的符号名。</p><p><code>vs</code> 中经过名字改编后的符号名是</p><p><code>?GetStaticData@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ</code></p><p><code>lib</code> 库中经过名字改编后的符号名是</p><p><code>?GetStaticData@@YAAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ</code></p><p>如果仔细看，确实能发现这两个输出结果是不一样的，但是经过编译器处理的符号名非常不适合人类阅读。如果能看到函数原型就太好了。</p><p>其实，上面的输出结果既包含了函数原型，又包含了经过名字改编后的符号名。</p><p><code>vs</code> 中的函数名：</p><p><code>class std::basic_string&lt;char,struct std::char_traits&lt;char&gt;,class std::allocator&lt;char&gt; &gt; __cdecl GetStaticData(void)</code></p><p><code>lib</code> 库中的函数名：</p><p><code>class std::basic_string&lt;char,struct std::char_traits&lt;char&gt;,class std::allocator&lt;char&gt; &gt; &amp; __cdecl GetStaticData(void)</code></p><p>可以发现，<code>lib</code> 库中提供的函数的返回值是引用类型的，而 <code>vs</code> 中函数的返回值是不带引用的。</p><p>至此就破案了！</p><h2 id="undname-工具"><a href="#undname-工具" class="headerlink" title="undname 工具"></a>undname 工具</h2><p>如果只有经过名字改编后的符号名，可以通过微软提供的 <code>undname.exe</code> 工具来翻译成人类友好的名称。</p><p><img src="http://resources.bianchengnan.tech/troubleshoot-LNK2001-unresovled-external-symbol-error/compare-undname.png" alt="compare-undname"></p><h2 id="示例工程"><a href="#示例工程" class="headerlink" title="示例工程"></a>示例工程</h2><p>可以到 <a href="https://github.com/bianchengnan/MyBlogStuff/tree/master/troubleshoot-LNK2001-unresovled-external-symbol-error/TestLnk2001" target="_blank" rel="noopener">github</a> 上下载示例工程。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><code>dumpbin.exe</code> 可以查看 <code>lib</code> 库中的符号信息</p><p><code>undname.exe</code> 可以非常方便的查看未经过编译器处理的函数名</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;缘起&quot;&gt;&lt;a href=&quot;#缘起&quot; class=&quot;headerlink&quot; title=&quot;缘起&quot;&gt;&lt;/a&gt;缘起&lt;/h2&gt;&lt;p&gt;最近，在加班的过程中遇到一个链接错误 —— &lt;code&gt;fatal error LNK1120: 1 unresolved externals&lt;/code&gt;。这种错误是老朋友了，对我这种常年写 &lt;code&gt;bug&lt;/code&gt; 的老手来说，完全不是事儿，轻松+愉快。&lt;/p&gt;
&lt;p&gt;根据以下的排查思路基本上能解决大多数链接错误：&lt;/p&gt;
&lt;p&gt;既然报了链接错误，说明编译已经通过了，问题基本出现在库文件上。&lt;/p&gt;
&lt;p&gt;有可能是找不到库文件（缺少库，或者库文件搜索路径不对），可以先确认工程配置是否正确或者使用 &lt;code&gt;/verbose:lib&lt;/code&gt; 查看链接过程。&lt;/p&gt;
&lt;p&gt;也可能是库文件不对（没包含对应的导出符号），可以通过 &lt;code&gt;dumpbin /exports error.lib &amp;gt; error.txt&lt;/code&gt; 查看 &lt;code&gt;lib&lt;/code&gt; 库中的导出符号。按照以上步骤排查基本上可以解决绝大多数链接错误。&lt;/p&gt;
&lt;p&gt;好的，让我们一起来实战一下吧。&lt;/p&gt;
    
    </summary>
    
      <category term="调试" scheme="https://bianchengnan.github.io/categories/%E8%B0%83%E8%AF%95/"/>
    
    
      <category term="原" scheme="https://bianchengnan.github.io/tags/%E5%8E%9F/"/>
    
      <category term="总结" scheme="https://bianchengnan.github.io/tags/%E6%80%BB%E7%BB%93/"/>
    
      <category term="调试" scheme="https://bianchengnan.github.io/tags/%E8%B0%83%E8%AF%95/"/>
    
      <category term="vs" scheme="https://bianchengnan.github.io/tags/vs/"/>
    
      <category term="链接错误" scheme="https://bianchengnan.github.io/tags/%E9%93%BE%E6%8E%A5%E9%94%99%E8%AF%AF/"/>
    
      <category term="LNK" scheme="https://bianchengnan.github.io/tags/LNK/"/>
    
  </entry>
  
</feed>
